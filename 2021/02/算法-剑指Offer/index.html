<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>剑指Offer | Lsmg的大学之路</title>
  <meta name="keywords" content="">
  <meta name="description" content="剑指Offer | Lsmg的大学之路">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="背景项目使用Unity开发，使用过程中可以明显内存有异常增长，所以排查了一下原因，做一下记录。 分三步描述  寻找异常内存分配时的地址 寻找异常内存分配的堆栈 寻找对应的项目代码  寻找异常内存分配时的地址后台用的工具使用massif可以详细打印内存分配时的堆栈信息，但是没有Windows版本，询问GPT后得到了下面几个工具。  Unity自带的Profile vs2022 vmmap64  工具">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows下Unity内存泄露排查">
<meta property="og:url" content="http://blog.lsmg.xyz/2024/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-Windows%E4%B8%8BUnity%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%8E%92%E6%9F%A5/index.html">
<meta property="og:site_name" content="Lsmg的大学之路">
<meta property="og:description" content="背景项目使用Unity开发，使用过程中可以明显内存有异常增长，所以排查了一下原因，做一下记录。 分三步描述  寻找异常内存分配时的地址 寻找异常内存分配的堆栈 寻找对应的项目代码  寻找异常内存分配时的地址后台用的工具使用massif可以详细打印内存分配时的堆栈信息，但是没有Windows版本，询问GPT后得到了下面几个工具。  Unity自带的Profile vs2022 vmmap64  工具">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-11-14T19:48:22.000Z">
<meta property="article:modified_time" content="2025-02-27T06:39:40.173Z">
<meta property="article:author" content="Lsmg">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Lsmg的大学之路" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Lsmg</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:jaytp@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=872336115&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(87)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="CPP">
                        <i class="fold iconfont icon-right"></i>
                        
                        CPP
                        <small>(14)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="CPP<--->源码学习">
                                        
                                        源码学习
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="Linux">
                        
                        Linux
                        <small>(9)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="UE5">
                        
                        UE5
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="个人记录">
                        
                        个人记录
                        <small>(8)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="优化">
                        
                        优化
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="分享会">
                        
                        分享会
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="学习记录">
                        
                        学习记录
                        <small>(11)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="工具使用">
                        <i class="fold iconfont icon-right"></i>
                        
                        工具使用
                        <small>(2)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="工具使用<--->Git操作">
                                        
                                        Git操作
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="日语">
                        
                        日语
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="模块设计">
                        
                        模块设计
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="算法">
                        
                        算法
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="网络编程">
                        
                        网络编程
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="计算机网络">
                        
                        计算机网络
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="读书记录">
                        
                        读书记录
                        <small>(20)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="采坑记">
                        
                        采坑记
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="项目制作">
                        
                        项目制作
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="87">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ebpf</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>GDB调试</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Git操作</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HTTPS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Shell</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spf-13</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>UP</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>常用命令</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>方向选择</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>时间触发器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>编译加速</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>采坑记</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a id="top" class="All 日语 "
           href="/2023/03/%E6%97%A5%E8%AF%AD-GPT%E7%AD%94%E7%96%91%E8%AE%B0%E5%BD%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GPT答疑记录">GPT答疑记录</span>
            <span class="post-date" title="2023-03-26 10:37:20">2023/03/26</span>
        </a>
        
        
        <a id="top" class="All 日语 "
           href="/2023/03/%E6%97%A5%E8%AF%AD-%E4%BA%94%E5%A4%A7%E6%80%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="五大态">五大态</span>
            <span class="post-date" title="2023-03-26 10:37:20">2023/03/26</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2023/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95180-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="性能之巅">性能之巅</span>
            <span class="post-date" title="2023-03-21 23:37:20">2023/03/21</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2022/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95170-%E6%88%91%E6%98%AF%E4%B8%80%E5%8F%AAIT%E5%B0%8F%E5%B0%8F%E9%B8%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="我是一只IT小小鸟">我是一只IT小小鸟</span>
            <span class="post-date" title="2022-05-30 19:09:20">2022/05/30</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2022/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95161-%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="现代C++教程">现代C++教程</span>
            <span class="post-date" title="2022-05-31 19:09:20">2022/05/31</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2021/04/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95160-TCPIP%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TCP/IP详解">TCP/IP详解</span>
            <span class="post-date" title="2021-04-03 19:09:20">2021/04/03</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2021/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95150-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux内核设计精髓">Linux内核设计精髓</span>
            <span class="post-date" title="2021-03-28 19:09:20">2021/03/28</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2021/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95140-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="程序员的自我修养">程序员的自我修养</span>
            <span class="post-date" title="2021-03-17 19:09:20">2021/03/17</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2020/09/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95135-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深度探索C++对象模型">深度探索C++对象模型</span>
            <span class="post-date" title="2020-09-15 15:17:39">2020/09/15</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2021/04/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95131-%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码整洁之道">代码整洁之道</span>
            <span class="post-date" title="2021-04-28 08:19:39">2021/04/28</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2020/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码大全">代码大全</span>
            <span class="post-date" title="2020-05-13 21:19:39">2020/05/13</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2022/02/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95120-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux多线程服务器端编程">Linux多线程服务器端编程</span>
            <span class="post-date" title="2022-02-15 17:19:39">2022/02/15</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2020/02/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95110-Effective%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="EffectiveCpp读书记录">EffectiveCpp读书记录</span>
            <span class="post-date" title="2020-02-26 21:43:46">2020/02/26</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2020/02/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95102-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux高性能服务器-进程线程">Linux高性能服务器-进程线程</span>
            <span class="post-date" title="2020-02-25 22:34:39">2020/02/25</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2019/08/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95101-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux高性能服务器-高级部分">Linux高性能服务器-高级部分</span>
            <span class="post-date" title="2019-08-18 20:34:39">2019/08/18</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2019/08/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95100-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux高性能服务器-初级部分">Linux高性能服务器-初级部分</span>
            <span class="post-date" title="2019-08-17 20:34:39">2019/08/17</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2020/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9599-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux高性能服务器-理论部分">Linux高性能服务器-理论部分</span>
            <span class="post-date" title="2020-03-06 22:53:00">2020/03/06</span>
        </a>
        
        
        <a id="top" class="All 算法 "
           href="/2021/02/%E7%AE%97%E6%B3%9590-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构和STL">数据结构和STL</span>
            <span class="post-date" title="2021-02-05 10:38:28">2021/02/05</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2019/08/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9580-CPPPrimer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++Primer学习">C++Primer学习</span>
            <span class="post-date" title="2019-08-16 19:13:22">2019/08/16</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2024/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-Windows%E4%B8%8BUnity%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%8E%92%E6%9F%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Windows下Unity内存泄露排查">Windows下Unity内存泄露排查</span>
            <span class="post-date" title="2024-11-14 19:48:22">2024/11/14</span>
        </a>
        
        
        <a  class="All 优化 "
           href="/2024/11/%E4%BC%98%E5%8C%96-%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F2/"
           data-tag="编译加速"
           data-author="" >
            <span class="post-title" title="CMake项目常见的编译加速方式汇总">CMake项目常见的编译加速方式汇总</span>
            <span class="post-date" title="2024-11-13 14:48:22">2024/11/13</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2024/07/CPP-CMAKE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CMAKE&amp;Make">CMAKE&amp;Make</span>
            <span class="post-date" title="2024-07-02 17:07:45">2024/07/02</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2024/06/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E7%89%882/"
           data-tag="UP"
           data-author="" >
            <span class="post-title" title="如何更好的添砖加瓦2">如何更好的添砖加瓦2</span>
            <span class="post-date" title="2024-06-24 09:48:22">2024/06/24</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2024/04/Linux-massif/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="massif使用">massif使用</span>
            <span class="post-date" title="2024-04-13 16:31:22">2024/04/13</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2024/03/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E5%B8%B8%E4%BA%8BUP/"
           data-tag="UP"
           data-author="" >
            <span class="post-title" title="常事UP">常事UP</span>
            <span class="post-date" title="2024-03-23 14:48:22">2024/03/23</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2024/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%8E%92%E8%A1%8C%E6%A6%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="排行榜">排行榜</span>
            <span class="post-date" title="2024-01-25 14:38:08">2024/01/25</span>
        </a>
        
        
        <a  class="All 优化 "
           href="/2023/12/%E4%BC%98%E5%8C%96-%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F/"
           data-tag="编译加速"
           data-author="" >
            <span class="post-title" title="编译加速">编译加速</span>
            <span class="post-date" title="2023-12-13 14:48:22">2023/12/13</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2023/12/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/"
           data-tag="方向选择"
           data-author="" >
            <span class="post-title" title="方向选择">方向选择</span>
            <span class="post-date" title="2023-12-11 19:48:22">2023/12/11</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2023/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E7%89%88/"
           data-tag="UP"
           data-author="" >
            <span class="post-title" title="如何更好的添砖加瓦">如何更好的添砖加瓦</span>
            <span class="post-date" title="2023-11-25 09:48:22">2023/11/25</span>
        </a>
        
        
        <a  class="All 项目制作 "
           href="/2023/11/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-PrometheusX%E7%81%AB%E7%84%B0%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何实现火焰图半自由">如何实现火焰图半自由</span>
            <span class="post-date" title="2023-11-18 12:50:02">2023/11/18</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2023/11/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%86%99%E5%8D%9A%E5%AE%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="写博客技巧">写博客技巧</span>
            <span class="post-date" title="2023-11-15 10:38:08">2023/11/15</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E6%9C%88%E8%AE%B0%E5%BD%95/"
           data-tag="UP"
           data-author="" >
            <span class="post-title" title="UP月记录">UP月记录</span>
            <span class="post-date" title="2023-10-27 09:48:22">2023/10/27</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2023/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="游戏设计">游戏设计</span>
            <span class="post-date" title="2023-10-24 10:38:08">2023/10/24</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2023/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="设计模式">设计模式</span>
            <span class="post-date" title="2023-10-20 18:38:08">2023/10/20</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"
           data-tag="常用命令"
           data-author="" >
            <span class="post-title" title="常用命令">常用命令</span>
            <span class="post-date" title="2023-10-16 09:48:22">2023/10/16</span>
        </a>
        
        
        <a  class="All 模块设计 "
           href="/2023/10/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1-%E6%97%B6%E9%97%B4%E8%A7%A6%E5%8F%91%E5%99%A8/"
           data-tag="时间触发器"
           data-author="" >
            <span class="post-title" title="时间触发器">时间触发器</span>
            <span class="post-date" title="2023-10-16 09:48:22">2023/10/16</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP/"
           data-tag="UP"
           data-author="" >
            <span class="post-title" title="个人UP">个人UP</span>
            <span class="post-date" title="2023-10-16 09:48:22">2023/10/16</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2023/10/Linux-ebpf/"
           data-tag="ebpf"
           data-author="" >
            <span class="post-title" title="bpf">bpf</span>
            <span class="post-date" title="2023-10-11 17:00:22">2023/10/11</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%9E%B6%E6%9E%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="架构">架构</span>
            <span class="post-date" title="2023-04-17 10:38:08">2023/04/17</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-Wireshark%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Wireshark插件开发">Wireshark插件开发</span>
            <span class="post-date" title="2023-04-11 19:00:00">2023/04/11</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E9%80%9A%E8%AF%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="通识">通识</span>
            <span class="post-date" title="2023-04-07 10:38:08">2023/04/07</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%B8%A7%E5%90%8C%E6%AD%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="帧同步">帧同步</span>
            <span class="post-date" title="2022-05-27 10:38:08">2022/05/27</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-SDL2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SDL学习">SDL学习</span>
            <span class="post-date" title="2022-05-25 10:38:08">2022/05/25</span>
        </a>
        
        
        <a  class="All UE5 "
           href="/2022/05/UE5-%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UE5学习">UE5学习</span>
            <span class="post-date" title="2022-05-12 20:31:22">2022/05/12</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2022/05/CPP-%E5%8D%8F%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="协程">协程</span>
            <span class="post-date" title="2022-05-07 10:38:08">2022/05/07</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-asio%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="asio官方文档笔记">asio官方文档笔记</span>
            <span class="post-date" title="2022-05-04 10:38:08">2022/05/04</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-6.s081/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="6.s081学习 &amp;&amp; tmux">6.s081学习 &amp;&amp; tmux</span>
            <span class="post-date" title="2022-05-04 10:38:08">2022/05/04</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2021/07/CPP-alias/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=".*_case">.*_case</span>
            <span class="post-date" title="2021-07-14 21:27:27">2021/07/14</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2021/05/CPP-ModernCpp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ModernCpp.md">ModernCpp.md</span>
            <span class="post-date" title="2021-05-25 23:27:27">2021/05/25</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2021/05/Linux-sed&awk&grep/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="sed&amp;awk&amp;grep">sed&amp;awk&amp;grep</span>
            <span class="post-date" title="2021-05-07 08:11:22">2021/05/07</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2021/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTPS/"
           data-tag="HTTPS"
           data-author="" >
            <span class="post-title" title="HTTPS的基本流程和原理">HTTPS的基本流程和原理</span>
            <span class="post-date" title="2021-03-01 16:50:22">2021/03/01</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2021/02/CPP-class%20struct%20typename/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="class struct typename">class struct typename</span>
            <span class="post-date" title="2021-02-24 10:54:08">2021/02/24</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2021/02/%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="剑指Offer">剑指Offer</span>
            <span class="post-date" title="2021-02-10 00:08:28">2021/02/10</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2021/02/CPP-stdany,%20How%20when%20and%20why/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="void*|function|any|optional|variant, How when and why">void*|function|any|optional|variant, How when and why</span>
            <span class="post-date" title="2021-02-06 18:56:27">2021/02/06</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2021/02/%E7%AE%97%E6%B3%95-leetcode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="leetcode">leetcode</span>
            <span class="post-date" title="2021-02-05 12:10:02">2021/02/05</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2021/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEURL%E5%88%B0%E6%98%BE%E7%A4%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="浏览器访问URL到显示">浏览器访问URL到显示</span>
            <span class="post-date" title="2021-02-01 16:55:22">2021/02/01</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2021/01/Linux-docker/"
           data-tag="docker"
           data-author="" >
            <span class="post-title" title="Docker使用">Docker使用</span>
            <span class="post-date" title="2021-01-31 23:34:22">2021/01/31</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2021/01/CPP-cast/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=".*_case">.*_case</span>
            <span class="post-date" title="2021-01-14 21:27:27">2021/01/14</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2021/01/Linux-%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux-调试常用命令">Linux-调试常用命令</span>
            <span class="post-date" title="2021-01-09 18:53:22">2021/01/09</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2021/01/CPP-pthread&thread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="pthread&amp;thread">pthread&amp;thread</span>
            <span class="post-date" title="2021-01-03 11:27:27">2021/01/03</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2021/01/Linux-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"
           data-tag="Shell"
           data-author="" >
            <span class="post-title" title="Shell脚本编写">Shell脚本编写</span>
            <span class="post-date" title="2021-01-02 22:00:22">2021/01/02</span>
        </a>
        
        
        <a  class="All 项目制作 "
           href="/2020/12/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-%E7%9B%B4%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="直播服务器">直播服务器</span>
            <span class="post-date" title="2020-12-02 12:50:02">2020/12/02</span>
        </a>
        
        
        <a  class="All 采坑记 "
           href="/2020/11/%E9%87%87%E5%9D%91%E8%AE%B0-delete%20this/"
           data-tag="采坑记"
           data-author="" >
            <span class="post-title" title="由muduo tie引出的 delete this">由muduo tie引出的 delete this</span>
            <span class="post-date" title="2020-11-26 17:37:08">2020/11/26</span>
        </a>
        
        
        <a  class="All 分享会 "
           href="/2020/11/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-HTTP%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="HTTP框架底层原理实现">HTTP框架底层原理实现</span>
            <span class="post-date" title="2020-11-01 22:45:39">2020/11/01</span>
        </a>
        
        
        <a  class="All 分享会 "
           href="/2020/10/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%AE%BF%E8%88%8D%E7%94%B5%E8%84%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="远程连接宿舍电脑">远程连接宿舍电脑</span>
            <span class="post-date" title="2020-10-29 16:40:39">2020/10/29</span>
        </a>
        
        
        <a  class="All 读书记录 "
           href="/2020/10/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-UNP/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UNP记录">UNP记录</span>
            <span class="post-date" title="2020-10-06 12:17:39">2020/10/06</span>
        </a>
        
        
        <a  class="All 采坑记 "
           href="/2020/08/%E9%87%87%E5%9D%91%E8%AE%B0-EPOLLET%E4%B8%A2%E5%A4%B1%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6/"
           data-tag="采坑记"
           data-author="" >
            <span class="post-title" title="EPOLLET丢失新连接事件">EPOLLET丢失新连接事件</span>
            <span class="post-date" title="2020-08-03 23:03:08">2020/08/03</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2020/07/%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%9B%9B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="算法四">算法四</span>
            <span class="post-date" title="2020-07-17 15:51:28">2020/07/17</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2020/07/Linux-VIM/"
           data-tag="spf-13"
           data-author="" >
            <span class="post-title" title="VIM使用">VIM使用</span>
            <span class="post-date" title="2020-07-05 20:31:22">2020/07/05</span>
        </a>
        
        
        <a  class="All 读书记录 "
           href="/2020/06/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-csapp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="csapp笔记">csapp笔记</span>
            <span class="post-date" title="2020-06-07 09:09:20">2020/06/07</span>
        </a>
        
        
        <a  class="All 网络编程 "
           href="/2020/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-EPOLL%E6%9C%AC%E8%B4%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="EPOLL本质">EPOLL本质</span>
            <span class="post-date" title="2020-03-25 17:35:20">2020/03/25</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2020/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E7%8A%B6%E6%80%81%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TCP状态机">TCP状态机</span>
            <span class="post-date" title="2020-03-25 12:55:20">2020/03/25</span>
        </a>
        
        
        <a  class="All 网络编程 "
           href="/2020/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Send%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Send返回值引出的(非)阻塞IO">Send返回值引出的(非)阻塞IO</span>
            <span class="post-date" title="2020-03-20 11:14:20">2020/03/20</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2020/03/Linux-Linux%E4%BD%BF%E7%94%A8/"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="Linux的使用">Linux的使用</span>
            <span class="post-date" title="2020-03-17 12:29:20">2020/03/17</span>
        </a>
        
        
        <a  class="All 读书记录 "
           href="/2020/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-UNP%E5%8D%B7%E4%BA%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UNP卷二读书记录">UNP卷二读书记录</span>
            <span class="post-date" title="2020-03-15 11:16:20">2020/03/15</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2020/03/Linux-GDB%E8%B0%83%E8%AF%95/"
           data-tag="GDB调试"
           data-author="" >
            <span class="post-title" title="GDB调试">GDB调试</span>
            <span class="post-date" title="2020-03-14 15:09:20">2020/03/14</span>
        </a>
        
        
        <a  class="All 工具使用 Git操作 "
           href="/2020/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%8F%8Acommit%E8%A7%84%E8%8C%83/"
           data-tag="Git操作"
           data-author="" >
            <span class="post-title" title="分支管理和实际应用及commit规范">分支管理和实际应用及commit规范</span>
            <span class="post-date" title="2020-03-06 19:34:25">2020/03/06</span>
        </a>
        
        
        <a  class="All 采坑记 "
           href="/2020/03/%E9%87%87%E5%9D%91%E8%AE%B0-%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E4%B9%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B/"
           data-tag="采坑记"
           data-author="" >
            <span class="post-title" title="循环判断中使用无符号类型">循环判断中使用无符号类型</span>
            <span class="post-date" title="2020-03-06 17:37:08">2020/03/06</span>
        </a>
        
        
        <a  class="All CPP 源码学习 "
           href="/2020/03/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Jsoncpp%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jsoncpp代码阅读">Jsoncpp代码阅读</span>
            <span class="post-date" title="2020-03-01 10:26:55">2020/03/01</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2020/02/CPP-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="定义与声明详解">定义与声明详解</span>
            <span class="post-date" title="2020-02-27 10:38:08">2020/02/27</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2020/02/CPP-CPP%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CPP11及以后的常用特性">CPP11及以后的常用特性</span>
            <span class="post-date" title="2020-02-19 17:41:27">2020/02/19</span>
        </a>
        
        
        <a  class="All CPP 源码学习 "
           href="/2020/02/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Libevent%E4%BB%A3%E7%A0%81%E5%88%9D%E6%9C%9F%E4%BA%86%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Libevent代码初期了解">Libevent代码初期了解</span>
            <span class="post-date" title="2020-02-19 14:56:55">2020/02/19</span>
        </a>
        
        
        <a  class="All 工具使用 Git操作 "
           href="/2020/02/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-Git-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git的基础使用">Git的基础使用</span>
            <span class="post-date" title="2020-02-07 18:24:42">2020/02/07</span>
        </a>
        
        
        <a  class="All 采坑记 "
           href="/2020/02/%E9%87%87%E5%9D%91%E8%AE%B0-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8/"
           data-tag="采坑记"
           data-author="" >
            <span class="post-title" title="头文件互相引用">头文件互相引用</span>
            <span class="post-date" title="2020-02-07 16:37:08">2020/02/07</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2020/02/CPP-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="字节对齐">字节对齐</span>
            <span class="post-date" title="2020-02-06 11:38:08">2020/02/06</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2019/11/CPP-%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="指针">指针</span>
            <span class="post-date" title="2019-11-07 22:26:22">2019/11/07</span>
        </a>
        
        
        <a  class="All 读书记录 "
           href="/2019/10/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++薄书整理">C++薄书整理</span>
            <span class="post-date" title="2019-10-20 19:13:22">2019/10/20</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-算法-剑指Offer" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">剑指Offer</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="算法">算法</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2025-02-27 06:39:40'>2021-02-10 00:08</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-03-数组中重复的数字"><span class="toc-text">剑指 Offer 03. 数组中重复的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-04-二维数组中的查找"><span class="toc-text">剑指 Offer 04. 二维数组中的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#菜鸡第一印象-暴力法"><span class="toc-text">菜鸡第一印象-暴力法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#大神点拨-站在右上角看-这个矩阵其实就像是一个BST"><span class="toc-text">大神点拨-站在右上角看,这个矩阵其实就像是一个BST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-05-替换空格"><span class="toc-text">剑指 Offer 05. 替换空格</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-额外字符串reserve版本"><span class="toc-text">Solution - 额外字符串reserve版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-精打细算-resize原地"><span class="toc-text">Solution - 精打细算 resize原地</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-06-从尾到头打印链表"><span class="toc-text">剑指 Offer 06. 从尾到头打印链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-两次遍历"><span class="toc-text">Solution - 两次遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-递归"><span class="toc-text">Solution - 递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-栈"><span class="toc-text">Solution - 栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-07-重建二叉树"><span class="toc-text">剑指 Offer 07. 重建二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-1"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-09-用两个栈实现队列"><span class="toc-text">剑指 Offer 09. 用两个栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-版本1-拷贝多"><span class="toc-text">Solution - 版本1 拷贝多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-版本2-减少了拷贝"><span class="toc-text">Solution - 版本2 减少了拷贝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-10-I-斐波那契数列"><span class="toc-text">剑指 Offer 10- I. 斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-2"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-10-II-青蛙跳台阶问题"><span class="toc-text">剑指 Offer 10- II. 青蛙跳台阶问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-3"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-11-旋转数组的最小数字"><span class="toc-text">剑指 Offer 11. 旋转数组的最小数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-暴力法"><span class="toc-text">Solution - 暴力法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-二分-一个排序好的数组-虽然打乱一次-但仍应该首先考虑二分"><span class="toc-text">Solution - 二分 (一个排序好的数组, 虽然打乱一次 但仍应该首先考虑二分)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-12-矩阵中的路径"><span class="toc-text">剑指 Offer 12. 矩阵中的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-dfs"><span class="toc-text">Solution - dfs</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-13-机器人的运动范围"><span class="toc-text">剑指 Offer 13. 机器人的运动范围</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-dfs-1"><span class="toc-text">Solution - dfs</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-14-I-剪绳子"><span class="toc-text">剑指 Offer 14- I. 剪绳子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-dp"><span class="toc-text">Solution - dp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-15-二进制中1的个数"><span class="toc-text">剑指 Offer 15. 二进制中1的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-右移运算符-循环M次-M为二进制位数和-负数会出错导致死循环"><span class="toc-text">Solution - 右移运算符 循环M次 M为二进制位数和 负数会出错导致死循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-解决负数的一种方法"><span class="toc-text">Solution - 解决负数的一种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-更加高效的-循环M次-M为二进制1的位数"><span class="toc-text">Solution - 更加高效的 循环M次 M为二进制1的位数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-16-数值的整数次方"><span class="toc-text">剑指 Offer 16. 数值的整数次方</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-快速幂"><span class="toc-text">Solution - 快速幂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-快速幂-减少空间-去除vector"><span class="toc-text">Solution - 快速幂 减少空间 去除vector</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-18-删除链表的节点"><span class="toc-text">剑指 Offer 18. 删除链表的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-爆栈Warning"><span class="toc-text">Solution 爆栈Warning</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-保存last"><span class="toc-text">Solution - 保存last</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-20-表示数值的字符串"><span class="toc-text">剑指 Offer 20. 表示数值的字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-if-else-我愿称其为最强题目-尝试了N遍才过"><span class="toc-text">Solution if else - 我愿称其为最强题目 尝试了N遍才过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-自动状态机"><span class="toc-text">Solution -  自动状态机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><span class="toc-text">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-代码不简洁版本-双指针"><span class="toc-text">Solution - 代码不简洁版本 双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-使用continue简化边界判断-双指针"><span class="toc-text">Solution - 使用continue简化边界判断 双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-快慢指针"><span class="toc-text">Solution - 快慢指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-22-链表中倒数第k个节点"><span class="toc-text">剑指 Offer 22. 链表中倒数第k个节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-依旧是解决链表问题的通用方法-快慢指针"><span class="toc-text">Solution - 依旧是解决链表问题的通用方法 快慢指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-24-反转链表"><span class="toc-text">剑指 Offer 24. 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution1-代码过长的递归"><span class="toc-text">Solution1 - 代码过长的递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution2-代码简洁的递归"><span class="toc-text">Solution2 - 代码简洁的递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-双指针-又双叒叕"><span class="toc-text">Solution - 双指针 又双叒叕</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-25-合并两个排序的链表"><span class="toc-text">剑指 Offer 25. 合并两个排序的链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-未使用虚拟头结点-代码较长且重复"><span class="toc-text">Solution - 未使用虚拟头结点 代码较长且重复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-使用虚拟头结点-代码大幅简洁-去除了重复片段"><span class="toc-text">Solution - 使用虚拟头结点 代码大幅简洁 去除了重复片段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-26-树的子结构"><span class="toc-text">剑指 Offer 26. 树的子结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-先序遍历"><span class="toc-text">Solution - 先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-简洁了一些-但我认为一个ifelse比一个函数调用更加高效"><span class="toc-text">Solution - 简洁了一些 但我认为一个ifelse比一个函数调用更加高效</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-27-二叉树的镜像"><span class="toc-text">剑指 Offer 27. 二叉树的镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-递归-1"><span class="toc-text">Solution - 递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-迭代"><span class="toc-text">Solution - 迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-28-对称的二叉树"><span class="toc-text">剑指 Offer 28. 对称的二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-递归-2"><span class="toc-text">Solution - 递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-迭代-1"><span class="toc-text">Solution - 迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-29-顺时针打印矩阵"><span class="toc-text">剑指 Offer 29. 顺时针打印矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-额外MN空间"><span class="toc-text">Solution - 额外MN空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-边界控制-不使用额外空间"><span class="toc-text">Solution - 边界控制 不使用额外空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-31-栈的压入、弹出序列"><span class="toc-text">剑指 Offer 31. 栈的压入、弹出序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution1-X一样长的代码"><span class="toc-text">Solution1 - X一样长的代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution2-大佬精简的代码"><span class="toc-text">Solution2 - 大佬精简的代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-32-I-从上到下打印二叉树"><span class="toc-text">剑指 Offer 32 - I. 从上到下打印二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-deque"><span class="toc-text">Solution - deque</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-32-II-从上到下打印二叉树-II"><span class="toc-text">剑指 Offer 32 - II. 从上到下打印二叉树 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-使用nullptr标记"><span class="toc-text">Solution - 使用nullptr标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用for循环-提前保存变量解决size会改变的问题"><span class="toc-text">- 使用for循环 提前保存变量解决size会改变的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-32-III-从上到下打印二叉树-III"><span class="toc-text">剑指 Offer 32 - III. 从上到下打印二叉树 III</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-设置标志位"><span class="toc-text">Solution - 设置标志位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-使用reverse"><span class="toc-text">Solution - 使用reverse</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-33-二叉搜索树的后序遍历序列"><span class="toc-text">剑指 Offer 33. 二叉搜索树的后序遍历序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-递归-3"><span class="toc-text">Solution - 递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-迭代-栈"><span class="toc-text">Solution - 迭代 栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-34-二叉树中和为某一值的路径"><span class="toc-text">剑指 Offer 34. 二叉树中和为某一值的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-回溯法"><span class="toc-text">Solution - 回溯法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-37-序列化二叉树"><span class="toc-text">剑指 Offer 37. 序列化二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-4"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-38-字符串的排列-30MIN"><span class="toc-text">剑指 Offer 38. 字符串的排列 - 30MIN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-5"><span class="toc-text">Solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-改进版-源字符串上swap"><span class="toc-text">Solution - 改进版 - 源字符串上swap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-39-数组中出现次数超过一半的数字-20MIN"><span class="toc-text">剑指 Offer 39. 数组中出现次数超过一半的数字 - 20MIN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-Map统计次数"><span class="toc-text">Solution - Map统计次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-sort排序-中间位置元素为结果"><span class="toc-text">Solution - sort排序 中间位置元素为结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-摩尔投票法"><span class="toc-text">Solution - 摩尔投票法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-40-最小的k个数"><span class="toc-text">剑指 Offer 40. 最小的k个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-维护最大堆-O-nlogk-O-k"><span class="toc-text">Solution - 维护最大堆 O(nlogk) O(k)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-基于快排分区思想-O-n-O-logn"><span class="toc-text">Solution - 基于快排分区思想 O(n) O(logn)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-41-数据流中的中位数-30MIN"><span class="toc-text">剑指 Offer 41. 数据流中的中位数 - 30MIN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-最大堆-最小堆-求中位数"><span class="toc-text">Solution 最大堆 + 最小堆 求中位数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-42-连续子数组的最大和-5MIN"><span class="toc-text">剑指 Offer 42. 连续子数组的最大和 - 5MIN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-6"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-45-把数组排成最小的数"><span class="toc-text">剑指 Offer 45. 把数组排成最小的数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-遇事不决dfs-超时"><span class="toc-text">Solution - 遇事不决dfs 超时..</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-特殊的排序-另类的comp函数"><span class="toc-text">Solution - 特殊的排序(另类的comp函数)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-46-把数字翻译成字符串"><span class="toc-text">剑指 Offer 46. 把数字翻译成字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-遇事不决dfs"><span class="toc-text">Solution - 遇事不决dfs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-DP"><span class="toc-text">Solution - DP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-47-礼物的最大价值"><span class="toc-text">剑指 Offer 47. 礼物的最大价值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-备忘录-接近超时"><span class="toc-text">Solution - 备忘录 接近超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-dp-table-接近100"><span class="toc-text">Solution - dp table 接近100%</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-48-最长不含重复字符的子字符串"><span class="toc-text">剑指 Offer 48. 最长不含重复字符的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-双指针-hash表"><span class="toc-text">Solution - 双指针 + hash表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-Dp-hash表"><span class="toc-text">Solution - Dp + hash表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-49-丑数"><span class="toc-text">剑指 Offer 49. 丑数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-逐个计算-超时"><span class="toc-text">Solution - 逐个计算 超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-生成丑数"><span class="toc-text">Solution - 生成丑数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-50-第一个只出现一次的字符"><span class="toc-text">剑指 Offer 50. 第一个只出现一次的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-7"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-51-数组中的逆序对"><span class="toc-text">剑指 Offer 51. 数组中的逆序对</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-归并排序-求逆序对"><span class="toc-text">Solution - 归并排序 求逆序对</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-52-两个链表的第一个公共节点"><span class="toc-text">剑指 Offer 52. 两个链表的第一个公共节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-相遇"><span class="toc-text">Solution - 相遇</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-53-II-0～n-1中缺失的数字"><span class="toc-text">剑指 Offer 53 - II. 0～n-1中缺失的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-二分法"><span class="toc-text">Solution - 二分法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-54-二叉搜索树的第k大节点"><span class="toc-text">剑指 Offer 54. 二叉搜索树的第k大节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-中序遍历得到递增序列"><span class="toc-text">Solution - 中序遍历得到递增序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-先右再左的中序遍历-得到的是递减序列"><span class="toc-text">Solution - 先右再左的中序遍历 得到的是递减序列!!</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-55-I-二叉树的深度"><span class="toc-text">剑指 Offer 55 - I. 二叉树的深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-bfs-nullptr"><span class="toc-text">Solution - bfs + nullptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs-第一个想出来的竟然不是这个…"><span class="toc-text">dfs 第一个想出来的竟然不是这个…</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-55-II-平衡二叉树"><span class="toc-text">剑指 Offer 55 - II. 平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-8"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-56-I-数组中数字出现的次数"><span class="toc-text">剑指 Offer 56 - I. 数组中数字出现的次数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-xor-以及xor分组"><span class="toc-text">Solution - xor 以及xor分组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-56-II-数组中数字出现的次数-II"><span class="toc-text">剑指 Offer 56 - II. 数组中数字出现的次数 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-二进制位出现次数-3"><span class="toc-text">Solution - 二进制位出现次数 % 3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-状态机"><span class="toc-text">Solution - 状态机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-57-和为s的两个数字"><span class="toc-text">剑指 Offer 57. 和为s的两个数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-双指针-O-n-O-1"><span class="toc-text">Solution - 双指针 O(n) O(1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-如果题目是无序数组-用Hash表-O-n-O-n"><span class="toc-text">Solution - 如果题目是无序数组 用Hash表 O(n) O(n)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-57-II-和为s的连续正数序列"><span class="toc-text">剑指 Offer 57 - II. 和为s的连续正数序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-滑动窗口"><span class="toc-text">Solution - 滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-58-I-翻转单词顺序"><span class="toc-text">剑指 Offer 58 - I. 翻转单词顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-9"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-59-I-滑动窗口的最大值"><span class="toc-text">剑指 Offer 59 - I. 滑动窗口的最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-10"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-59-II-队列的最大值"><span class="toc-text">剑指 Offer 59 - II. 队列的最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-11"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-60-n个骰子的点数"><span class="toc-text">剑指 Offer 60. n个骰子的点数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-暴力法-1"><span class="toc-text">Solution - 暴力法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-动态规划"><span class="toc-text">Solution - 动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-61-扑克牌中的顺子"><span class="toc-text">剑指 Offer 61. 扑克牌中的顺子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-12"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-63-股票的最大利润"><span class="toc-text">剑指 Offer 63. 股票的最大利润</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-动态规划-1"><span class="toc-text">Solution - 动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-64-求1-2-…-n"><span class="toc-text">剑指 Offer 64. 求1+2+…+n</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-sizeof代替乘法-短路运算控制返回"><span class="toc-text">Solution - sizeof代替乘法 + 短路运算控制返回</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-65-不用加减乘除做加法"><span class="toc-text">剑指 Offer 65. 不用加减乘除做加法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-a-b-x-进位信息-使用-amp-lt-lt-1-y-本位信息-使用-xor"><span class="toc-text">Solution a + b &#x3D; x(进位信息 使用 &amp; &lt;&lt; 1) + y(本位信息 使用 xor)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先"><span class="toc-text">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-读题-利用好每一个条件"><span class="toc-text">Solution - 读题 利用好每一个条件</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 03. 数组中重复的数字</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 </code></pre><p><strong>限制：</strong></p>
<p><code>2 &lt;= n &lt;= 100000</code></p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Language: ****</p>
<pre><code>​</code></pre><h3 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">剑指 Offer 04. 二维数组中的查找</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>示例:</strong></p>
<p>现有矩阵 matrix 如下：</p>
<pre><code>[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]</code></pre><p>给定 target = <code>5</code>，返回 <code>true</code>。</p>
<p>给定 target = <code>20</code>，返回 <code>false</code>。</p>
<p><strong>限制：</strong></p>
<p><code>0 &lt;= n &lt;= 1000</code></p>
<p><code>0 &lt;= m &lt;= 1000</code></p>
<p><strong>注意：</strong>本题与主站 240 题相同：</p>
<h4 id="菜鸡第一印象-暴力法"><a href="#菜鸡第一印象-暴力法" class="headerlink" title="菜鸡第一印象-暴力法"></a>菜鸡第一印象-暴力法</h4><p>O(nm)</p>
<pre><code class="c++">​class Solution {
public:
    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target)
    {
        if (matrix.empty() || matrix[0].empty())
        {
            return false;
        }

        for (const auto&amp; vec : matrix)
        {
            if (vec[0] &gt; target)
            {
                return false;
            }
            for (const auto&amp; num : vec)
            {
                if (num == target)
                {
                    return true;
                }
                if (num &gt; target)
                {
                    break;
                }
            }
        }
        return false;
    }
};</code></pre>
<h4 id="大神点拨-站在右上角看-这个矩阵其实就像是一个BST"><a href="#大神点拨-站在右上角看-这个矩阵其实就像是一个BST" class="headerlink" title="大神点拨-站在右上角看,这个矩阵其实就像是一个BST"></a>大神点拨-站在右上角看,这个矩阵其实就像是一个BST</h4><pre><code class="c++">class Solution {
public:
    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target)
    {
        if (matrix.empty() || matrix[0].empty())
        {
            return false;
        }

        int row_max = matrix.size();

        int column = matrix[0].size() - 1;
        int row = 0;

        while (row &lt; row_max &amp;&amp; column &gt;= 0)
        {
            if (matrix[row][column] == target)
            {
                return true;
            }
            else if (matrix[row][column] &gt; target)
            {
                column--;
            }
            else
            {
                row++;
            }
        }
        return false;
    }
};</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>初看题目, 还是没有详细审题漏掉了<code>每一列都按照从上到下递增的顺序排序</code>. 然后按照暴力法做了出来, 看了眼评论第一上面那句话让我翻回去看了下绝了.</p>
<h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">剑指 Offer 05. 替换空格</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：s = &quot;We are happy.&quot;
输出：&quot;We%20are%20happy.&quot;</code></pre><p><strong>限制：</strong></p>
<p><code>0 &lt;= s 的长度 &lt;= 10000</code></p>
<h4 id="Solution-额外字符串reserve版本"><a href="#Solution-额外字符串reserve版本" class="headerlink" title="Solution - 额外字符串reserve版本"></a>Solution - 额外字符串reserve版本</h4><pre><code class="c++">​class Solution {
public:
    string replaceSpace(string s)
    {
        string result;
        result.reserve(s.size() * 3);

        for (char c : s)
        {
            if (c == &#39; &#39;)
            {
                result.append(&quot;%20&quot;);
            }
            else
            {
                result += c;
            }
        }

        return result;
    }
};</code></pre>
<h4 id="Solution-精打细算-resize原地"><a href="#Solution-精打细算-resize原地" class="headerlink" title="Solution - 精打细算 resize原地"></a>Solution - 精打细算 resize原地</h4><pre><code class="c++">class Solution {
public:
    string replaceSpace(string s)
    {
        int num = 0;
        for (int i = 0; i &lt; s.size(); ++i)
        {
            if (s[i] == &#39; &#39;)
            {
                num++;
            }
        }

        s.resize(num * 2 + s.size());

        int sub = num * 2 + s.size();
        for (int i = s.size() - 1; i &gt;= 0; --i)
        {
            if (s[i] != &#39; &#39;)
            {
                sub--;
                s[sub] = s[i];
            }
            else
            {
                sub -= 3;
                s[sub] = &#39;%&#39;;
                s[sub + 1] = &#39;2&#39;;
                s[sub + 2] = &#39;0&#39;;
            }
        }
        return s;
    }
};</code></pre>
<h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 06. 从尾到头打印链表</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：head = [1,3,2]
输出：[2,3,1]</code></pre><p><strong>限制：</strong></p>
<p><code>0 &lt;= 链表长度 &lt;= 10000</code></p>
<h4 id="Solution-两次遍历"><a href="#Solution-两次遍历" class="headerlink" title="Solution - 两次遍历"></a>Solution - 两次遍历</h4><pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; reversePrint(ListNode* head)
    {
        if (!head)
        {
            return vector&lt;int&gt;();
        }

        int length = 0;
        ListNode* temp = head;
        while (temp)
        {
            length++;
            temp = temp-&gt;next;
        }

        vector&lt;int&gt; result;
        result.resize(length);
        for (int i = length - 1; i &gt;= 0; --i)
        {
            result[i] = head-&gt;val;
            head = head-&gt;next;
        }
        return result;
    }
};</code></pre>
<h4 id="Solution-递归"><a href="#Solution-递归" class="headerlink" title="Solution - 递归"></a>Solution - 递归</h4><pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; reversePrint(ListNode* head)
    {
        vector&lt;int&gt; result;
        reversePrint(head, &amp;result);
        return result;
    }

    void reversePrint(ListNode* head, vector&lt;int&gt;* result)
    {
        if (!head)
        {
            return;
        }

        reversePrint(head-&gt;next, result);
        result-&gt;push_back(head-&gt;val);
    } 
};</code></pre>
<h4 id="Solution-栈"><a href="#Solution-栈" class="headerlink" title="Solution - 栈"></a>Solution - 栈</h4><pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; reversePrint(ListNode* head)
    {
        stack&lt;ListNode*&gt; sta;

        ListNode* temp = head;
        while (temp)
        {
            sta.push(temp);
            temp = temp-&gt;next;
        }

        vector&lt;int&gt; result(sta.size());
        int sub = 0;
        while (!sta.empty())
        {
            result[sub++] = sta.top()-&gt;val;
            sta.pop();
        }
        return result;
    }
};</code></pre>
<h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<pre><code>前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]</code></pre><p>返回如下的二叉树：</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre><p><strong>限制：</strong></p>
<p><code>0 &lt;= 节点个数 &lt;= 5000</code></p>
<p><strong>注意</strong>：本题与主站 105 题重复：</p>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder)
    {
        return buildTree(preorder, inorder, 0, 0, inorder.size());
    }

    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pre_l, int in_l, int in_r)
    {
        if (in_l == in_r)
        {
            return nullptr;
        }

        TreeNode* node = new TreeNode(preorder[pre_l]);

        for (int i = in_l; i &lt; in_r; ++i)
        {
            if (inorder[i] == preorder[pre_l])
            {
                node-&gt;left = buildTree(preorder, inorder, pre_l + 1, in_l, i);
                node-&gt;right = buildTree(preorder, inorder, pre_l + 1 + i - in_l, i + 1, in_r);
            }
        }

        return node;
    }
};</code></pre>
<h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]
[[],[3],[],[]]
输出：[null,null,3,-1]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：
[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= values &lt;= 10000</code></li>
<li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li>
</ul>
<h4 id="Solution-版本1-拷贝多"><a href="#Solution-版本1-拷贝多" class="headerlink" title="Solution - 版本1 拷贝多"></a>Solution - 版本1 拷贝多</h4><pre><code class="c++">class CQueue {
public:
    CQueue() {

    }

    void appendTail(int value)
    {
        while (!core_stack.empty())
        {
            int temp = core_stack.top();
            core_stack.pop();
            temp_stack.push(temp);
        }

        temp_stack.push(value);
    }

    int deleteHead()
    {
        while (!temp_stack.empty())
        {
            int temp = temp_stack.top();
            temp_stack.pop();
            core_stack.push(temp);
        }

        int result = -1;
        if (!core_stack.empty())
        {
            result = core_stack.top();
            core_stack.pop();
        }
        return result;
    }

    stack&lt;int&gt; temp_stack;
    stack&lt;int&gt; core_stack;
};</code></pre>
<h4 id="Solution-版本2-减少了拷贝"><a href="#Solution-版本2-减少了拷贝" class="headerlink" title="Solution - 版本2 减少了拷贝"></a>Solution - 版本2 减少了拷贝</h4><pre><code class="c++">​class CQueue {
public:
    CQueue() {

    }

    void appendTail(int value)
    {
        temp_stack.push(value);
    }

    int deleteHead()
    {
        int result = -1;

        if (!core_stack.empty())
        {
            result = core_stack.top();
            core_stack.pop();
        }
        else
        {
            while (!temp_stack.empty())
            {
                int temp = temp_stack.top();
                temp_stack.pop();
                core_stack.push(temp);
            }

            if (!core_stack.empty())
            {
                result = core_stack.top();
                core_stack.pop();
            }
        }

        return result;
    }

    stack&lt;int&gt; temp_stack;
    stack&lt;int&gt; core_stack;
};</code></pre>
<h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 10- I. 斐波那契数列</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>
<pre><code>F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</code></pre><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 2
输出：1</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：n = 5
输出：5</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">class Solution {
public:
    int fib(int n)
    {
        int arr[max(n + 1, 2)];
        arr[0] = 0;
        arr[1] = 1;

        for (int i = 2; i &lt;= n; ++i)
        {
            arr[i] = (arr[i - 1] + arr[i - 2]) % 1000000007;
        }

        return arr[n];
    }
};
</code></pre>
<h3 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">剑指 Offer 10- II. 青蛙跳台阶问题</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：n = 2
输出：2</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：n = 7
输出：21</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：n = 0
输出：1</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
<p>注意：本题与主站 70 题相同：</p>
<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:
    int numWays(int n)
    {
        int dp[max(n + 1, 2)];
        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i &lt;= n; ++i)
        {
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
        }

        return dp[n];
    }
};</code></pre>
<h3 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 11. 旋转数组的最小数字</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。  </p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：[3,4,5,1,2]
输出：1</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：[2,2,2,0,1]
输出：0</code></pre><p>注意：本题与主站 154 题相同：</p>
<h4 id="Solution-暴力法"><a href="#Solution-暴力法" class="headerlink" title="Solution - 暴力法"></a>Solution - 暴力法</h4><pre><code class="c++">class Solution {
public:
    int minArray(vector&lt;int&gt;&amp; numbers)
    {
        int result = numbers[0];
        for (int i = 0; i &lt; numbers.size() - 1; ++i)
        {
            if (numbers[i] &gt; numbers[i + 1])
            {
                result = numbers[i + 1];
                break;
            }
        }

        return result;
    }
};​</code></pre>
<h4 id="Solution-二分-一个排序好的数组-虽然打乱一次-但仍应该首先考虑二分"><a href="#Solution-二分-一个排序好的数组-虽然打乱一次-但仍应该首先考虑二分" class="headerlink" title="Solution - 二分 (一个排序好的数组, 虽然打乱一次 但仍应该首先考虑二分)"></a>Solution - 二分 (一个排序好的数组, 虽然打乱一次 但仍应该首先考虑二分)</h4><pre><code class="c++">class Solution {
public:
    int minArray(vector&lt;int&gt;&amp; numbers)
    {
        int low = 0;
        int high = numbers.size() - 1;

        while (low &lt; high)
        {
            int mid = (low + high) / 2;

            if (numbers[mid] &gt; numbers[high])
            {
                low = mid + 1;
            }
            else if (numbers[mid] &lt; numbers[high])
            {
                high = mid;
            }
            else
            {
                high--;
            }
        }
        return numbers[low];
    }
};</code></pre>
<h3 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 12. 矩阵中的路径</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”<strong>b</strong>“,”c”,”e”],<br>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],<br>[“a”,”d”,”<strong>e</strong>“,”e”]]</p>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;
输出：true</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;
输出：false</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= board.length &lt;= 200</code></li>
<li><code>1 &lt;= board[i].length &lt;= 200</code></li>
</ul>
<p>注意：本题与主站 79 题相同：</p>
<h4 id="Solution-dfs"><a href="#Solution-dfs" class="headerlink" title="Solution - dfs"></a>Solution - dfs</h4><p>Language: ****</p>
<pre><code class="c++">​class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word)
    {
        for (int i = 0; i &lt; board.size(); ++i)
        {
            for (int j = 0; j &lt; board[0].size(); ++j)
            {
                if (word[0] == board[i][j])
                {
                    if (exist(board, word, i, j, 0))
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, const string&amp; word, int x, int y, int sub)
    {
        if (sub &gt;= word.size())
        {
            return true;
        }

        if (x &lt; 0 || y &lt; 0 || x &gt;= board.size() || y &gt;= board[0].size())
        {
            return false;
        }

        if (board[x][y] == &#39; &#39;)
        {
            return false;
        }

        if (board[x][y] != word[sub])
        {
            return false;
        }

        char back = board[x][y];
        board[x][y] = &#39; &#39;;

        if (exist(board, word, x + 1, y, sub + 1) || 
                exist(board, word, x, y + 1, sub + 1) ||
                exist(board, word, x - 1, y, sub + 1) ||
                exist(board, word, x, y - 1, sub + 1))
        {
            return true;
        }

        board[x][y] = back;

        return false;
    }
};</code></pre>
<h3 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">剑指 Offer 13. 机器人的运动范围</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：m = 2, n = 3, k = 1
输出：3</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：m = 3, n = 1, k = 0
输出：1</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n,m &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 20</code></li>
</ul>
<h4 id="Solution-dfs-1"><a href="#Solution-dfs-1" class="headerlink" title="Solution - dfs"></a>Solution - dfs</h4><pre><code class="c++">​class Solution {
public:
    bool Check(int x, int y, int k)
    {
        int temp = 0;

        while (x != 0)
        {
            temp += x % 10;
            x /= 10;
        }
        while (y != 0)
        {
            temp += y % 10;
            y /= 10;
        }
        return temp &lt;= k;
    }

    int movingCount(int m, int n, int k)
    {
        vector&lt;vector&lt;int&gt;&gt; vec(m, vector&lt;int&gt;(n, 0));
        return movingCount(vec, 0, 0, k);
    }

    constexpr static int SS = 4;
    int xx[SS] = {1, -1, 0, 0};
    int yy[SS] = {0, 0, 1, -1};

    int movingCount(vector&lt;vector&lt;int&gt;&gt;&amp; vec, int x, int y, int k)
    {
        if (!Check(x, y, k))
        {
            return 0;
        }

        if (x &lt; 0 || y &lt; 0 || x &gt;= vec.size() || y &gt;= vec[0].size())
        {
            return 0;
        }

        if (vec[x][y] == 1)
        {
            return 0;
        }
        vec[x][y] = 1;
        int result = 1;

        for (int i = 0; i &lt; SS; ++i)
        {
            result += movingCount(vec, x + xx[i], y + yy[i], k);
        }

        return result;
    }
};</code></pre>
<h3 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 14- I. 剪绳子</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 58</code></li>
</ul>
<p>注意：本题与主站 343 题相同：</p>
<h4 id="Solution-dp"><a href="#Solution-dp" class="headerlink" title="Solution - dp"></a>Solution - dp</h4><pre><code class="c++">​class Solution
{
public:
    int cuttingRope(int n)
    {
        int* dp = new int[n + 1]{};
        // 初始状态
        dp[2] = 1;
        // 状态转移方程
        for(int i = 3; i &lt; n + 1; i++)
        {
            for(int j = 2; j &lt; i; j++)
            {
                dp[i] = max(dp[i], max(j * dp[i-j], j * (i - j)));
            }
        }
        // 返回值
        return dp[n];
    }
};</code></pre>
<h3 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 15. 二进制中1的个数</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</code></pre><p><strong>提示：</strong></p>
<ul>
<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li>
</ul>
<p>注意：本题与主站 191 题相同：</p>
<h4 id="Solution-右移运算符-循环M次-M为二进制位数和-负数会出错导致死循环"><a href="#Solution-右移运算符-循环M次-M为二进制位数和-负数会出错导致死循环" class="headerlink" title="Solution - 右移运算符 循环M次 M为二进制位数和 负数会出错导致死循环"></a>Solution - 右移运算符 循环M次 M为二进制位数和 负数会出错导致死循环</h4><pre><code class="c++">​class Solution {
public:
    int hammingWeight(uint32_t n)
    {
        int result = 0;

        while (n != 0)
        {
            result += n &amp; 1;
            n = n &gt;&gt; 1;
        }
        return result;
    }
};</code></pre>
<h4 id="Solution-解决负数的一种方法"><a href="#Solution-解决负数的一种方法" class="headerlink" title="Solution - 解决负数的一种方法"></a>Solution - 解决负数的一种方法</h4><pre><code class="c++">class Solution
{
public:
    int hammingWeight(uint32_t n)
    {

    }
}</code></pre>
<h4 id="Solution-更加高效的-循环M次-M为二进制1的位数"><a href="#Solution-更加高效的-循环M次-M为二进制1的位数" class="headerlink" title="Solution - 更加高效的 循环M次 M为二进制1的位数"></a>Solution - 更加高效的 循环M次 M为二进制1的位数</h4><pre><code class="c++">class Solution {
public:
    int hammingWeight(uint32_t n)
    {
        int result = 0;

        while (n != 0)
        {
            result++;
            n &amp;= n - 1;
        }
        return result;
    }
};</code></pre>
<p>把一个整数减去1之后再和原来的整数作<code>&amp;</code>运算, 得到的结果相当于将二进制表示中的最右边一个1变成0</p>
<h3 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 2.00000, 10
输出: 1024.00000</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: 2.10000, 3
输出: 9.26100</code></pre><p><strong>示例 3:</strong></p>
<pre><code>输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25</code></pre><p><strong>说明:</strong></p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> 是 32 位有符号整数，其数值范围是 [−2<sup>31</sup>, 2<sup>31 </sup>− 1] 。</li>
</ul>
<p>注意：本题与主站 50 题相同：</p>
<h4 id="Solution-快速幂"><a href="#Solution-快速幂" class="headerlink" title="Solution - 快速幂"></a>Solution - 快速幂</h4><pre><code class="c++">​class Solution {
public:
    double myPow(double x, int n)
    {
        if (n == 0)
        {
            return 1;
        }

        bool flag = true;
        if (n &gt; 0)
        {
            flag = false;
            n = -n;
        }

        double result = x;
        vector&lt;double&gt; ex;
        while (n &lt; -1)
        {
            if (n % 2 == -1)
            {
                ex.push_back(result);
            }
            result *= result;
            n = n / 2; 
        }

        while (!ex.empty())
        {
            result *= ex.back();
            ex.pop_back();
        }

        if (flag)
        {
            result = 1 / result;
        }

        return result;
    }
};</code></pre>
<h4 id="Solution-快速幂-减少空间-去除vector"><a href="#Solution-快速幂-减少空间-去除vector" class="headerlink" title="Solution - 快速幂 减少空间 去除vector"></a>Solution - 快速幂 减少空间 去除vector</h4><pre><code class="c++">class Solution {
public:
    double myPow(double x, int n)
    {
        if (n == 0)
        {
            return 1;
        }

        bool flag = true;
        if (n &gt; 0)
        {
            flag = false;
            n = -n;
        }

        double result = x;
        double ex = 1.0;
        while (n &lt; -1)
        {
            if (n % 2 == -1)
            {
                ex *= result;
            }
            result *= result;
            n = n / 2; 
        }

        result *= ex;

        if (flag)
        {
            result = 1 / result;
        }

        return result;
    }
};</code></pre>
<h3 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 18. 删除链表的节点</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p><strong>注意：</strong>此题对比原题有改动</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</code></pre><p><strong>说明：</strong></p>
<ul>
<li>题目保证链表中节点的值互不相同</li>
<li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>
</ul>
<h4 id="Solution-爆栈Warning"><a href="#Solution-爆栈Warning" class="headerlink" title="Solution 爆栈Warning"></a>Solution 爆栈Warning</h4><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val)
    {
        if (!head)
        {
            return nullptr;
        }

        if (head-&gt;val == val)
        {
            return head-&gt;next;
        }

        head-&gt;next = deleteNode(head-&gt;next, val);
        return head;
    }
};</code></pre>
<h4 id="Solution-保存last"><a href="#Solution-保存last" class="headerlink" title="Solution - 保存last"></a>Solution - 保存last</h4><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val)
    {
        if (!head)
        {
            return nullptr;
        }

        if (head-&gt;val == val)
        {
            return head-&gt;next;
        }

        ListNode* last = head;
        ListNode* temp = head-&gt;next;

        while (temp)
        {
            if (temp-&gt;val == val)
            {
                last-&gt;next = temp-&gt;next;
            }
            last = temp;
            temp = temp-&gt;next;
        }

        return head;
    }
};</code></pre>
<h3 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 20. 表示数值的字符串</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<h4 id="Solution-if-else-我愿称其为最强题目-尝试了N遍才过"><a href="#Solution-if-else-我愿称其为最强题目-尝试了N遍才过" class="headerlink" title="Solution if else - 我愿称其为最强题目 尝试了N遍才过"></a>Solution if else - 我愿称其为最强题目 尝试了N遍才过</h4><pre><code class="c++">​class Solution {
public:
    bool isNumber(string s)
    {
        int begin = 0;
        int end = s.size();
        bool num = false;

        // 去除开头结尾空格
        while (begin &lt; end &amp;&amp; s[begin] == &#39; &#39;)
        {
            begin++;
        }
        while (end &gt; begin &amp;&amp; s[end - 1] == &#39; &#39;)
        {
            end--;
        }
        int sub = begin;

        // + - 打头直接去掉
        if (s[sub] == &#39;+&#39; || s[sub] == &#39;-&#39;)
        {
            sub++;
        }

        // 判断+-之后是否有小数点
        bool has_point = false;
        if (s[sub] == &#39;.&#39;)
        {
            has_point = true;
            sub++;
        }

        // 正常数字判断
        while (sub &lt; end)
        {
            if (s[sub] == &#39;.&#39;)
            {
                if (has_point)
                {
                    return false; // 小数点只能出现一次
                }
                has_point = true;
            }
            else if (s[sub] &gt;= &#39;0&#39; &amp;&amp; s[sub] &lt;= &#39;9&#39;)
            {
                num = true; // 是一个数字
            }
            else
            {
                break;
            }
            sub++;
        }

        // 科学计数法判断 E或e 不作为第一个或者最后一个字符
        if (sub &gt; begin &amp;&amp; sub &lt; end - 1 &amp;&amp; (s[sub] == &#39;e&#39; || s[sub] == &#39;E&#39;))
        {
            sub++;

            // 去掉E e之后紧接着的 +- 必须 +-只有还有数字
            if ((s[sub] == &#39;+&#39; || s[sub] == &#39;-&#39;) &amp;&amp; sub &lt; end - 1)
            {
                sub++;
            }

            while (sub &lt; end &amp;&amp; s[sub] &gt;= &#39;0&#39; &amp;&amp; s[sub] &lt;= &#39;9&#39;)
            {
                sub++;
            }
        }
        return num &amp;&amp; sub == end; // 含数字且已经遍历完毕
    }
};</code></pre>
<h4 id="Solution-自动状态机"><a href="#Solution-自动状态机" class="headerlink" title="Solution -  自动状态机"></a>Solution -  自动状态机</h4><pre><code class="c++"></code></pre>
<h3 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p><strong>示例：</strong></p>
<pre><code>输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。</code></pre><p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10000</code></li>
</ol>
<h4 id="Solution-代码不简洁版本-双指针"><a href="#Solution-代码不简洁版本-双指针" class="headerlink" title="Solution - 代码不简洁版本 双指针"></a>Solution - 代码不简洁版本 双指针</h4><pre><code class="c++">​class Solution {
public:
    vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums)
    {
        if (nums.empty())
        {
            return nums;
        }

        int begin = 0;
        int end = nums.size() - 1;

        while (begin &lt; end)
        {
            while (nums[end] % 2 == 0)
            {
                end--;
                if (begin &gt; end)
                {
                    return nums;
                }
            }

            if (nums[begin] % 2 == 0)
            {
                swap(nums[begin], nums[end--]);
            }
            else
            {
                begin++;
            }
        }
        return nums;
    }
};</code></pre>
<h4 id="Solution-使用continue简化边界判断-双指针"><a href="#Solution-使用continue简化边界判断-双指针" class="headerlink" title="Solution - 使用continue简化边界判断 双指针"></a>Solution - 使用continue简化边界判断 双指针</h4><pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums)
    {
        int left = 0; 
        int right = nums.size() - 1;

        while (left &lt; right)
        {
            if ((nums[left] &amp; 1) != 0)
            {
                left ++;
                continue;
            }
            if ((nums[right] &amp; 1) != 1)
            {
                right --;
                continue;
            }
            swap(nums[left++], nums[right--]);
        }
        return nums;
    }
};</code></pre>
<h4 id="Solution-快慢指针"><a href="#Solution-快慢指针" class="headerlink" title="Solution - 快慢指针"></a>Solution - 快慢指针</h4><pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums)
    {
        int slow = 0;
        int fast = 0;

        while (fast &lt; nums.size())
        {
            if ((nums[fast] &amp; 1) == 0)
            {
                fast++;
                continue;
            }
            swap(nums[slow++], nums[fast++]);
        }
        return nums;
    }
};</code></pre>
<p>慢指针负责指向偶数, 当快指针寻找到奇数时 进行替换 然后两者都向前移动</p>
<p>不过这个代码存在原地tp的问题 极端情况下如果全是奇数则会替换size次</p>
<h3 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 22. 链表中倒数第k个节点</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p>
<p><strong>示例：</strong></p>
<pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.

返回链表 4-&gt;5.</code></pre><h4 id="Solution-依旧是解决链表问题的通用方法-快慢指针"><a href="#Solution-依旧是解决链表问题的通用方法-快慢指针" class="headerlink" title="Solution - 依旧是解决链表问题的通用方法 快慢指针"></a>Solution - 依旧是解决链表问题的通用方法 快慢指针</h4><pre><code class="c++">​class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k)
    {
        if (!head)
        {
            return nullptr;
        }

        ListNode* fast = head;
        for (int i = 0; i &lt; k; ++i)
        {
            fast = fast-&gt;next;
        }

        ListNode* slow = head;
        while (fast)
        {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }
        return slow;
    }
};</code></pre>
<p>判断链表环依然采用快慢指针, 快指针一次走两步 注意判断两次fast不为nullptr 当fast==low的时候说明有环</p>
<p>判断环长度, 第一次相遇后 到 第二次相遇 慢指针走的次数即为长度. 快指针在相遇后正好比慢指针多走一圈</p>
<p>1-&gt;2-&gt;3-&gt;4</p>
<p>1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>取中间节点 快指针走两步 慢指针走一步 当快指针无法走两步的时候 慢指针所指为中间</p>
<h3 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 24. 反转链表</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p><strong>限制：</strong></p>
<p><code>0 &lt;= 节点个数 &lt;= 5000</code></p>
<p><strong>注意</strong>：本题与主站 206 题相同：</p>
<h4 id="Solution1-代码过长的递归"><a href="#Solution1-代码过长的递归" class="headerlink" title="Solution1 - 代码过长的递归"></a>Solution1 - 代码过长的递归</h4><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head)
    {
        if (!head)
        {
            return nullptr;
        }

        ListNode* new_head = nullptr;
        ListNode* front = reverse(head, &amp;new_head);
        front-&gt;next = nullptr;

        return new_head;
    }

    ListNode* reverse(ListNode* node, ListNode** head)
    {
        if (!node)
        {
            return nullptr;
        }

        ListNode* front = reverse(node-&gt;next, head);
        if (front)
        {
            front-&gt;next = node;
        }
        else
        {
            *head = node;
        }
        return node;
    }
};</code></pre>
<h4 id="Solution2-代码简洁的递归"><a href="#Solution2-代码简洁的递归" class="headerlink" title="Solution2 - 代码简洁的递归"></a>Solution2 - 代码简洁的递归</h4><pre><code class="c++">class Solution {
public:
    ListNode* reverseList(ListNode* head)
    {
        if (!head || !head-&gt;next)
        {
            return head;
        }

        ListNode* ret = reverseList(head-&gt;next);

        head-&gt;next-&gt;next = head;
        head-&gt;next = nullptr;
        return ret;
    }
};</code></pre>
<p>首先S2开头的<code>!head-&gt;next</code>的判断减少了一次了递归 同时也简化了S1中的<code>front</code>的判断 不会有空指针.</p>
<p>然后S1使用的返回值 返回的下一个节点. 然而实际上下一个节点已经可以通过本节点的<code>next</code>访问 通过<code>next-&gt;next</code>来倒转指向</p>
<p>这样将返回值省了出来 返回原链表的尾结点 作为新的头结点</p>
<h4 id="Solution-双指针-又双叒叕"><a href="#Solution-双指针-又双叒叕" class="headerlink" title="Solution - 双指针 又双叒叕"></a>Solution - 双指针 又双叒叕</h4><pre><code class="c++">class Solution {
public:
    ListNode* reverseList(ListNode* head)
    {
        if (!head)
        {
            return nullptr;
        }

        ListNode* node2 = head-&gt;next;
        ListNode* node1 = head;

        node1-&gt;next = nullptr;

        ListNode* back = nullptr;
        while (node2)
        {
            back = node2-&gt;next;

            node2-&gt;next = node1;
            node1 = node2;

            node2 = back;
        }
        return node1;
    }
};</code></pre>
<h3 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 25. 合并两个排序的链表</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p><strong>示例1：</strong></p>
<pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><p><strong>限制：</strong></p>
<p><code>0 &lt;= 链表长度 &lt;= 1000</code></p>
<p>注意：本题与主站 21 题相同：</p>
<h4 id="Solution-未使用虚拟头结点-代码较长且重复"><a href="#Solution-未使用虚拟头结点-代码较长且重复" class="headerlink" title="Solution - 未使用虚拟头结点 代码较长且重复"></a>Solution - 未使用虚拟头结点 代码较长且重复</h4><pre><code class="c++">class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)
    {
        if (!l1)
        {
            return l2;
        }

        if (!l2)
        {
            return l1;
        }

        ListNode* ret = nullptr;
        if (l1-&gt;val &lt; l2-&gt;val)
        {
            ret = l1;
            l1 = l1-&gt;next;
        }
        else
        {
            ret = l2;
            l2 = l2-&gt;next;
        }

        ListNode* node = ret;
        while (l1 || l2)
        {
            if (!l1)
            {
                node-&gt;next = l2;
                break;
            }
            if (!l2)
            {
                node-&gt;next = l1;
                break;
            }

            if (l1-&gt;val &lt; l2-&gt;val)
            {
                node-&gt;next = l1;
                l1 = l1-&gt;next;
            }
            else
            {
                node-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            node = node-&gt;next;
        }
        return ret;
    }
};</code></pre>
<h4 id="Solution-使用虚拟头结点-代码大幅简洁-去除了重复片段"><a href="#Solution-使用虚拟头结点-代码大幅简洁-去除了重复片段" class="headerlink" title="Solution - 使用虚拟头结点 代码大幅简洁 去除了重复片段"></a>Solution - 使用虚拟头结点 代码大幅简洁 去除了重复片段</h4><pre><code class="c++">class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)
    {
        ListNode* dumy = new ListNode(0);

        ListNode* node = dumy;
        while (l1 || l2)
        {
            if (!l1)
            {
                node-&gt;next = l2;
                break;
            }
            if (!l2)
            {
                node-&gt;next = l1;
                break;
            }

            if (l1-&gt;val &lt; l2-&gt;val)
            {
                node-&gt;next = l1;
                l1 = l1-&gt;next;
            }
            else
            {
                node-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            node = node-&gt;next;
        }
        return dumy-&gt;next;
    }
};</code></pre>
<p>使用了虚拟头结点 直接简化了重复片段 tql</p>
<h3 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">剑指 Offer 26. 树的子结构</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<p><code>3  
    / \  
   4   5  
  / \  
 1   2</code><br>给定的树 B：</p>
<p><code>4   
  /  
 1</code><br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：A = [1,2,3], B = [3,1]
输出：false</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：A = [3,4,5,1,2], B = [4,1]
输出：true</code></pre><p><strong>限制：</strong></p>
<p><code>0 &lt;= 节点个数 &lt;= 10000</code></p>
<h4 id="Solution-先序遍历"><a href="#Solution-先序遍历" class="headerlink" title="Solution - 先序遍历"></a>Solution - 先序遍历</h4><pre><code class="c++">​class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B)
    {
        if (!A || !B)
        {
            return false;
        }

        if (A-&gt;val == B-&gt;val)
        {
            if (cmpTree(A, B))
            {
                return true;
            }
        }

        return isSubStructure(A-&gt;left, B) ||
        isSubStructure(A-&gt;right, B);
    }

    bool cmpTree(TreeNode* A, TreeNode* B)
    {
        if (!B)
        {
            return true;
        }
        if (!A)
        {
            return false;
        }

        if (A-&gt;val == B-&gt;val)
        {
            return cmpTree(A-&gt;left, B-&gt;left) &amp;&amp; cmpTree(A-&gt;right, B-&gt;right);
        }
        return false;
    }
};</code></pre>
<h4 id="Solution-简洁了一些-但我认为一个ifelse比一个函数调用更加高效"><a href="#Solution-简洁了一些-但我认为一个ifelse比一个函数调用更加高效" class="headerlink" title="Solution - 简洁了一些 但我认为一个ifelse比一个函数调用更加高效"></a>Solution - 简洁了一些 但我认为一个ifelse比一个函数调用更加高效</h4><pre><code class="c++">class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B)
    {
        if (!A || !B)
        {
            return false;
        }

        return cmpTree(A, B) || isSubStructure(A-&gt;left, B) ||
        isSubStructure(A-&gt;right, B);
    }

    bool cmpTree(TreeNode* A, TreeNode* B)
    {
        if (!B)
        {
            return true;
        }
        if (!A)
        {
            return false;
        }

        return (A-&gt;val == B-&gt;val) &amp;&amp; cmpTree(A-&gt;left, B-&gt;left) &amp;&amp; cmpTree(A-&gt;right, B-&gt;right);
    }
};</code></pre>
<h3 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">剑指 Offer 27. 二叉树的镜像</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<p><code>4  
   /   \  
  2     7  
 / \   / \  
1   3 6   9</code><br>镜像输出：</p>
<p><code>4  
   /   \  
  7     2  
 / \   / \  
9   6 3   1</code></p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]</code></pre><p><strong>限制：</strong></p>
<p><code>0 &lt;= 节点个数 &lt;= 1000</code></p>
<p>注意：本题与主站 226 题相同：</p>
<h4 id="Solution-递归-1"><a href="#Solution-递归-1" class="headerlink" title="Solution - 递归"></a>Solution - 递归</h4><pre><code class="c++">​class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root)
    {
        if (!root)
        {
            return nullptr;
        }

        swap(root-&gt;left, root-&gt;right);

        mirrorTree(root-&gt;left);
        mirrorTree(root-&gt;right);

        return root;
    }
};</code></pre>
<h4 id="Solution-迭代"><a href="#Solution-迭代" class="headerlink" title="Solution - 迭代"></a>Solution - 迭代</h4><pre><code class="c++">class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root)
    {
        if (!root)
        {
            return nullptr;
        }

        deque&lt;TreeNode*&gt; nodes;
        nodes.push_back(root);

        while (!nodes.empty())
        {
            TreeNode* node = nodes.front();
            nodes.pop_front();
            swap(node-&gt;left, node-&gt;right);

            if (node-&gt;left)
            {
                nodes.push_back(node-&gt;left);
            }
            if (node-&gt;right)
            {
                nodes.push_back(node-&gt;right);
            }
        }

        return root;
    }
};</code></pre>
<h3 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 28. 对称的二叉树</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<p><code>1  
   / \  
  2   2  
 / \ / \  
3  4 4  3</code><br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<p><code>1  
   / \  
  2   2  
   \   \  
   3    3</code></p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：root = [1,2,2,3,4,4,3]
输出：true</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：root = [1,2,2,null,3,null,3]
输出：false</code></pre><p><strong>限制：</strong></p>
<p><code>0 &lt;= 节点个数 &lt;= 1000</code></p>
<p>注意：本题与主站 101 题相同：</p>
<h4 id="Solution-递归-2"><a href="#Solution-递归-2" class="headerlink" title="Solution - 递归"></a>Solution - 递归</h4><pre><code class="c++">​class Solution {
public:
    bool isSymmetric(TreeNode* root)
    {
        if (!root)
        {
            return true;
        }

        return solve(root-&gt;left, root-&gt;right);
    }

    bool solve(TreeNode* lhs, TreeNode* rhs)
    {
        if (!lhs &amp;&amp; !rhs)
        {
            return true;
        }
        if (!lhs || !rhs)
        {
            return false;
        }

        if (lhs-&gt;val == rhs-&gt;val)
        {
            return solve(lhs-&gt;left, rhs-&gt;right) &amp;&amp; solve(lhs-&gt;right, rhs-&gt;left);
        }
        return false;
    }
};</code></pre>
<h4 id="Solution-迭代-1"><a href="#Solution-迭代-1" class="headerlink" title="Solution - 迭代"></a>Solution - 迭代</h4><pre><code class="c++">class Solution {
public:
    bool isSymmetric(TreeNode* root)
    {
        if (!root)
        {
            return true;
        }

        list&lt;TreeNode*&gt; nodes;
        nodes.push_back(root-&gt;left);
        nodes.push_back(root-&gt;right);

        while (!nodes.empty())
        {
            TreeNode* node1 = nodes.front();
            nodes.pop_front();
            TreeNode* node2 = nodes.front();
            nodes.pop_front();

            if (!node1 &amp;&amp; !node2)
            {
                continue;
            }
            else if (node1 &amp;&amp; node2)
            {
                if (node1-&gt;val != node2-&gt;val)
                {
                    return false;
                }
                nodes.push_back(node1-&gt;left);
                nodes.push_back(node2-&gt;right);
                nodes.push_back(node1-&gt;right);
                nodes.push_back(node2-&gt;left);
            }
            else
            {
                return false;
            }
        }
        return true;
    }
};</code></pre>
<h3 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">剑指 Offer 29. 顺时针打印矩阵</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]</code></pre><p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code></li>
</ul>
<p>注意：本题与主站 54 题相同：</p>
<h4 id="Solution-额外MN空间"><a href="#Solution-额外MN空间" class="headerlink" title="Solution - 额外MN空间"></a>Solution - 额外MN空间</h4><pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)
    {
        if (matrix.empty() || matrix[0].empty())
        {
            return vector&lt;int&gt;();
        }

        const int MX = matrix.size();
        const int MY = matrix[0].size();
        vector&lt;vector&lt;int&gt;&gt; flags(MX, vector&lt;int&gt;(MY, 0));

        int x = 0, y = 0;

        vector&lt;int&gt; result;
        result.reserve(MX * MY);

        int xx[] = {0, 1, 0, -1};
        int yy[] = {1, 0, -1, 0};

        int i = 0;

        while (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; MX &amp;&amp; y &lt; MY &amp;&amp; flags[x][y] != 1)
        {
            for (;x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; MX &amp;&amp; y &lt; MY &amp;&amp; flags[x][y] != 1; 
                x += xx[i], y += yy[i])
            {
                flags[x][y] = 1;
                result.push_back(matrix[x][y]);
            }

            x -= xx[i];
            y -= yy[i];

            i = (i + 1) % 4;

            x += xx[i];
            y += yy[i];
        }
        return result;
    }
};</code></pre>
<h4 id="Solution-边界控制-不使用额外空间"><a href="#Solution-边界控制-不使用额外空间" class="headerlink" title="Solution - 边界控制 不使用额外空间"></a>Solution - 边界控制 不使用额外空间</h4><pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)
    {
        if (matrix.empty() || matrix[0].empty())
        {
            return vector&lt;int&gt;();
        }

        const int MX = matrix.size();
        const int MY = matrix[0].size();

        vector&lt;int&gt; result;
        result.reserve(MX * MY);

        int xx[] = {0, 1, 0, -1};
        int yy[] = {1, 0, -1, 0};

        // int nn[] = {1, 0, 0, 0};
        // int ee[] = {0, -1, 0, 0};
        // int ss[] = {0, 0, -1, 0};
        // int ww[] = {0, 0, 0, 1};

        int i = 0;
        int x = 0, y = 0;

        int e = MY, s = MX, w = 0, n = 0;

        while (x &gt;= n &amp;&amp; y &gt;= w &amp;&amp; x &lt; s &amp;&amp; y &lt; e)
        {
            for (;x &gt;= n &amp;&amp; y &gt;= w &amp;&amp; x &lt; s &amp;&amp; y &lt; e; 
                x += xx[i], y += yy[i])
            {
                result.push_back(matrix[x][y]);
            }

            x -= xx[i];
            y -= yy[i];


            // n += nn[i];
            // e += ee[i];
            // s += ss[i]; 更短的写法
            // w += ww[i];

            if (i == 0)
            {
                n++;
            }
            else if (i == 1)
            {
                e--;
            }
            else if (i == 2)
            {
                s--;
            }
            else
            {
                w++;
            }

            i = (i + 1) % 4;
            x += xx[i];
            y += yy[i];
        }
        return result;
    }
};</code></pre>
<h3 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 31. 栈的压入、弹出序列</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -&gt; 4,
push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。</code></pre><p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>
<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>
<li><code>pushed</code> 是 <code>popped</code> 的排列。</li>
</ol>
<p>注意：本题与主站 946 题相同：</p>
<h4 id="Solution1-X一样长的代码"><a href="#Solution1-X一样长的代码" class="headerlink" title="Solution1 - X一样长的代码"></a>Solution1 - X一样长的代码</h4><pre><code class="c++">class Solution {
public:
    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped)
    {
        stack&lt;int&gt; lstack;

        int i = 0, j = 0;

        while (i &lt; pushed.size() &amp;&amp; j &lt; popped.size())
        {
            while (!lstack.empty())
            {
                if (lstack.top() == popped[j])
                {
                    lstack.pop();
                    j++;
                }
                else
                {
                    break;
                }
            }
            if (pushed[i] == popped[j])
            {
                i++;
                j++;
            }
            else
            {
                lstack.push(pushed[i]);
                i++;
            }
        }

        while (!lstack.empty())
        {
            if (lstack.top() == popped[j])
            {
                lstack.pop();
                j++;
            }
            else
            {
                return false;
            }
        }
        return true;
    }
};</code></pre>
<h4 id="Solution2-大佬精简的代码"><a href="#Solution2-大佬精简的代码" class="headerlink" title="Solution2 - 大佬精简的代码"></a>Solution2 - 大佬精简的代码</h4><pre><code class="c++">class Solution {
public:
    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped)
    {
        stack&lt;int&gt; lstack;

        int j = 0;
        for (int num : pushed)
        {
            lstack.push(num);

            while (!lstack.empty() &amp;&amp; lstack.top() == popped[j])
            {
                lstack.pop();
                j++;
            }
        }
        return j == popped.size();
    }
};</code></pre>
<p><strong>精简思路</strong></p>
<p>源代码是栈不为空的时候 比较栈顶和<code>popped[i]</code></p>
<p>如果相等则出栈</p>
<p>如果不相等 转去判断<code>pushed当前元素</code>和<code>popped[i]</code></p>
<p>如果两者相等则后移</p>
<p>如果两者不相等则入栈当前元素.</p>
<p><em>实际上这里就可以直接入栈元素然后再判断,如果相等了就出栈 如果不相等也恰好入栈了</em></p>
<h3 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - I. 从上到下打印二叉树</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre><p>返回：</p>
<pre><code>[3,9,20,15,7]</code></pre><p><strong>提示：</strong></p>
<ol>
<li><code>节点总数 &lt;= 1000</code></li>
</ol>
<h4 id="Solution-deque"><a href="#Solution-deque" class="headerlink" title="Solution - deque"></a>Solution - deque</h4><pre><code class="c++">​class Solution {
public:
    vector&lt;int&gt; levelOrder(TreeNode* root)
    {
        if (!root)
        {
            return {};
        }
        deque&lt;TreeNode*&gt; nodes;

        nodes.push_back(root);

        vector&lt;int&gt; result;
        while (!nodes.empty())
        {
            TreeNode* node = nodes.front();
            nodes.pop_front();

            result.push_back(node-&gt;val);

            if (node-&gt;left)
            {
                nodes.push_back(node-&gt;left);
            }
            if (node-&gt;right)
            {
                nodes.push_back(node-&gt;right);
            }
        }
        return result;
    }
};</code></pre>
<h3 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre><p>返回其层次遍历结果：</p>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]</code></pre><p><strong>提示：</strong></p>
<ol>
<li><code>节点总数 &lt;= 1000</code></li>
</ol>
<p>注意：本题与主站 102 题相同：</p>
<h4 id="Solution-使用nullptr标记"><a href="#Solution-使用nullptr标记" class="headerlink" title="Solution - 使用nullptr标记"></a>Solution - 使用nullptr标记</h4><pre><code class="c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)
    {
        if (!root)
        {
            return {};
        }

        deque&lt;TreeNode*&gt; nodes;

        nodes.push_back(root);
        nodes.push_back(nullptr);

        vector&lt;vector&lt;int&gt;&gt; result;
        result.push_back(vector&lt;int&gt;());

        while (!nodes.empty())
        {
            TreeNode* node = nodes.front();
            nodes.pop_front();

            if (node)
            {
                result.back().push_back(node-&gt;val);
                if (node-&gt;left)
                {
                    nodes.push_back(node-&gt;left);
                }
                if (node-&gt;right)
                {
                    nodes.push_back(node-&gt;right);
                }
            }
            else
            {
                if (!nodes.empty())
                {
                    result.push_back(vector&lt;int&gt;());
                    nodes.push_back(nullptr);
                }
            }
        }

        return result;
    }
};</code></pre>
<p>首先想出的就是这个方法</p>
<h4 id="使用for循环-提前保存变量解决size会改变的问题"><a href="#使用for循环-提前保存变量解决size会改变的问题" class="headerlink" title="- 使用for循环 提前保存变量解决size会改变的问题"></a>- 使用for循环 提前保存变量解决size会改变的问题</h4><pre><code class="c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)
    {
        if (!root)
        {
            return {};
        }

        deque&lt;TreeNode*&gt; nodes;

        nodes.push_back(root);

        vector&lt;vector&lt;int&gt;&gt; result;

        while (!nodes.empty())
        {
            result.push_back(vector&lt;int&gt;());

            int ss = nodes.size();
            for (int i = 0; i &lt; ss; ++i)
            {
                TreeNode* node = nodes.front();
                nodes.pop_front();

                result.back().push_back(node-&gt;val);
                if (node-&gt;left)
                {
                    nodes.push_back(node-&gt;left);
                }
                if (node-&gt;right)
                {
                    nodes.push_back(node-&gt;right);
                }
            }
        }

        return result;
    }
};</code></pre>
<p>写完S1就去看了看题解 没想到还有这种方法, 妙蛙种子在米奇妙妙屋吃妙脆角</p>
<h3 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre><p>返回其层次遍历结果：</p>
<pre><code>[
  [3],
  [20,9],
  [15,7]
]</code></pre><p><strong>提示：</strong></p>
<ol>
<li><code>节点总数 &lt;= 1000</code></li>
</ol>
<h4 id="Solution-设置标志位"><a href="#Solution-设置标志位" class="headerlink" title="Solution - 设置标志位"></a>Solution - 设置标志位</h4><pre><code class="c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) 
    {
        if (!root)
        {
            return {};
        }

        deque&lt;TreeNode*&gt; nodes;
        nodes.push_back(root);

        bool right = true;

        vector&lt;vector&lt;int&gt;&gt; result;

        while (!nodes.empty())
        {
            result.emplace_back();

            int SS = nodes.size();

            if (right)
            {
                right = false;
                for (int i = 0; i &lt; SS; ++i)
                {
                    TreeNode* node = nodes.front();
                    nodes.pop_front();
                    result.back().push_back(node-&gt;val);

                    if (node-&gt;left)
                    {
                        nodes.push_back(node-&gt;left);
                    }
                    if (node-&gt;right)
                    {
                        nodes.push_back(node-&gt;right);
                    }
                }
            }
            else
            {
                right = true;
                for (int i = SS - 1; i &gt;= 0; --i)
                {
                    TreeNode* node = nodes.back();
                    nodes.pop_back();
                    result.back().push_back(node-&gt;val);

                    if (node-&gt;right)
                    {
                        nodes.push_front(node-&gt;right);
                    }
                    if (node-&gt;left)
                    {
                        nodes.push_front(node-&gt;left);
                    }
                }
            }
        }
        return result;
    }
};​</code></pre>
<h4 id="Solution-使用reverse"><a href="#Solution-使用reverse" class="headerlink" title="Solution - 使用reverse"></a>Solution - 使用reverse</h4><pre><code class="c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) 
    {
        if (!root)
        {
            return {};
        }

        deque&lt;TreeNode*&gt; nodes;
        nodes.push_back(root);

        vector&lt;vector&lt;int&gt;&gt; result;
        bool even = false;

        while (!nodes.empty())
        {
            result.emplace_back();

            int SS = nodes.size();

            vector&lt;int&gt;&amp; tmp = result.back();
            for (int i = 0; i &lt; SS; ++i)
            {
                TreeNode* node = nodes.front();
                nodes.pop_front();
                tmp.push_back(node-&gt;val);

                if (node-&gt;left)
                {
                    nodes.push_back(node-&gt;left);
                }
                if (node-&gt;right)
                {
                    nodes.push_back(node-&gt;right);
                }
            }

            if (even)
            {
                std::reverse(tmp.begin(), tmp.end());
            }
            even = !even;
        }
        return result;
    }
};</code></pre>
<h3 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
<pre><code>     5
    / \
   2   6
  / \
 1   3</code></pre><p><strong>示例 1：</strong></p>
<pre><code>输入: [1,6,3,2,5]
输出: false</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入: [1,3,2,6,5]
输出: true</code></pre><p><strong>提示：</strong></p>
<ol>
<li><code>数组长度 &lt;= 1000</code></li>
</ol>
<h4 id="Solution-递归-3"><a href="#Solution-递归-3" class="headerlink" title="Solution - 递归"></a>Solution - 递归</h4><pre><code class="c++">​class Solution {
public:
    bool verifyPostorder(vector&lt;int&gt;&amp; postorder)
    {
        return verifyPostorder(postorder, 0, postorder.size());
    }

    bool verifyPostorder(vector&lt;int&gt;&amp; postorder, int begin, int end)
    {
        if (end - begin &lt;= 2)
        {
            return true;
        }

        int root_sub = end - 1;
        int r_begin = begin;
        for (int i = begin; i &lt; root_sub; ++i)
        {
            if (postorder[i] &lt; postorder[root_sub])
            {
                r_begin++;
            }
            else
            {
                break;
            }
        }

        for (int i = r_begin; i &lt; root_sub; ++i)
        {
            if (postorder[i] &lt; postorder[root_sub])
            {
                return false;
            }
        }
        return verifyPostorder(postorder, begin, r_begin) &amp;&amp; 
            verifyPostorder(postorder, r_begin, root_sub);
    }
};</code></pre>
<p>睡前来一道, 这是我第一次 一次通过的剑指里面的中等题目-_- 睡了睡了</p>
<h4 id="Solution-迭代-栈"><a href="#Solution-迭代-栈" class="headerlink" title="Solution - 迭代 栈"></a>Solution - 迭代 栈</h4><h3 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<pre><code>              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1</code></pre><p>返回:</p>
<pre><code>[
   [5,4,11,2],
   [5,8,4,5]
]</code></pre><p><strong>提示：</strong></p>
<ol>
<li><code>节点总数 &lt;= 10000</code></li>
</ol>
<p>注意：本题与主站 113 题相同：</p>
<h4 id="Solution-回溯法"><a href="#Solution-回溯法" class="headerlink" title="Solution - 回溯法"></a>Solution - 回溯法</h4><pre><code class="c++">​class Solution {
public:

    vector&lt;int&gt; path;
    vector&lt;vector&lt;int&gt;&gt; result;

    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum)
    {
        dfs(root, sum);

        return result; 
    }

    void dfs(TreeNode* root, int sum)
    {
        if (!root)
        {
            return;
        }

        path.push_back(root-&gt;val);
        if (sum == root-&gt;val &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)
        {
            result.push_back(path);
        }
        else
        {
            dfs(root-&gt;left, sum - root-&gt;val);
            dfs(root-&gt;right, sum - root-&gt;val);
        }
        path.pop_back();
    }
};</code></pre>
<h3 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 37. 序列化二叉树</a></h3><p>Difficulty: <strong>困难</strong></p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>*<em>示例: *</em></p>
<pre><code>你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 &quot;[1,2,3,null,null,4,5]&quot;</code></pre><p>注意：本题与主站 297 题相同：</p>
<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root)
    {
        if (!root)
        {
            return &quot;[null]&quot;;
        }

        deque&lt;TreeNode*&gt; nodes;
        nodes.push_back(root);

        string result;
        while (!nodes.empty())
        {
            TreeNode* node = nodes.front();
            nodes.pop_front();
            if (node)
            {
                result += &quot;,&quot; + to_string(node-&gt;val);
                nodes.push_back(node-&gt;left);
                nodes.push_back(node-&gt;right);
            }
            else
            {
                result += &quot;,null&quot;;
            }
        }

        result[0] = &#39;[&#39;;
        result += &#39;]&#39;;
        return result;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data)
    {
        deque&lt;TreeNode*&gt; nodes;
        ParseData(data, nodes);

        TreeNode* ret = nodes.front();
        nodes.pop_front();

        if (nodes.size() == 0)
        {
            return ret;
        }

        deque&lt;TreeNode*&gt; temp_nodes;
        temp_nodes.push_back(ret);

        while (!temp_nodes.empty())
        {
            const int SS = temp_nodes.size();

            if (nodes.size() &lt; SS * 2)
            {
                break;
            }

            for (int i = 0; i &lt; SS; ++i)
            {
                TreeNode* node = temp_nodes.front();
                temp_nodes.pop_front();

                node-&gt;left = nodes.front();
                nodes.pop_front();
                node-&gt;right = nodes.front();
                nodes.pop_front();

                if (node-&gt;left)
                {
                    temp_nodes.push_back(node-&gt;left);
                }
                if (node-&gt;right)
                {
                    temp_nodes.push_back(node-&gt;right);
                }
            }
        }

        return ret;
    }

    void ParseData(const string&amp; data, deque&lt;TreeNode*&gt;&amp; nodes)
    {
        int i = 1;

        int num = 0;
        bool empty = false;
        int flag = 1; // -

        while (i &lt; data.size())
        {
            char c = data[i++];

            if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)
            {
                num = num * 10 + c - &#39;0&#39;;
            }
            else if (c == &#39;,&#39; || c == &#39;]&#39;)
            {
                if (empty)
                {
                    nodes.push_back(nullptr);
                    empty = false;
                }
                else
                {
                    nodes.push_back(new TreeNode(num * flag));
                    num = 0;
                    flag = 1;
                }
            }
            else if (c == &#39;n&#39;)
            {
                empty = true;
            }
            else if (c == &#39;-&#39;)
            {
                flag = -1;
            }
        }
    }
};​</code></pre>
<h3 id="剑指-Offer-38-字符串的排列-30MIN"><a href="#剑指-Offer-38-字符串的排列-30MIN" class="headerlink" title="剑指 Offer 38. 字符串的排列 - 30MIN"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 38. 字符串的排列</a> - 30MIN</h3><p>Difficulty: <strong>中等</strong></p>
<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p><strong>示例:</strong></p>
<pre><code>输入：s = &quot;abc&quot;
输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</code></pre><p><strong>限制：</strong></p>
<p><code>1 &lt;= s 的长度 &lt;= 8</code></p>
<h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:

    vector&lt;string&gt; result;

    vector&lt;string&gt; permutation(string s)
    {
        std::string temp;
        temp.resize(s.size());

        permutation(s, 0, temp);
        return result;
    }

    void permutation(string&amp; s, int sub, std::string&amp; temp)
    {
        if (sub == s.size())
        {
            result.push_back(temp);
            return;
        }

        char flag[&#39;z&#39; - &#39;A&#39; + 1]{};
        for (int i = 0; i &lt; s.size(); ++i)
        {
            char back = s[i];
            if (back != &#39;#&#39;)
            {
                if (flag[back - &#39;A&#39;] == 0)
                {
                    flag[back - &#39;A&#39;] = 1;
                    temp[sub] = s[i];

                    s[i] = &#39;#&#39;;
                    permutation(s, sub + 1, temp);
                    s[i] = back;
                }
            }
        }
    }
};</code></pre>
<p>代码中防止重复的代码太巧了, 自己一开始使用的set去重. 然后看到了题解的剪枝方法 在每一层中一个字母仅能出现一次, 时间消耗大幅下降了</p>
<h4 id="Solution-改进版-源字符串上swap"><a href="#Solution-改进版-源字符串上swap" class="headerlink" title="Solution - 改进版 - 源字符串上swap"></a>Solution - 改进版 - 源字符串上swap</h4><pre><code class="c++">class Solution {
public:

    vector&lt;string&gt; result;

    vector&lt;string&gt; permutation(string s)
    {        
        permutation(s, 0);
        return result;
    }

    void permutation(string&amp; s, int sub)
    {
        if (sub == s.size() - 1) // 仅剩一个字符 该字符正好位于末尾 直接保存
        {
            result.push_back(s);
            return;
        }

        char flag[&#39;z&#39; - &#39;A&#39; + 1]{};
        for (int i = sub; i &lt; s.size(); ++i) // 从本层开始 sub之前的字符已经被使用了
        {
            char back = s[i];

            if (flag[back - &#39;A&#39;] == 0)
            {
                flag[back - &#39;A&#39;] = 1;

                swap(s[i], s[sub]); // 交换未使用元素到本层位置
                permutation(s, sub + 1);
                swap(s[i], s[sub]);
            }
        }
    }
};</code></pre>
<p>由于是全排列, 其实可以将未使用元素挨个的交换到本层位置 这样本层位置之前的字符是使用过的.</p>
<h3 id="剑指-Offer-39-数组中出现次数超过一半的数字-20MIN"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字-20MIN" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字 - 20MIN"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 39. 数组中出现次数超过一半的数字</a> - 20MIN</h3><p>Difficulty: <strong>简单</strong></p>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2</code></pre><p><strong>限制：</strong></p>
<p><code>1 &lt;= 数组长度 &lt;= 50000</code></p>
<p>注意：本题与主站 169 题相同：</p>
<h4 id="Solution-Map统计次数"><a href="#Solution-Map统计次数" class="headerlink" title="Solution - Map统计次数"></a>Solution - Map统计次数</h4><pre><code class="c++">​int majorityElement(vector&lt;int&gt;&amp; nums)
{
    map&lt;int, int&gt; times;

    int end_time = nums.size() / 2;

    for (auto&amp; num : nums)
    {
        times[num]++;
        if (times[num] &gt; end_time)
        {
            return num;
        }
    }
    return 0;
}</code></pre>
<h4 id="Solution-sort排序-中间位置元素为结果"><a href="#Solution-sort排序-中间位置元素为结果" class="headerlink" title="Solution - sort排序 中间位置元素为结果"></a>Solution - sort排序 中间位置元素为结果</h4><pre><code class="c++">int majorityElement(vector&lt;int&gt;&amp; nums)
{
    sort(nums.begin(), nums.end());

    return nums[nums.size() / 2];
}</code></pre>
<h4 id="Solution-摩尔投票法"><a href="#Solution-摩尔投票法" class="headerlink" title="Solution - 摩尔投票法"></a>Solution - 摩尔投票法</h4><pre><code class="c++">int majorityElement(vector&lt;int&gt;&amp; nums)
{
    int vote = nums[0];
    int sum = 0;

    for (auto&amp; num : nums)
    {
        sum += vote == num ? 1 : -1;
        if (sum &lt; 0)
        {
            vote = num;
            sum = 1;
        }
    }

    // int times = 0;
    // for (auto&amp; num : nums)
    // {
    //     times += num == vote ? 1 : 0;
    // }
    // 如果可能不存在结果 则需要进行验证
    return vote;
}</code></pre>
<h3 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：arr = [0,1,2,1], k = 1
输出：[0]</code></pre><p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10000</code></li>
</ul>
<h4 id="Solution-维护最大堆-O-nlogk-O-k"><a href="#Solution-维护最大堆-O-nlogk-O-k" class="headerlink" title="Solution - 维护最大堆 O(nlogk) O(k)"></a>Solution - 维护最大堆 O(nlogk) O(k)</h4><pre><code class="c++">​class Solution {
public:

    priority_queue&lt;int&gt; min_heap;

    void TryToAdd(int num, int k)
    {
        if (min_heap.size() &lt; k)
        {
            min_heap.push(num);
        }
        else
        {
            if (num &lt; min_heap.top())
            {
                min_heap.pop();
                min_heap.push(num);
            }
        }
    }

    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k)
    {
        if (k &lt;= 0)
        {
            return {};
        }

        for (auto num : arr)
        {
            TryToAdd(num, k);
        }

        vector&lt;int&gt; result(k);
        for (int i = 0; i &lt; k; ++i)
        {
            result[i] = min_heap.top();
            min_heap.pop();
        }
        return result;
    }
};</code></pre>
<h4 id="Solution-基于快排分区思想-O-n-O-logn"><a href="#Solution-基于快排分区思想-O-n-O-logn" class="headerlink" title="Solution - 基于快排分区思想 O(n) O(logn)"></a>Solution - 基于快排分区思想 O(n) O(logn)</h4><pre><code class="c++">class Solution {
public:

    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k)
    {
        if (k == 0)
        {
            return {};
        }
        Partition(arr, 0, arr.size() - 1, k);

        return vector&lt;int&gt;(arr.begin(), arr.begin() + k);
    }

    int Partition(vector&lt;int&gt;&amp; arr, int left , int right, int k)
    {
        if (right - left &lt;= 0)
        {
            return left;
        }
        int ret = left;

        int index = ret + 1;

        for (int i = index; i &lt;= right; ++i)
        {
            if (arr[i] &lt; arr[ret])
            {
                swap(arr[index], arr[i]);
                index++;
            }
        }
        swap(arr[index - 1], arr[ret]);
        int part = index - 1;

        if (part == k)
        {
            return part;
        }
        else if (part &lt; k)
        {
            return Partition(arr, part + 1, right, k);
        }
        else
        {
            return Partition(arr, left, part - 1, k);
        }
    }
};</code></pre>
<h3 id="剑指-Offer-41-数据流中的中位数-30MIN"><a href="#剑指-Offer-41-数据流中的中位数-30MIN" class="headerlink" title="剑指 Offer 41. 数据流中的中位数 - 30MIN"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 41. 数据流中的中位数</a> - 30MIN</h3><p>Difficulty: <strong>困难</strong></p>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。</li>
</ul>
<p><strong>示例 1：</strong></p>
<pre><code>输入：
[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]
[[],[1],[2],[],[3],[]]
输出：[null,null,null,1.50000,null,2.00000]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：
[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]
[[],[2],[],[3],[]]
输出：[null,null,2.00000,null,2.50000]</code></pre><p><strong>限制：</strong></p>
<ul>
<li>最多会对 <code>addNum、findMedian</code> 进行 <code>50000</code> 次调用。</li>
</ul>
<p>注意：本题与主站 295 题相同：</p>
<h4 id="Solution-最大堆-最小堆-求中位数"><a href="#Solution-最大堆-最小堆-求中位数" class="headerlink" title="Solution 最大堆 + 最小堆 求中位数"></a>Solution 最大堆 + 最小堆 求中位数</h4><pre><code class="c++">​class MedianFinder {
public:

    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_heap;
    priority_queue&lt;int&gt; max_heap;
    int size = 0;

    /** initialize your data structure here. */
    MedianFinder() {

    }

    void addNum(int num)
    {
        if (size == 0)
        {
            min_heap.push(num);
        }
        else
        {
            if (size % 2 == 0)
            {
                if (num &gt; max_heap.top())
                {
                    min_heap.push(num);
                }
                else
                {
                    max_heap.push(num);
                    min_heap.push(max_heap.top());
                    max_heap.pop();
                }
            }
            else
            {
                if (num &lt; min_heap.top())
                {
                    max_heap.push(num);
                }
                else
                {
                    min_heap.push(num);
                    max_heap.push(min_heap.top());
                    min_heap.pop();
                }
            }
        }
        size++;
    }

    double findMedian()
    {
        if (size % 2 == 0)
        {
            return (max_heap.top() + min_heap.top()) / 2.0;
        }
        else
        {
            return min_heap.top();
        }
    }
};</code></pre>
<p>最开始写的时候堆的调整写在了findMedian里面, 实际应该写在addNum这样函数的功能才分工明确 而且由于两个堆大小基本平衡效率更高</p>
<h3 id="剑指-Offer-42-连续子数组的最大和-5MIN"><a href="#剑指-Offer-42-连续子数组的最大和-5MIN" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和 - 5MIN"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">剑指 Offer 42. 连续子数组的最大和</a> - 5MIN</h3><p>Difficulty: <strong>简单</strong></p>
<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<p><strong>示例1:</strong></p>
<pre><code>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>-100 &lt;= arr[i] &lt;= 100</code></li>
</ul>
<p>注意：本题与主站 53 题相同：</p>
<h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums)
    {
        int sum = 0;
        int ret = nums[0];
        for (auto&amp; num : nums)
        {
            if (sum &gt;= 0)
            {
                sum += num;
            }
            else
            {
                sum = num;
            }
            ret = max(sum, ret);
        }
        return ret;
    }
};</code></pre>
<h3 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 45. 把数组排成最小的数</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [10,2]
输出: &quot;102&quot;</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: [3,30,34,5,9]
输出: &quot;3033459&quot;</code></pre><p><strong>提示:</strong></p>
<ul>
<li><code>0 &lt; nums.length &lt;= 100</code></li>
</ul>
<p><strong>说明:</strong></p>
<ul>
<li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li>
<li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li>
</ul>
<h4 id="Solution-遇事不决dfs-超时"><a href="#Solution-遇事不决dfs-超时" class="headerlink" title="Solution - 遇事不决dfs 超时.."></a>Solution - 遇事不决dfs 超时..</h4><pre><code class="c++">​class Solution {
public:

    string minNumber(vector&lt;int&gt;&amp; nums)
    {
        string result;
        string temp;
        dfs(nums, 0, result, temp);
        return result;
    }

    void dfs(vector&lt;int&gt;&amp; nums, int sub, string&amp; result, string&amp; temp)
    {
        if (!result.empty() &amp;&amp; result.compare(temp) &lt; 0) // 剪枝
        {
            return;
        }

        if (sub == nums.size())
        {
            if (result.empty() || result.compare(temp) &gt; 0)
            {
                result = temp;
            }
            return;
        }

        set&lt;int&gt; exist;
        for (int i = sub; i &lt; nums.size(); ++i)
        {
            auto iter = exist.lower_bound(nums[i]); // 剪枝
            if (iter == exist.end() || *iter != nums[i])
            {
                exist.insert(iter, nums[i]);

                swap(nums[i], nums[sub]);

                string num = to_string(nums[sub]);
                temp += num;

                dfs(nums, sub + 1, result, temp);

                temp.erase(temp.end() - num.size(), temp.end());

                swap(nums[i], nums[sub]);
            }
        }
    }
};</code></pre>
<h4 id="Solution-特殊的排序-另类的comp函数"><a href="#Solution-特殊的排序-另类的comp函数" class="headerlink" title="Solution - 特殊的排序(另类的comp函数)"></a>Solution - 特殊的排序(另类的comp函数)</h4><pre><code class="c++">class Solution {
public:

    void QuickSort(vector&lt;string&gt;&amp; strs, int left, int right)
    {
        if (right - left &lt;= 0)
        {
            return;
        }

        auto comp =
            [](const string&amp; lhs, const string&amp; rhs)
            {
                return lhs + rhs &lt; rhs + lhs;
            };

        int pivot = left;

        int index = left + 1;
        for (int i = index; i &lt;= right; ++i)
        {
            if (comp(strs[i], strs[pivot]))
            {
                swap(strs[i], strs[index]);
                index++;
            }
        }
        swap(strs[pivot], strs[index - 1]);

        // int le = left;
        // int ri = right;

        // while (le &lt; ri)
        // {
        //     while (le &lt; ri &amp;&amp; !comp(strs[ri], strs[pivot]))
        //     {
        //         ri--;
        //     }
        //     while (le &lt; ri &amp;&amp; comp(strs[le], strs[pivot]))
        //     {
        //         le++;
        //     }
        //     swap(strs[le], strs[ri]);
        // }
        // swap(strs[le], strs[pivot]);

        QuickSort(strs, left, index - 2);
        QuickSort(strs, index, right);
    }

    string minNumber(vector&lt;int&gt;&amp; nums)
    {
        vector&lt;string&gt; strs;
        strs.reserve(nums.size());

        for (int num : nums)
        {
            strs.push_back(to_string(num));
        }

        QuickSort(strs, 0, strs.size() - 1);

        string result;
        for (const auto&amp; str : strs)
        {
            result += str;
        }
        return result;
    }
};</code></pre>
<h3 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 46. 把数字翻译成字符串</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= num &lt; 2&lt;sup&gt;31&lt;/sup&gt;</code></li>
</ul>
<h4 id="Solution-遇事不决dfs"><a href="#Solution-遇事不决dfs" class="headerlink" title="Solution - 遇事不决dfs"></a>Solution - 遇事不决dfs</h4><pre><code class="c++">​class Solution {
public:
    int translateNum(int num)
    {
        string num_str = to_string(num);

        return dfs(num_str, 0);
    }

    int dfs(const string&amp; str, int sub)
    {
        if (sub &gt; str.size())
        {
            return 0;
        }
        else if (sub &gt;= str.size() - 1)
        {
            return 1;
        }

        int time = 0;
        if (sub &lt; str.size() - 1 &amp;&amp; str[sub] == &#39;1&#39;)
        {
            time += dfs(str, sub + 2);
        }
        else if (sub &lt; str.size() - 1 &amp;&amp; str[sub] == &#39;2&#39; &amp;&amp; 
                str[sub + 1] &gt;= &#39;0&#39; &amp;&amp; str[sub + 1] &lt;= &#39;5&#39;)
        {
            time += dfs(str, sub + 2);
        }

        time += dfs(str, sub + 1);

        return time;
    }
};</code></pre>
<h4 id="Solution-DP"><a href="#Solution-DP" class="headerlink" title="Solution - DP"></a>Solution - DP</h4><pre><code class="c++">class Solution {
public:
    int translateNum(int num)
    {
        string num_str = to_string(num);

        vector&lt;int&gt; dp(num_str.size() + 1);
        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i &lt;= num_str.size(); ++i)
        {
            dp[i] = dp[i - 1];

            if (num_str[i - 2] == &#39;1&#39;)
            {
                dp[i] += dp[i - 2];
            }
            else if (num_str[i - 2] == &#39;2&#39; &amp;&amp; num_str[i - 1] &gt;= &#39;0&#39; &amp;&amp; num_str[i - 1] &lt;= &#39;5&#39;)
            {
                dp[i] += dp[i - 2];
            }
        }
        return dp[num_str.size()];
    }
};</code></pre>
<p>可以对dp数组进行降维打击 易读性也被降维打击了</p>
<pre><code class="c++">class Solution {
public:
    int translateNum(int num)
    {
        string num_str = to_string(num);

        int a = 1; // i - 2
        int b = 1; // i - 1
        int dp = b; // i

        for (int i = 2; i &lt;= num_str.size(); ++i)
        {
            dp = b;

            if (num_str[i - 2] == &#39;1&#39;)
            {
                dp += a;
            }
            else if (num_str[i - 2] == &#39;2&#39; &amp;&amp; num_str[i - 1] &gt;= &#39;0&#39; &amp;&amp; num_str[i - 1] &lt;= &#39;5&#39;)
            {
                dp += a;
            }
            a = b;
            b = dp;
        }
        return dp;
    }
};</code></pre>
<p><code>dp[0]=1</code>这点没有考虑到, 本来设置的为0. </p>
<p>然而当num为25的时候<code>dp[2]</code>应该为2, 所以必须把<code>dp[0]</code>设置为1</p>
<p>状态转移方程<code>dp[i] = dp[i - 1] + dp[i - 2](i-1和i-2字符需要能连接)</code> 是因为如果把<code>i-1和i-2</code>连接有<code>dp[i-2]</code>种</p>
<p>如果不连接则有<code>dp[i - 1]</code>种 所以最终是二者之和</p>
<p>可以对str字符串进行降维打击 易读性又双被降维打击了</p>
<pre><code class="c++">class Solution {
public:
    int translateNum(int num)
    {
        int a = 1; // i - 2
        int b = 1; // i - 1
        int dp = b; // i

        int last_s = num % 10;
        int now_s;
        num /= 10;

        while (num != 0)
        {
            now_s = num % 10;
            num /= 10;

            dp = b;

            int temp = now_s * 10 + last_s;
            if (temp &gt;= 10 &amp;&amp; temp &lt;= 25)
            {
                dp += a;
            }

            a = b;
            b = dp;

            last_s = now_s;
        }
        return dp;
    }
};</code></pre>
<h3 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 47. 礼物的最大价值</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</code></pre><p>提示：</p>
<ul>
<li><code>0 &lt; grid.length &lt;= 200</code></li>
<li><code>0 &lt; grid[0].length &lt;= 200</code></li>
</ul>
<h4 id="Solution-备忘录-接近超时"><a href="#Solution-备忘录-接近超时" class="headerlink" title="Solution - 备忘录 接近超时"></a>Solution - 备忘录 接近超时</h4><pre><code class="c++">​class Solution {
public:
    int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid)
    {
        return dfs(grid, 0, 0);
    }

    std::map&lt;std::string, int&gt; bwl;
    int dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y)
    {
        if (x == grid.size() - 1 &amp;&amp; y == grid[0].size() - 1)
        {
            return grid[x][y];
        }

        std::string key = to_string(x) + &quot;,&quot; + to_string(y);
        auto iter = bwl.find(key);
        if (iter != bwl.end())
        {
            return iter-&gt;second;
        }

        int r = 0;
        int d = 0;
        if (x &lt; grid.size() - 1 &amp;&amp; y &lt; grid[0].size())
        {
            r = dfs(grid, x + 1, y);
        }
        if (y &lt; grid[0].size() - 1 &amp;&amp; x &lt; grid.size())
        {
            d = dfs(grid, x, y + 1);
        }

        int result = max(r, d) + grid[x][y];
        bwl[key] = result;
        return result;
    }
};</code></pre>
<h4 id="Solution-dp-table-接近100"><a href="#Solution-dp-table-接近100" class="headerlink" title="Solution - dp table 接近100%"></a>Solution - dp table 接近100%</h4><pre><code class="c++">class Solution {
public:
    int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid)
    {
        const int XS = grid.size();
        const int YS = grid[0].size();

        vector&lt;vector&lt;int&gt;&gt; dp(XS + 1, vector&lt;int&gt;(YS + 1, 0));

        for (int x = 1; x &lt;= XS; ++x)
        {
            for (int y = 1; y &lt;= YS; ++y)
            {
                dp[x][y] = max(dp[x - 1][y], dp[x][y - 1]) + grid[x - 1][y - 1];
            }
        }
        return dp[XS][YS];
    }
};</code></pre>
<h3 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 48. 最长不含重复字符的子字符串</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p>
<pre><code>输入: &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><p>提示：</p>
<ul>
<li><code>s.length &lt;= 40000</code></li>
</ul>
<p>注意：本题与主站 3 题相同：</p>
<h4 id="Solution-双指针-hash表"><a href="#Solution-双指针-hash表" class="headerlink" title="Solution - 双指针 + hash表"></a>Solution - 双指针 + hash表</h4><pre><code class="c++">​class Solution {
public:
    int lengthOfLongestSubstring(string s) 
    {
        if (s.empty())
        {
            return 0;
        }

        int begin = 0;
        int end = 0;
        int hash[128]{};
        for (int i = 0; i &lt; 128; ++i)
        {
            hash[i] = -1;
        }

        int ret = 1;
        for (;end &lt; s.size(); ++end)
        {
            char c = s[end];
            if (hash[c] &gt;= begin)
            {
                int len = end - begin;
                ret = max(len, ret);
                begin = hash[c] + 1;
            }
            hash[c] = end;
        }
        ret = max(end - begin, ret);
        return ret;
    }
};</code></pre>
<pre><code class="c++">​class Solution {
public:
    int lengthOfLongestSubstring(string s) 
    {
        int begin = 0;
        int end = 0;
        int hash[128]{};
        for (int i = 0; i &lt; 128; ++i)
        {
            hash[i] = -1;
        }

        int ret = 0;
        for (;end &lt; s.size(); ++end)
        {
            char c = s[end];
            if (hash[c] &gt;= begin)
            {
                begin = hash[c] + 1;
            }
            ret = max(end - begin + 1, ret);
            hash[c] = end;
        }
        return ret;
    }
};</code></pre>
<p>简化版, <code>hash[c] &gt;= begin</code>主要是更细begin指针, 而更新ret的可以放一起. 原版是end在重复的字符上进行取长度, 新版则是end未在重复字符上 所以需要长度 + 1</p>
<h4 id="Solution-Dp-hash表"><a href="#Solution-Dp-hash表" class="headerlink" title="Solution - Dp + hash表"></a>Solution - Dp + hash表</h4><pre><code class="c++">class Solution {
public:
    int lengthOfLongestSubstring(string s) 
    {
        int hash[128]{};
        vector&lt;int&gt; dp(s.size() + 1);
        dp[0] = 0;
        int begin = 1;
        int ret = 0;
        for(int i = 1; i &lt;= s.size(); ++i)
        {
            char c = s[i - 1];
            if (hash[c] &gt;= begin)
            {
                dp[i] = i - hash[c];
                begin = hash[c] + 1;
            } 
            else
            {
                dp[i] = dp[i - 1] + 1;
            }
            hash[c] = i;
            ret = max(ret, dp[i]);
        }
        return ret;
    }
};</code></pre>
<h3 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 49. 丑数</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</code></pre><p>*<em>说明: *</em> </p>
<ol>
<li><code>1</code> 是丑数。</li>
<li><code>n</code> <strong>不超过</strong>1690。</li>
</ol>
<p>注意：本题与主站 264 题相同：</p>
<h4 id="Solution-逐个计算-超时"><a href="#Solution-逐个计算-超时" class="headerlink" title="Solution - 逐个计算 超时"></a>Solution - 逐个计算 超时</h4><pre><code class="c++">​class Solution {
public:
    int nthUglyNumber(int n)
    {
        if (n &lt;= 1)
        {
            return 1;
        }

        unordered_set&lt;int&gt; ugly_num;
        vector&lt;int&gt; bases = {2, 3, 5};
        ugly_num.insert(1);

        int k = 1;
        int num = 1;
        while (k &lt; n)
        {
            num++;
            for (int base : bases)
            {
                if (num % base == 0 &amp;&amp; ugly_num.find(num / base) != ugly_num.end())
                {
                    ugly_num.insert(num);
                    k++;
                    break;
                }
            }
        }
        return num;
    }
};</code></pre>
<h4 id="Solution-生成丑数"><a href="#Solution-生成丑数" class="headerlink" title="Solution - 生成丑数"></a>Solution - 生成丑数</h4><pre><code class="c++">class Solution {
public:
    int nthUglyNumber(int n)
    {
        int dp[n];
        dp[0] = 1;
        int a = 0, b = 0, c = 0;
        for (int i = 1; i &lt; n; ++i)
        {
            int numa = dp[a] * 2;
            int numb = dp[b] * 3;
            int numc = dp[c] * 5;

            int min_abc = min(numa, min(numb, numc));
            dp[i] = min_abc;
            if (min_abc == numa)
            {
                a++;
            }
            if (min_abc == numb)
            {
                b++;
            }
            if (min_abc == numc)
            {
                c++;
            }
        }
        return dp[n - 1];
    }
};</code></pre>
<p>每个新的丑数都是已有丑数的2 3 5倍, 需要按循序将这些丑数排好. 如果一个数字已经提供过了新的丑数, 那么就应该有这个新的丑数尝试去提供, 否则一定是重复的 对应了</p>
<p>代码中的a++ b++ c++, 每次取出最小的丑数添加到结果中</p>
<h3 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">剑指 Offer 50. 第一个只出现一次的字符</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p><strong>示例:</strong></p>
<pre><code>s = &quot;abaccdeff&quot;
返回 &quot;b&quot;

s = &quot;&quot; 
返回 &quot; &quot;</code></pre><p><strong>限制：</strong></p>
<p><code>0 &lt;= s 的长度 &lt;= 50000</code></p>
<h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:
    char firstUniqChar(string s)
    {
        if (s.empty())
        {
            return &#39; &#39;;
        }

        int hash2[26]{};
        for (int i = 0; i &lt; 26; ++i)
        {
            hash2[i] = -1;
        }

        for (int i = 0; i &lt; s.size(); ++i)
        {
            int c = s[i] - &#39;a&#39;;

            if (hash2[c] == -1)
            {
                hash2[c] = i; // 标记第一次出现的位置
            }
            else
            {
                hash2[c] = -2;
            }
        }

        int min_sub = -1;
        int min = INT_MAX;
        for (int i = 0; i &lt; 26; ++i)
        {
            if (hash2[i] &gt;= 0 &amp;&amp; hash2[i] &lt; min)
            {
                min = hash2[i];
                min_sub = i;  
            }
        }
        if (min_sub == -1)
        {
            return &#39; &#39;;
        }

        char result = &#39;a&#39; + min_sub;
        return result;
    }
};</code></pre>
<h3 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">剑指 Offer 51. 数组中的逆序对</a></h3><p>Difficulty: <strong>困难</strong></p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [7,5,6,4]
输出: 5</code></pre><p><strong>限制：</strong></p>
<p><code>0 &lt;= 数组长度 &lt;= 50000</code></p>
<h4 id="Solution-归并排序-求逆序对"><a href="#Solution-归并排序-求逆序对" class="headerlink" title="Solution - 归并排序 求逆序对"></a>Solution - 归并排序 求逆序对</h4><pre><code class="c++">class Solution {
public:
    int reversePairs(vector&lt;int&gt;&amp; nums)
    {
        vector&lt;int&gt; temp(nums.size());
        return MergeSort(nums, temp, 0, nums.size() - 1);
    }

    int MergeSort(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; temp, int left, int right)
    {
        if (left &gt;= right)
        {
            return 0;
        }

        int mid = (left + right) / 2;

        int result = 0;

        result += MergeSort(nums, temp, left, mid);
        result += MergeSort(nums, temp, mid + 1, right);

        int temp_i = left;
        int i = left;
        int j = mid + 1;
        int begin_j = j;
        while (i &lt;= mid &amp;&amp; j &lt;= right)
        {
            if (nums[i] &lt;= nums[j])
            {
                temp[temp_i++] = nums[i];
                i++;
                result += (j - begin_j);

            }
            else
            {
                temp[temp_i++] = nums[j];
                j++;
            }
        }
        for (;i &lt;= mid; ++i)
        {
            temp[temp_i++] = nums[i];
            result += (j - begin_j);
        }
        for (; j &lt;= right; ++j)
        {
            temp[temp_i++] = nums[j];
        }
        std::copy(temp.begin() + left, temp.begin() + right + 1, nums.begin() + left);

        return result;
    }
};</code></pre>
<h3 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 52. 两个链表的第一个公共节点</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p>在节点 c1 开始相交。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。</code></pre><p><strong>注意：</strong></p>
<ul>
<li>如果两个链表没有交点，返回 <code>null</code>.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li>
<li>本题与主站 160 题相同：</li>
</ul>
<h4 id="Solution-相遇"><a href="#Solution-相遇" class="headerlink" title="Solution - 相遇"></a>Solution - 相遇</h4><pre><code class="c++">class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) 
    {
        if (!headA || !headB)
        {
            return nullptr;
        }
        ListNode* temp_a = headA;
        ListNode* temp_b = headB;

        while (temp_a-&gt;next || temp_b-&gt;next)
        {
            if (temp_a == temp_b)
            {
                return temp_a;
            }
            temp_a = temp_a-&gt;next ? temp_a-&gt;next : headB;

            temp_b = temp_b-&gt;next ? temp_b-&gt;next : headA; 
        }
        return temp_a == temp_b ? temp_a : nullptr;
    }
};</code></pre>
<p>这里踩了一个坑, 我开始是修改了next指针 首先题目不允许修改 其次修改之后会影响另一个指针的判断, 因为修改的这个node很可能是共享的node</p>
<pre><code class="c++">​class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) 
    {
        ListNode* temp_a = headA;
        ListNode* temp_b = headB;

        while (temp_a != temp_b)
        {
            temp_a = temp_a ? temp_a-&gt;next : headB;
            temp_b = temp_b ? temp_b-&gt;next : headA; 
        }
        return temp_a;
    }
};</code></pre>
<p>退出条件优化了, 两种可能一种是二者相遇了 一种是二者都为空指针 这样代码能简化很多</p>
<h3 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [0,1,3]
输出: 2</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: [0,1,2,3,4,5,6,7,9]
输出: 8</code></pre><p><strong>限制：</strong></p>
<p><code>1 &lt;= 数组长度 &lt;= 10000</code></p>
<h4 id="Solution-二分法"><a href="#Solution-二分法" class="headerlink" title="Solution - 二分法"></a>Solution - 二分法</h4><pre><code class="c++">​class Solution {
public:
    int missingNumber(vector&lt;int&gt;&amp; nums)
    {
        if (nums[0] != 0)
        {
            return 0;
        }

        int ret = find(nums, 0, nums.size() - 1);
        if (ret == -1)
        {
            return nums[nums.size() - 1] + 1;
        }
        return ret;
    }

    int find(vector&lt;int&gt;&amp; nums, int left, int right)
    {
        if (left &gt;= right)
        {
            return -1;
        }

        int mid = (left + right) / 2;
        if (mid + 1 &lt;= right &amp;&amp; nums[mid] == nums[mid + 1] - 2)
        {
            return nums[mid] + 1;
        }
        else if (mid - 1 &gt;= left &amp;&amp; nums[mid] == nums[mid - 1] + 2)
        {
            return nums[mid] - 1;
        }
        else
        {
            int ret = find(nums, left, mid - 1);
            if (ret == -1)
            {
                ret = find(nums, mid + 1, right);
            }
            return ret;
        }
    }
};</code></pre>
<p>没错写了这么长的二分….  第一印象没有想到迭代版本 如何收缩区间. 索性就两侧都搜索. 实际看了题解才发现</p>
<p>漏掉了一个条件, 当<code>num[i] &gt; i</code>的时候就说明了缺失的数字在左边 反过来就是在右边</p>
<pre><code class="c++">class Solution {
public:
    int missingNumber(vector&lt;int&gt;&amp; nums)
    {
        int left = 0;
        int right = nums.size() - 1;

        while (left &lt;= right)
        {
            int mid = (left + right) / 2;
            if (nums[mid] &gt; mid)
            {
                right = mid - 1;
            }
            else if (nums[mid] == mid)
            {
                left = mid + 1;
            }
        }
        return left;
    }
};</code></pre>
<p>题解上面还多了一个判断点 循环结束的时候left位于右子数组的开始 right位于左子数组的结束</p>
<p>结果为右子数组开始元素的下标</p>
<pre><code class="c++">0 1 2 3 4 5

0 1 2 3 5 6 // 右子数组 56 左子数组 0 1 2 3  5对应的下标4位答案 </code></pre>
<h3 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 54. 二叉搜索树的第k大节点</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4</code></pre><p><strong>限制：</strong></p>
<p>1 ≤ k ≤ 二叉搜索树元素个数</p>
<h4 id="Solution-中序遍历得到递增序列"><a href="#Solution-中序遍历得到递增序列" class="headerlink" title="Solution - 中序遍历得到递增序列"></a>Solution - 中序遍历得到递增序列</h4><pre><code class="c++">​class Solution {
public:
    int kthLargest(TreeNode* root, int k)
    {
        vector&lt;int&gt; temp;
        dfs(root, k, temp);
        return temp[temp.size() - k];
    }

    void dfs(TreeNode* root, int k, vector&lt;int&gt;&amp; temp)
    {
        if (!root)
        {
            return 0;
        }
        dfs(root-&gt;left, k, temp);
        temp.push_back(root-&gt;val);
        dfs(root-&gt;right, k, temp);
    }
};</code></pre>
<h4 id="Solution-先右再左的中序遍历-得到的是递减序列"><a href="#Solution-先右再左的中序遍历-得到的是递减序列" class="headerlink" title="Solution - 先右再左的中序遍历 得到的是递减序列!!"></a>Solution - 先右再左的中序遍历 得到的是递减序列!!</h4><pre><code class="c++">class Solution {
public:
    int result;
    int kthLargest(TreeNode* root, int k)
    {
        dfs(root, k);
        return result;
    }

    void dfs(TreeNode* root, int&amp; k)
    {
        if (!root)
        {
            return;
        }
        dfs(root-&gt;right, k);
        if (k == 0)
        {
            return; // 提前返回这里也非常妙啊
        }
        if (--k == 0)
        {
            result = root-&gt;val;
        }
        dfs(root-&gt;left, k);
    }
};</code></pre>
<p>看到题解这句话直接惊呆我了<code>先右再左的中序遍历 得到的是递减序列</code></p>
<p>还有提前返回的判断</p>
<h3 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - I. 二叉树的深度</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre><p>返回它的最大深度 3 。</p>
<p><strong>提示：</strong></p>
<ol>
<li><code>节点总数 &lt;= 10000</code></li>
</ol>
<p>注意：本题与主站 104 题相同：</p>
<h4 id="Solution-bfs-nullptr"><a href="#Solution-bfs-nullptr" class="headerlink" title="Solution - bfs + nullptr"></a>Solution - bfs + nullptr</h4><pre><code class="c++">​class Solution {
public:
    int maxDepth(TreeNode* root)
    {
        if (!root)
        {
            return 0;
        }

        deque&lt;TreeNode*&gt; nodes;
        nodes.push_back(root);
        nodes.push_back(nullptr);
        int result = 0;

        while (!nodes.empty())
        {
            TreeNode* node = nodes.front();
            nodes.pop_front();

            if (node == nullptr)
            {
                if (!nodes.empty())
                {
                    nodes.push_back(nullptr);
                }
                result++;
                continue;
            }
            if (node-&gt;left)
            {
                nodes.push_back(node-&gt;left);
            }
            if (node-&gt;right)
            {
                nodes.push_back(node-&gt;right);
            }
        }
        return result;
    }
};</code></pre>
<p>第一印象还是使用了nullptr作为层之间的区分, 前面做过类似的第一印象也是nullptr实际上应该用</p>
<p>for循环更加好 提前取出循环次数, 这样就算更改deque的size也不影响循环次数了</p>
<pre><code class="c++">class Solution {
public:
    int maxDepth(TreeNode* root)
    {
        if (!root)
        {
            return 0;
        }

        deque&lt;TreeNode*&gt; nodes;
        nodes.push_back(root);
        int result = 0;

        while (!nodes.empty())
        {
            result++;
            const int SS = nodes.size();
            for (int i = 0; i &lt; SS; ++i)
            {
                TreeNode* node = nodes.front();
                nodes.pop_front();
                if (node-&gt;left)
                {
                    nodes.push_back(node-&gt;left);
                }
                if (node-&gt;right)
                {
                    nodes.push_back(node-&gt;right);
                }
            }
        }
        return result;
    }
};</code></pre>
<h4 id="dfs-第一个想出来的竟然不是这个…"><a href="#dfs-第一个想出来的竟然不是这个…" class="headerlink" title="dfs 第一个想出来的竟然不是这个…"></a>dfs 第一个想出来的竟然不是这个…</h4><pre><code class="c++">class Solution {
public:
    int maxDepth(TreeNode* root)
    {
        if (!root)
        {
            return 0;
        }
        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;
    }
};</code></pre>
<h3 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - II. 平衡二叉树</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p><strong>示例 1:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre><p>返回 <code>true</code> 。  </p>
<p><strong>示例 2:</strong></p>
<p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>
<pre><code>       1
      / \
     2   2
    / \
   3   3
  / \
 4   4</code></pre><p>返回 <code>false</code> 。</p>
<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= 树的结点个数 &lt;= 10000</code></li>
</ul>
<p>注意：本题与主站 110 题相同：</p>
<h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:
    bool isBalanced(TreeNode* root)
    {
        return depth(root) != -1;
    }

    int depth(TreeNode* node)
    {
        if (!node)
        {
            return 0;
        }
        int left = depth(node-&gt;left);
        if (left == -1)
        {
            return -1;
        }

        int right = depth(node-&gt;right);
        if (right == -1)
        {
            return -1;
        }
        if (abs(left - right) &gt; 1)
        {
            return -1;
        }
        return max(left, right) + 1;
    }
};</code></pre>
<h3 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - I. 数组中数字出现的次数</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]</code></pre><p><strong>限制：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 10000</code></li>
</ul>
<h4 id="Solution-xor-以及xor分组"><a href="#Solution-xor-以及xor分组" class="headerlink" title="Solution - xor 以及xor分组"></a>Solution - xor 以及xor分组</h4><pre><code class="c++">​class Solution {
public:
    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums)
    {
        int xor_result = 0;
        for (int num : nums)
        {
            xor_result ^= num;
        }

        int bit_1 = 1;
        while ((xor_result &amp; 1) == 0)
        {
            xor_result = xor_result &gt;&gt; 1;
            bit_1++;
        }

        int xor_1 = 0;
        int xor_2 = 0;
        bit_1--;
        for (int num : nums)
        {
            int bit_1_temp = (num &gt;&gt; bit_1) &amp; 1;

            if (bit_1_temp == 1)
            {
                xor_1 ^= num;
            }
            else
            {
                xor_2 ^= num;
            }
        }
        return {xor_1, xor_2};
    }
};</code></pre>
<p>第一印象看到这个题目想到了用xor运算, 然而却没有想到如何将两个不同的数字分开.</p>
<p>看了题解发现 第一次xor出来的<code>xor_result</code> 如果是<code>11101</code>则说明两个不同的数字的右数第一位不同. 这样通过</p>
<p>其他数字的最后一位是1还是0就能分成两个数组 然后分别xor</p>
<pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums)
    {
        int xor_result = 0;
        for (int num : nums)
        {
            xor_result ^= num;
        }

        int bit_1 = 1;
        while ((xor_result &amp; bit_1) == 0)
        {
            bit_1 = bit_1 &lt;&lt; 1; // 通过逻辑左移取位
        }

        int xor_1 = 0;
        int xor_2 = 0;
        for (int num : nums)
        {
            if (num &amp; bit_1) // 这里也变了
            {
                xor_1 ^= num;
            }
            else
            {
                xor_2 ^= num;
            }
        }
        return {xor_1, xor_2};
    }
};</code></pre>
<h3 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [3,4,3,3]
输出：4</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [9,1,7,9,7,9,7]
输出：1</code></pre><p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10000</code></li>
<li><code>1 &lt;= nums[i] &lt; 2^31</code></li>
</ul>
<h4 id="Solution-二进制位出现次数-3"><a href="#Solution-二进制位出现次数-3" class="headerlink" title="Solution - 二进制位出现次数 % 3"></a>Solution - 二进制位出现次数 % 3</h4><pre><code class="c++">​class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums)
    {
        int bits[32]{};

        for (int num : nums)
        {
            int index = 0;
            while (num != 0)
            {
                bits[index] += num &amp; 1;
                num = num &gt;&gt; 1;
                index++;
            }
        }

        int result = 0;
        for (int i = 0; i &lt; 32; ++i)
        {
            result = result &lt;&lt; 1;
            result |= bits[31 - i] % 3;
        }
        return result;
    }
};</code></pre>
<h4 id="Solution-状态机"><a href="#Solution-状态机" class="headerlink" title="Solution - 状态机"></a>Solution - 状态机</h4><h3 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 57. 和为s的两个数字</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]</code></pre><p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^6</code></li>
</ul>
<h4 id="Solution-双指针-O-n-O-1"><a href="#Solution-双指针-O-n-O-1" class="headerlink" title="Solution - 双指针 O(n) O(1)"></a>Solution - 双指针 O(n) O(1)</h4><pre><code class="c++">​class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) 
    {
        int le = 0;
        int ri = nums.size() - 1;

        while (le &lt; ri)
        {
            int sum = nums[le] + nums[ri];
            if (sum == target)
            {
                return {nums[le], nums[ri]};
            }
            else if (sum &gt; target)
            {
                ri--;
            }
            else
            {
                le++;
            }
        }
        return {0, 0};
    }
};</code></pre>
<h4 id="Solution-如果题目是无序数组-用Hash表-O-n-O-n"><a href="#Solution-如果题目是无序数组-用Hash表-O-n-O-n" class="headerlink" title="Solution - 如果题目是无序数组 用Hash表 O(n) O(n)"></a>Solution - 如果题目是无序数组 用Hash表 O(n) O(n)</h4><pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) 
    {
        unordered_set&lt;int&gt; set;

        for (int num : nums)
        {
            int need = target - num;

            auto iter = set.find(need);
            if (iter == set.end())
            {
                set.insert(num);
            }
            else
            {
                return {num, *iter};
            }
        }
        return {0, 0};
    }
};</code></pre>
<h3 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 57 - II. 和为s的连续正数序列</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：target = 9
输出：[[2,3,4],[4,5]]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]</code></pre><p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 10^5</code></li>
</ul>
<h4 id="Solution-滑动窗口"><a href="#Solution-滑动窗口" class="headerlink" title="Solution - 滑动窗口"></a>Solution - 滑动窗口</h4><pre><code class="c++">​class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) 
    {
        vector&lt;vector&lt;int&gt;&gt; result;
        int begin = 1;
        int end = 2;
        int sum = 3;

        while (end &lt; target &amp;&amp; begin != end)
        {
            if (sum == target)
            {
                result.emplace_back();
                vector&lt;int&gt;&amp; vec = result.back();
                vec.reserve(end - begin + 1);
                for (int i = begin; i &lt;= end; ++i)
                {
                    vec.push_back(i);
                }
                end++;
                sum += end;
            }
            else if (sum &lt; target)
            {
                end++;
                sum += end;
            }
            else
            {
                sum -= begin;
                begin++;
            }
        }
        return result;
    }
};</code></pre>
<h3 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">剑指 Offer 58 - I. 翻转单词顺序</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入: &quot;the sky is blue&quot;
输出: &quot;blue is sky the&quot;</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入: &quot;  hello world!  &quot;
输出: &quot;world! hello&quot;
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入: &quot;a good   example&quot;
输出: &quot;example good a&quot;
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</code></pre><p><strong>说明：</strong></p>
<ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<p><strong>注意：</strong>本题与主站 151 题相同：</p>
<p><strong>注意：</strong>此题对比原题有改动</p>
<h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:
    string reverseWords(string s)
    {
        if (s.empty())
        {
            return &quot;&quot;;
        }

        int begin = 0;
        int end = s.size();
        while (begin &lt; s.size() &amp;&amp; s[begin] == &#39; &#39;)
        {
            begin++;
        }
        while (end &gt;= 1 &amp;&amp; s[end - 1] == &#39; &#39;)
        {
            end--;
        }
        if (begin &gt;= end)
        {
            return &quot;&quot;;
        }
        reverse(s.begin() + begin, s.begin() + end);

        int word_begin = begin;
        for (int i = begin; i &lt; end; ++i)
        {
            if (s[i] == &#39; &#39;)
            {
                int word_end = i;
                reverse(s.begin() + word_begin, s.begin() + word_end);
                word_begin = i + 1;
            }
        }
        reverse(s.begin() + word_begin, s.begin() + end);

        string result;
        result.reserve(end - begin);
        for (int i = begin; i &lt; end; ++i)
        {
            if (s[i] == &#39; &#39;)
            {
                if (result[result.size() - 1] != &#39; &#39;)
                {
                    result.append(1, &#39; &#39;);
                }
            }
            else
            {
                result.append(1, s[i]);
            }
        }
        return result;
    }
};</code></pre>
<p>我用的解法是先翻转整个字符串 然后再把单词翻转过来 这样组成结果</p>
<p>实际上可以直接从尾部遍历, 然后一个单词一个单词的拼接出结果</p>
<pre><code class="c++">class Solution {
public:
    string reverseWords(string s)
    {
        int begin = 0;
        int end = s.size();
        while (begin &lt; s.size() &amp;&amp; s[begin] == &#39; &#39;)
        {
            begin++;
        }
        while (end &gt;= 1 &amp;&amp; s[end - 1] == &#39; &#39;)
        {
            end--;
        }
        if (begin &gt;= end)
        {
            return &quot;&quot;;
        }
        string result;
        result.reserve(end - begin);

        int i = end - 1;
        int j = end;
        while (i &gt;= begin)
        {
            while (i &gt;= begin &amp;&amp; s[i] != &#39; &#39;)
            {
                i--;
            }
            result.append(s.begin() + i + 1, s.begin() + j);
            result.append(1, &#39; &#39;); // 注意这里 第一个参数数量 第二个是字符 反过来也能运行 但是结果出错
            while (i &gt;= begin &amp;&amp; s[i] == &#39; &#39;)
            {
                i--;
            }
            j = i + 1;
        }
        return result.substr(0, result.size() - 1);
    }
};</code></pre>
<h3 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7</code></pre><p><strong>提示：</strong></p>
<p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<p>注意：本题与主站 239 题相同：</p>
<h4 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k)
    {
        if (nums.empty())
        {
            return {};
        }
        vector&lt;int&gt; result;
        result.reserve(nums.size() - k + 1);

        int temp_i = 0;
        for (int i = 1; i &lt; k; ++i)
        {
            if (nums[i] &gt; nums[temp_i])
            {
                temp_i = i;
            }
        }
        result.push_back(nums[temp_i]);

        int left = 1;
        int right = k;
        while (right &lt; nums.size())
        {
            if (left &gt; temp_i)
            {
                temp_i = left;
                for (int j = left + 1; j &lt;= right; ++j)
                {
                    if (nums[j] &gt; nums[temp_i])
                    {
                        temp_i = j;
                    }
                }
            }
            else
            {
                if (nums[right] &gt; nums[temp_i])
                {
                    temp_i = right;
                }
            }
            result.push_back(nums[temp_i]);
            left++;
            right++;
        }
        return result;
    }
};</code></pre>
<p>实际不用在将最大元素移出时进行遍历,  可以采用如下方式, 添加一个deque来解决. 这样能保证获取最大元素为O(1)</p>
<pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k)
    {
        if (nums.empty())
        {
            return {};
        }
        vector&lt;int&gt; result;
        result.reserve(nums.size() - k + 1);

        deque&lt;int&gt; window;
        for (int i = 0; i &lt; k; ++i)
        {
            while (!window.empty() &amp;&amp; nums[window.back()] &lt; nums[i])
            {
                window.pop_back();
            }
            window.push_back(i);
        }
        result.push_back(nums[window.front()]);

        for (int i = k; i &lt; nums.size(); ++i)
        {
            if (i - k + 1 &gt; window.front()) // 移除已经滑动出去的值
            {
                window.pop_front();
            }

            while (!window.empty() &amp;&amp; nums[window.back()] &lt; nums[i]) // 每次添加元素前将小于其的元素移除 保证队列内有序
            {
                window.pop_back();
            }
            window.push_back(i);
            result.push_back(nums[window.front()]);
        }
        return result;
    }
};</code></pre>
<h3 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - II. 队列的最大值</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是O(1)。</p>
<p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入: 
[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入: 
[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]
[[],[],[]]
输出: [null,-1,-1]</code></pre><p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li>
<li><code>1 &lt;= value &lt;= 10^5</code></li>
</ul>
<h4 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h4><p>鉴于上一题所以这一题一开始就想的这种方法, 结果有个地方开始没转过来</p>
<p>如果压入123 那么maxs里面只会保留3 不管是否pop_front掉1和2 最大值只会是3, pop_front掉于最大值前面压入的数不会影响最大值</p>
<pre><code class="c++">​class MaxQueue {
public:
    MaxQueue()
    {

    }

    int max_value()
    {
        return maxs.empty() ? -1 : maxs.front();
    }

    void push_back(int value)
    {
        nums.push(value);

        while (!maxs.empty() &amp;&amp; maxs.back() &lt; value)
        {
            maxs.pop_back();
        }
        maxs.push_back(value);
    }

    int pop_front()
    {
        if (nums.empty())
        {
            return -1;
        }
        int ret = nums.front();
        nums.pop();
        if (maxs.front() == ret)
        {
            maxs.pop_front();
        }

        return ret;
    }

    queue&lt;int&gt; nums;
    deque&lt;int&gt; maxs;
};</code></pre>
<h3 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 60. n个骰子的点数</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</code></pre><p><strong>限制：</strong></p>
<p><code>1 &lt;= n &lt;= 11</code></p>
<h4 id="Solution-暴力法-1"><a href="#Solution-暴力法-1" class="headerlink" title="Solution - 暴力法"></a>Solution - 暴力法</h4><pre><code class="c++">​class Solution {
public:

    vector&lt;int&gt; counter;

    int n_back;

    void dfs(int n, int sum)
    {
        if (n == 0)
        {
            counter[sum - n_back]++;
            return;
        }
        for (int i = 1; i &lt;= 6; ++i)
        {
            dfs(n - 1, sum + i);
        }
    }

    vector&lt;double&gt; dicesProbability(int n) 
    {
        n_back = n;
        counter.resize(n * 6 - n + 1);
        dfs(n, 0);

        double sum_count = pow(6, n);
        vector&lt;double&gt; result;
        result.resize(n *  6 - n + 1);
        for (int i = 0; i &lt; n * 6 - n + 1; ++i)
        {
            result[i] = counter[i] / sum_count;
        }
        return result;
    }
};</code></pre>
<p>每个骰子都可能是1-6 将骰子掷完就能得到结果</p>
<h4 id="Solution-动态规划"><a href="#Solution-动态规划" class="headerlink" title="Solution - 动态规划"></a>Solution - 动态规划</h4><pre><code class="c++">​class Solution {
public:

    vector&lt;double&gt; dicesProbability(int n) 
    {
        vector&lt;int&gt; vec1(n * 6 + 1, 0);
        vector&lt;int&gt; vec2(n * 6 + 1, 0);

        for (int i = 1; i &lt;= 6; ++i) // n == 1时 是 1 1 1 1 1 1
        {
            vec1[i] = 1;
        }

        for (int i = 2; i &lt;= n; ++i)
        {
            for (int j = 0; j &lt; i; ++j)
            {
                vec2[j] = 0;
            }

            for (int j = i; j &lt;= i * 6; ++j)
            {
                vec2[j] = 0;
                for (int k = 1; j &gt;= k &amp;&amp; k &lt;= 6; ++k)
                {
                    vec2[j] += vec1[j - k];
                }
            }
            vec1.swap(vec2);
        }

        double sum = pow(6, n);
        vector&lt;double&gt; ret;
        ret.reserve(n * 6 - n + 1);
        for (int i = n; i &lt;= n * 6; ++i)
        {
            ret.push_back(vec1[i] / sum);
        }
        return ret;
    }
};</code></pre>
<p>当投掷n个骰子的时候出现总和为m  那么 <code>x[n][m] = x[n-1][m-1] + x[n-1][m-2] + x[n-1][m-3] + x[n-1][m-4] + x[n-1][m-5] + x[n-1][m-6]</code></p>
<p>这样每计算n个骰子的时候只需要第n-1轮的结果 可以使用两个数组, 计算完第n轮后将这个数组swap到”上一轮数组”用于计算n+1轮</p>
<h3 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 61. 扑克牌中的顺子</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [1,2,3,4,5]
输出: True</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: [0,0,1,2,5]
输出: True</code></pre><p><strong>限制：</strong></p>
<p>数组长度为 5 </p>
<p>数组的数取值为 [0, 13] .</p>
<h4 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:
    bool isStraight(vector&lt;int&gt;&amp; nums)
    {
        vector&lt;int&gt; vec(13, 0);
        int left_sub = vec.size();
        int zero_count = 0;
        for (int num : nums)
        {
            if (num == 0)
            {
                zero_count++; // 统计0的数量
            }
            else if (vec[num - 1] == 0)
            {
                vec[num - 1] = 1; // 标记出现的非0卡牌
                left_sub = min(left_sub, num - 1); // 更新第一张非0卡牌的开始位置
            }
            else
            {
                return false; // 存在重复的卡牌
            }
        }

        int right_sub = left_sub;
        while (right_sub &lt; vec.size() &amp;&amp; (vec[right_sub] == 1 || zero_count &gt; 0))
        {
            if (vec[right_sub] == 0) // 为0表示没有这张卡 需要消耗一张0来补齐
            {
                zero_count--;
            }
            right_sub++;
        }

        return right_sub - left_sub + zero_count == nums.size(); // 输入数据的长度 = 顺子的长度(含补齐) + 剩余下的0
    }
};</code></pre>
<h3 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">剑指 Offer 63. 股票的最大利润</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>限制：</strong></p>
<p><code>0 &lt;= 数组长度 &lt;= 10^5</code></p>
<p><strong>注意：</strong>本题与主站 121 题相同：</p>
<h4 id="Solution-动态规划-1"><a href="#Solution-动态规划-1" class="headerlink" title="Solution - 动态规划"></a>Solution - 动态规划</h4><pre><code class="c++">​class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices)
    {
        int buy_price = INT_MAX;
        int ans = 0;

        for (int curr_price : prices)
        {
            if (curr_price &gt; buy_price)
            {
                // try sell
                ans = max(ans, curr_price - buy_price); // 当前价格大于卖出价格尝试卖出
            }
            else if (curr_price &lt; buy_price)
            {
                // buy this
                buy_price = curr_price; // 当前价格小于买入价格 尝试改为当前价格买入
            }
        }
        return ans;
    }
};</code></pre>
<h3 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">剑指 Offer 64. 求1+2+…+n</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入: n = 3
输出: 6</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入: n = 9
输出: 45</code></pre><p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10000</code></li>
</ul>
<h4 id="Solution-sizeof代替乘法-短路运算控制返回"><a href="#Solution-sizeof代替乘法-短路运算控制返回" class="headerlink" title="Solution - sizeof代替乘法 + 短路运算控制返回"></a>Solution - sizeof代替乘法 + 短路运算控制返回</h4><pre><code class="c++">​class Solution {
public:
    // int sumNums(int n)
    // {
    //     char a[n][n + 1];
    //     return (sizeof a) &gt;&gt; 1;
    // }

    int sumNums(int n)
    {
        n &gt; 1 &amp;&amp; (n += sumNums(n - 1)); // 短路运算右边对n进行赋值
        return n;
    }
};</code></pre>
<h3 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">剑指 Offer 65. 不用加减乘除做加法</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: a = 1, b = 1
输出: 2</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>a</code>, <code>b</code> 均可能是负数或 0</li>
<li>结果不会溢出 32 位整数</li>
</ul>
<h4 id="Solution-a-b-x-进位信息-使用-amp-lt-lt-1-y-本位信息-使用-xor"><a href="#Solution-a-b-x-进位信息-使用-amp-lt-lt-1-y-本位信息-使用-xor" class="headerlink" title="Solution a + b = x(进位信息 使用 &amp; &lt;&lt; 1) + y(本位信息 使用 xor)"></a>Solution a + b = x(进位信息 使用 &amp; &lt;&lt; 1) + y(本位信息 使用 xor)</h4><pre><code class="c++">​class Solution {
public:
    int add(int a, int b)
    {
        while (b != 0)
        {
            int c = (a &amp; b) &lt;&lt; 1; // 进位信息  1 + 1 = 10 由于1&amp;1=1所以需要 &lt;&lt;
            a ^= b; // 本位信息 0 + 0 = 0  1 + 0 = 1 0 + 1 = 0 1 + 1 = 0
            b = c; // a + b = x1(进位) + y1(本位) = x2(进位) + y2(本位) .... + 到进位为0 这样就是结果了 0 + x = x;
        } // 已知a+b = 进位+本位 而进位+本位也是两个数字相加 所以可以连续调用公式 直到进位为0 本位就是结果
        return a;
    }
};</code></pre>
<h3 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt=""></p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<p>注意：本题与主站 235 题相同：</p>
<h4 id="Solution-读题-利用好每一个条件"><a href="#Solution-读题-利用好每一个条件" class="headerlink" title="Solution - 读题 利用好每一个条件"></a>Solution - 读题 利用好每一个条件</h4><pre><code class="c++">​/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)
    {
        if (!root)
        {
            return nullptr;
        }
        if (p-&gt;val &gt; q-&gt;val)
        {
            swap(p, q);
        }
        while (true)
        {
            if (root-&gt;val &lt; p-&gt;val)
            {
                root = root-&gt;right;
            }
            else if (root-&gt;val &gt; q-&gt;val)
            {
                root = root-&gt;left;
            }
            else
            {
                break;
            }
        }
        return root;
    }
};</code></pre>
<p>我第一次写这个题目没有用上二叉搜索树这个条件, 把下一个题目二叉树给写出来了….</p>
<p>没利用好题目, 没读好题 我有罪</p>
<p>这个题目利用的是二叉搜索树 如果两个数都小于根节点 则位于根节点的左子树 两个都大于则位于根节点的右子树</p>
<p>如果一个大于一个小于说明位于左右子树则当前节点即为答案. 通过保证p的值小于q可以简化以上的判断.  如果最小的p都大于根节点则较大的q也一定大于</p>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2023 lsmg
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
