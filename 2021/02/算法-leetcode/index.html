<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>leetcode | Lsmg的大学之路</title>
  <meta name="keywords" content="">
  <meta name="description" content="leetcode | Lsmg的大学之路">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="背景项目使用Unity开发，使用过程中可以明显内存有异常增长，所以排查了一下原因，做一下记录。 分三步描述  寻找异常内存分配时的地址 寻找异常内存分配的堆栈 寻找对应的项目代码  寻找异常内存分配时的地址后台用的工具使用massif可以详细打印内存分配时的堆栈信息，但是没有Windows版本，询问GPT后得到了下面几个工具。  Unity自带的Profile vs2022 vmmap64  工具">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows下Unity内存泄露排查">
<meta property="og:url" content="http://blog.lsmg.xyz/2024/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-Windows%E4%B8%8BUnity%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%8E%92%E6%9F%A5/index.html">
<meta property="og:site_name" content="Lsmg的大学之路">
<meta property="og:description" content="背景项目使用Unity开发，使用过程中可以明显内存有异常增长，所以排查了一下原因，做一下记录。 分三步描述  寻找异常内存分配时的地址 寻找异常内存分配的堆栈 寻找对应的项目代码  寻找异常内存分配时的地址后台用的工具使用massif可以详细打印内存分配时的堆栈信息，但是没有Windows版本，询问GPT后得到了下面几个工具。  Unity自带的Profile vs2022 vmmap64  工具">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-11-14T19:48:22.000Z">
<meta property="article:modified_time" content="2025-02-27T06:39:40.173Z">
<meta property="article:author" content="Lsmg">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Lsmg的大学之路" type="application/atom+xml">
</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Lsmg</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:jaytp@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=872336115&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(87)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="CPP">
                        <i class="fold iconfont icon-right"></i>
                        
                        CPP
                        <small>(14)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="CPP<--->源码学习">
                                        
                                        源码学习
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="Linux">
                        
                        Linux
                        <small>(9)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="UE5">
                        
                        UE5
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="个人记录">
                        
                        个人记录
                        <small>(8)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="优化">
                        
                        优化
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="分享会">
                        
                        分享会
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="学习记录">
                        
                        学习记录
                        <small>(11)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="工具使用">
                        <i class="fold iconfont icon-right"></i>
                        
                        工具使用
                        <small>(2)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="工具使用<--->Git操作">
                                        
                                        Git操作
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="日语">
                        
                        日语
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="模块设计">
                        
                        模块设计
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="算法">
                        
                        算法
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="网络编程">
                        
                        网络编程
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="计算机网络">
                        
                        计算机网络
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="读书记录">
                        
                        读书记录
                        <small>(20)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="采坑记">
                        
                        采坑记
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="项目制作">
                        
                        项目制作
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="87">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ebpf</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>GDB调试</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Git操作</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HTTPS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Linux</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Shell</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spf-13</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>UP</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>常用命令</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>方向选择</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>时间触发器</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>编译加速</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>采坑记</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a id="top" class="All 日语 "
           href="/2023/03/%E6%97%A5%E8%AF%AD-GPT%E7%AD%94%E7%96%91%E8%AE%B0%E5%BD%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GPT答疑记录">GPT答疑记录</span>
            <span class="post-date" title="2023-03-26 10:37:20">2023/03/26</span>
        </a>
        
        
        <a id="top" class="All 日语 "
           href="/2023/03/%E6%97%A5%E8%AF%AD-%E4%BA%94%E5%A4%A7%E6%80%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="五大态">五大态</span>
            <span class="post-date" title="2023-03-26 10:37:20">2023/03/26</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2023/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95180-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="性能之巅">性能之巅</span>
            <span class="post-date" title="2023-03-21 23:37:20">2023/03/21</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2022/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95170-%E6%88%91%E6%98%AF%E4%B8%80%E5%8F%AAIT%E5%B0%8F%E5%B0%8F%E9%B8%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="我是一只IT小小鸟">我是一只IT小小鸟</span>
            <span class="post-date" title="2022-05-30 19:09:20">2022/05/30</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2022/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95161-%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="现代C++教程">现代C++教程</span>
            <span class="post-date" title="2022-05-31 19:09:20">2022/05/31</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2021/04/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95160-TCPIP%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TCP/IP详解">TCP/IP详解</span>
            <span class="post-date" title="2021-04-03 19:09:20">2021/04/03</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2021/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95150-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux内核设计精髓">Linux内核设计精髓</span>
            <span class="post-date" title="2021-03-28 19:09:20">2021/03/28</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2021/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95140-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="程序员的自我修养">程序员的自我修养</span>
            <span class="post-date" title="2021-03-17 19:09:20">2021/03/17</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2020/09/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95135-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深度探索C++对象模型">深度探索C++对象模型</span>
            <span class="post-date" title="2020-09-15 15:17:39">2020/09/15</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2021/04/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95131-%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码整洁之道">代码整洁之道</span>
            <span class="post-date" title="2021-04-28 08:19:39">2021/04/28</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2020/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码大全">代码大全</span>
            <span class="post-date" title="2020-05-13 21:19:39">2020/05/13</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2022/02/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95120-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux多线程服务器端编程">Linux多线程服务器端编程</span>
            <span class="post-date" title="2022-02-15 17:19:39">2022/02/15</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2020/02/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95110-Effective%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="EffectiveCpp读书记录">EffectiveCpp读书记录</span>
            <span class="post-date" title="2020-02-26 21:43:46">2020/02/26</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2020/02/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95102-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux高性能服务器-进程线程">Linux高性能服务器-进程线程</span>
            <span class="post-date" title="2020-02-25 22:34:39">2020/02/25</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2019/08/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95101-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux高性能服务器-高级部分">Linux高性能服务器-高级部分</span>
            <span class="post-date" title="2019-08-18 20:34:39">2019/08/18</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2019/08/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95100-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux高性能服务器-初级部分">Linux高性能服务器-初级部分</span>
            <span class="post-date" title="2019-08-17 20:34:39">2019/08/17</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2020/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9599-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux高性能服务器-理论部分">Linux高性能服务器-理论部分</span>
            <span class="post-date" title="2020-03-06 22:53:00">2020/03/06</span>
        </a>
        
        
        <a id="top" class="All 算法 "
           href="/2021/02/%E7%AE%97%E6%B3%9590-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构和STL">数据结构和STL</span>
            <span class="post-date" title="2021-02-05 10:38:28">2021/02/05</span>
        </a>
        
        
        <a id="top" class="All 读书记录 "
           href="/2019/08/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9580-CPPPrimer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++Primer学习">C++Primer学习</span>
            <span class="post-date" title="2019-08-16 19:13:22">2019/08/16</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2024/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-Windows%E4%B8%8BUnity%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%8E%92%E6%9F%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Windows下Unity内存泄露排查">Windows下Unity内存泄露排查</span>
            <span class="post-date" title="2024-11-14 19:48:22">2024/11/14</span>
        </a>
        
        
        <a  class="All 优化 "
           href="/2024/11/%E4%BC%98%E5%8C%96-%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F2/"
           data-tag="编译加速"
           data-author="" >
            <span class="post-title" title="CMake项目常见的编译加速方式汇总">CMake项目常见的编译加速方式汇总</span>
            <span class="post-date" title="2024-11-13 14:48:22">2024/11/13</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2024/07/CPP-CMAKE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CMAKE&amp;Make">CMAKE&amp;Make</span>
            <span class="post-date" title="2024-07-02 17:07:45">2024/07/02</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2024/06/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E7%89%882/"
           data-tag="UP"
           data-author="" >
            <span class="post-title" title="如何更好的添砖加瓦2">如何更好的添砖加瓦2</span>
            <span class="post-date" title="2024-06-24 09:48:22">2024/06/24</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2024/04/Linux-massif/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="massif使用">massif使用</span>
            <span class="post-date" title="2024-04-13 16:31:22">2024/04/13</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2024/03/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E5%B8%B8%E4%BA%8BUP/"
           data-tag="UP"
           data-author="" >
            <span class="post-title" title="常事UP">常事UP</span>
            <span class="post-date" title="2024-03-23 14:48:22">2024/03/23</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2024/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%8E%92%E8%A1%8C%E6%A6%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="排行榜">排行榜</span>
            <span class="post-date" title="2024-01-25 14:38:08">2024/01/25</span>
        </a>
        
        
        <a  class="All 优化 "
           href="/2023/12/%E4%BC%98%E5%8C%96-%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F/"
           data-tag="编译加速"
           data-author="" >
            <span class="post-title" title="编译加速">编译加速</span>
            <span class="post-date" title="2023-12-13 14:48:22">2023/12/13</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2023/12/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/"
           data-tag="方向选择"
           data-author="" >
            <span class="post-title" title="方向选择">方向选择</span>
            <span class="post-date" title="2023-12-11 19:48:22">2023/12/11</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2023/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E7%89%88/"
           data-tag="UP"
           data-author="" >
            <span class="post-title" title="如何更好的添砖加瓦">如何更好的添砖加瓦</span>
            <span class="post-date" title="2023-11-25 09:48:22">2023/11/25</span>
        </a>
        
        
        <a  class="All 项目制作 "
           href="/2023/11/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-PrometheusX%E7%81%AB%E7%84%B0%E5%9B%BE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何实现火焰图半自由">如何实现火焰图半自由</span>
            <span class="post-date" title="2023-11-18 12:50:02">2023/11/18</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2023/11/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%86%99%E5%8D%9A%E5%AE%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="写博客技巧">写博客技巧</span>
            <span class="post-date" title="2023-11-15 10:38:08">2023/11/15</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E6%9C%88%E8%AE%B0%E5%BD%95/"
           data-tag="UP"
           data-author="" >
            <span class="post-title" title="UP月记录">UP月记录</span>
            <span class="post-date" title="2023-10-27 09:48:22">2023/10/27</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2023/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="游戏设计">游戏设计</span>
            <span class="post-date" title="2023-10-24 10:38:08">2023/10/24</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2023/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="设计模式">设计模式</span>
            <span class="post-date" title="2023-10-20 18:38:08">2023/10/20</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"
           data-tag="常用命令"
           data-author="" >
            <span class="post-title" title="常用命令">常用命令</span>
            <span class="post-date" title="2023-10-16 09:48:22">2023/10/16</span>
        </a>
        
        
        <a  class="All 模块设计 "
           href="/2023/10/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1-%E6%97%B6%E9%97%B4%E8%A7%A6%E5%8F%91%E5%99%A8/"
           data-tag="时间触发器"
           data-author="" >
            <span class="post-title" title="时间触发器">时间触发器</span>
            <span class="post-date" title="2023-10-16 09:48:22">2023/10/16</span>
        </a>
        
        
        <a  class="All 个人记录 "
           href="/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP/"
           data-tag="UP"
           data-author="" >
            <span class="post-title" title="个人UP">个人UP</span>
            <span class="post-date" title="2023-10-16 09:48:22">2023/10/16</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2023/10/Linux-ebpf/"
           data-tag="ebpf"
           data-author="" >
            <span class="post-title" title="bpf">bpf</span>
            <span class="post-date" title="2023-10-11 17:00:22">2023/10/11</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%9E%B6%E6%9E%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="架构">架构</span>
            <span class="post-date" title="2023-04-17 10:38:08">2023/04/17</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-Wireshark%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Wireshark插件开发">Wireshark插件开发</span>
            <span class="post-date" title="2023-04-11 19:00:00">2023/04/11</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E9%80%9A%E8%AF%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="通识">通识</span>
            <span class="post-date" title="2023-04-07 10:38:08">2023/04/07</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%B8%A7%E5%90%8C%E6%AD%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="帧同步">帧同步</span>
            <span class="post-date" title="2022-05-27 10:38:08">2022/05/27</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-SDL2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SDL学习">SDL学习</span>
            <span class="post-date" title="2022-05-25 10:38:08">2022/05/25</span>
        </a>
        
        
        <a  class="All UE5 "
           href="/2022/05/UE5-%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UE5学习">UE5学习</span>
            <span class="post-date" title="2022-05-12 20:31:22">2022/05/12</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2022/05/CPP-%E5%8D%8F%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="协程">协程</span>
            <span class="post-date" title="2022-05-07 10:38:08">2022/05/07</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-asio%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="asio官方文档笔记">asio官方文档笔记</span>
            <span class="post-date" title="2022-05-04 10:38:08">2022/05/04</span>
        </a>
        
        
        <a  class="All 学习记录 "
           href="/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-6.s081/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="6.s081学习 &amp;&amp; tmux">6.s081学习 &amp;&amp; tmux</span>
            <span class="post-date" title="2022-05-04 10:38:08">2022/05/04</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2021/07/CPP-alias/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=".*_case">.*_case</span>
            <span class="post-date" title="2021-07-14 21:27:27">2021/07/14</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2021/05/CPP-ModernCpp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ModernCpp.md">ModernCpp.md</span>
            <span class="post-date" title="2021-05-25 23:27:27">2021/05/25</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2021/05/Linux-sed&awk&grep/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="sed&amp;awk&amp;grep">sed&amp;awk&amp;grep</span>
            <span class="post-date" title="2021-05-07 08:11:22">2021/05/07</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2021/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTPS/"
           data-tag="HTTPS"
           data-author="" >
            <span class="post-title" title="HTTPS的基本流程和原理">HTTPS的基本流程和原理</span>
            <span class="post-date" title="2021-03-01 16:50:22">2021/03/01</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2021/02/CPP-class%20struct%20typename/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="class struct typename">class struct typename</span>
            <span class="post-date" title="2021-02-24 10:54:08">2021/02/24</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2021/02/%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="剑指Offer">剑指Offer</span>
            <span class="post-date" title="2021-02-10 00:08:28">2021/02/10</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2021/02/CPP-stdany,%20How%20when%20and%20why/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="void*|function|any|optional|variant, How when and why">void*|function|any|optional|variant, How when and why</span>
            <span class="post-date" title="2021-02-06 18:56:27">2021/02/06</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2021/02/%E7%AE%97%E6%B3%95-leetcode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="leetcode">leetcode</span>
            <span class="post-date" title="2021-02-05 12:10:02">2021/02/05</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2021/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEURL%E5%88%B0%E6%98%BE%E7%A4%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="浏览器访问URL到显示">浏览器访问URL到显示</span>
            <span class="post-date" title="2021-02-01 16:55:22">2021/02/01</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2021/01/Linux-docker/"
           data-tag="docker"
           data-author="" >
            <span class="post-title" title="Docker使用">Docker使用</span>
            <span class="post-date" title="2021-01-31 23:34:22">2021/01/31</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2021/01/CPP-cast/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=".*_case">.*_case</span>
            <span class="post-date" title="2021-01-14 21:27:27">2021/01/14</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2021/01/Linux-%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux-调试常用命令">Linux-调试常用命令</span>
            <span class="post-date" title="2021-01-09 18:53:22">2021/01/09</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2021/01/CPP-pthread&thread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="pthread&amp;thread">pthread&amp;thread</span>
            <span class="post-date" title="2021-01-03 11:27:27">2021/01/03</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2021/01/Linux-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"
           data-tag="Shell"
           data-author="" >
            <span class="post-title" title="Shell脚本编写">Shell脚本编写</span>
            <span class="post-date" title="2021-01-02 22:00:22">2021/01/02</span>
        </a>
        
        
        <a  class="All 项目制作 "
           href="/2020/12/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-%E7%9B%B4%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="直播服务器">直播服务器</span>
            <span class="post-date" title="2020-12-02 12:50:02">2020/12/02</span>
        </a>
        
        
        <a  class="All 采坑记 "
           href="/2020/11/%E9%87%87%E5%9D%91%E8%AE%B0-delete%20this/"
           data-tag="采坑记"
           data-author="" >
            <span class="post-title" title="由muduo tie引出的 delete this">由muduo tie引出的 delete this</span>
            <span class="post-date" title="2020-11-26 17:37:08">2020/11/26</span>
        </a>
        
        
        <a  class="All 分享会 "
           href="/2020/11/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-HTTP%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="HTTP框架底层原理实现">HTTP框架底层原理实现</span>
            <span class="post-date" title="2020-11-01 22:45:39">2020/11/01</span>
        </a>
        
        
        <a  class="All 分享会 "
           href="/2020/10/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%AE%BF%E8%88%8D%E7%94%B5%E8%84%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="远程连接宿舍电脑">远程连接宿舍电脑</span>
            <span class="post-date" title="2020-10-29 16:40:39">2020/10/29</span>
        </a>
        
        
        <a  class="All 读书记录 "
           href="/2020/10/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-UNP/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UNP记录">UNP记录</span>
            <span class="post-date" title="2020-10-06 12:17:39">2020/10/06</span>
        </a>
        
        
        <a  class="All 采坑记 "
           href="/2020/08/%E9%87%87%E5%9D%91%E8%AE%B0-EPOLLET%E4%B8%A2%E5%A4%B1%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6/"
           data-tag="采坑记"
           data-author="" >
            <span class="post-title" title="EPOLLET丢失新连接事件">EPOLLET丢失新连接事件</span>
            <span class="post-date" title="2020-08-03 23:03:08">2020/08/03</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2020/07/%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%9B%9B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="算法四">算法四</span>
            <span class="post-date" title="2020-07-17 15:51:28">2020/07/17</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2020/07/Linux-VIM/"
           data-tag="spf-13"
           data-author="" >
            <span class="post-title" title="VIM使用">VIM使用</span>
            <span class="post-date" title="2020-07-05 20:31:22">2020/07/05</span>
        </a>
        
        
        <a  class="All 读书记录 "
           href="/2020/06/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-csapp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="csapp笔记">csapp笔记</span>
            <span class="post-date" title="2020-06-07 09:09:20">2020/06/07</span>
        </a>
        
        
        <a  class="All 网络编程 "
           href="/2020/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-EPOLL%E6%9C%AC%E8%B4%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="EPOLL本质">EPOLL本质</span>
            <span class="post-date" title="2020-03-25 17:35:20">2020/03/25</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2020/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E7%8A%B6%E6%80%81%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TCP状态机">TCP状态机</span>
            <span class="post-date" title="2020-03-25 12:55:20">2020/03/25</span>
        </a>
        
        
        <a  class="All 网络编程 "
           href="/2020/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Send%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Send返回值引出的(非)阻塞IO">Send返回值引出的(非)阻塞IO</span>
            <span class="post-date" title="2020-03-20 11:14:20">2020/03/20</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2020/03/Linux-Linux%E4%BD%BF%E7%94%A8/"
           data-tag="Linux"
           data-author="" >
            <span class="post-title" title="Linux的使用">Linux的使用</span>
            <span class="post-date" title="2020-03-17 12:29:20">2020/03/17</span>
        </a>
        
        
        <a  class="All 读书记录 "
           href="/2020/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-UNP%E5%8D%B7%E4%BA%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UNP卷二读书记录">UNP卷二读书记录</span>
            <span class="post-date" title="2020-03-15 11:16:20">2020/03/15</span>
        </a>
        
        
        <a  class="All Linux "
           href="/2020/03/Linux-GDB%E8%B0%83%E8%AF%95/"
           data-tag="GDB调试"
           data-author="" >
            <span class="post-title" title="GDB调试">GDB调试</span>
            <span class="post-date" title="2020-03-14 15:09:20">2020/03/14</span>
        </a>
        
        
        <a  class="All 工具使用 Git操作 "
           href="/2020/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%8F%8Acommit%E8%A7%84%E8%8C%83/"
           data-tag="Git操作"
           data-author="" >
            <span class="post-title" title="分支管理和实际应用及commit规范">分支管理和实际应用及commit规范</span>
            <span class="post-date" title="2020-03-06 19:34:25">2020/03/06</span>
        </a>
        
        
        <a  class="All 采坑记 "
           href="/2020/03/%E9%87%87%E5%9D%91%E8%AE%B0-%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E4%B9%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B/"
           data-tag="采坑记"
           data-author="" >
            <span class="post-title" title="循环判断中使用无符号类型">循环判断中使用无符号类型</span>
            <span class="post-date" title="2020-03-06 17:37:08">2020/03/06</span>
        </a>
        
        
        <a  class="All CPP 源码学习 "
           href="/2020/03/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Jsoncpp%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jsoncpp代码阅读">Jsoncpp代码阅读</span>
            <span class="post-date" title="2020-03-01 10:26:55">2020/03/01</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2020/02/CPP-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E%E8%AF%A6%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="定义与声明详解">定义与声明详解</span>
            <span class="post-date" title="2020-02-27 10:38:08">2020/02/27</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2020/02/CPP-CPP%E6%96%B0%E7%89%B9%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CPP11及以后的常用特性">CPP11及以后的常用特性</span>
            <span class="post-date" title="2020-02-19 17:41:27">2020/02/19</span>
        </a>
        
        
        <a  class="All CPP 源码学习 "
           href="/2020/02/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Libevent%E4%BB%A3%E7%A0%81%E5%88%9D%E6%9C%9F%E4%BA%86%E8%A7%A3/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Libevent代码初期了解">Libevent代码初期了解</span>
            <span class="post-date" title="2020-02-19 14:56:55">2020/02/19</span>
        </a>
        
        
        <a  class="All 工具使用 Git操作 "
           href="/2020/02/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-Git-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git的基础使用">Git的基础使用</span>
            <span class="post-date" title="2020-02-07 18:24:42">2020/02/07</span>
        </a>
        
        
        <a  class="All 采坑记 "
           href="/2020/02/%E9%87%87%E5%9D%91%E8%AE%B0-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8/"
           data-tag="采坑记"
           data-author="" >
            <span class="post-title" title="头文件互相引用">头文件互相引用</span>
            <span class="post-date" title="2020-02-07 16:37:08">2020/02/07</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2020/02/CPP-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="字节对齐">字节对齐</span>
            <span class="post-date" title="2020-02-06 11:38:08">2020/02/06</span>
        </a>
        
        
        <a  class="All CPP "
           href="/2019/11/CPP-%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="指针">指针</span>
            <span class="post-date" title="2019-11-07 22:26:22">2019/11/07</span>
        </a>
        
        
        <a  class="All 读书记录 "
           href="/2019/10/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++薄书整理">C++薄书整理</span>
            <span class="post-date" title="2019-10-20 19:13:22">2019/10/20</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-算法-leetcode" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">leetcode</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="算法">算法</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2025-02-27 06:39:40'>2021-02-05 12:10</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#N3-无重复字符的最长子串"><span class="toc-text">N3.无重复字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1"><span class="toc-text">代码1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#样例代码"><span class="toc-text">样例代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#改进"><span class="toc-text">改进</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N34-在排序数组中查找元素的第一个和最后一个位置"><span class="toc-text">N34.在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-1"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剑指-Offer-53-I-在排序数组中查找数字-I"><span class="toc-text">剑指 Offer 53 - I. 在排序数组中查找数字 I</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-2"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#合并K个升序链表"><span class="toc-text">合并K个升序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-3"><span class="toc-text">代码1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码2"><span class="toc-text">代码2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#样例代码-1"><span class="toc-text">样例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长回文子串"><span class="toc-text">最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-中心扩散法"><span class="toc-text">代码1 - 中心扩散法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长公共子序列"><span class="toc-text">最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-4"><span class="toc-text">代码1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码2-动态规划"><span class="toc-text">代码2 动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E53-最大子序和"><span class="toc-text">E53.最大子序和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-5"><span class="toc-text">代码1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码2-1"><span class="toc-text">代码2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H51-amp-H52N皇后"><span class="toc-text">H51&amp;H52N皇后</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-6"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N55-跳跃游戏"><span class="toc-text">N55.跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-7"><span class="toc-text">代码1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码2-2"><span class="toc-text">代码2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#516-最长回文子序列"><span class="toc-text">516. 最长回文子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#整数反转"><span class="toc-text">整数反转</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-8"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#汉诺塔"><span class="toc-text">汉诺塔</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-9"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#整数转罗马数字"><span class="toc-text">整数转罗马数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-10"><span class="toc-text">代码1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码2-3"><span class="toc-text">代码2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#226-Invert-Binary-Tree"><span class="toc-text">226. Invert Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#116-填充每个节点的下一个右侧节点指针"><span class="toc-text">116. 填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114-二叉树展开为链表"><span class="toc-text">114. 二叉树展开为链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#450-删除二叉搜索树中的节点"><span class="toc-text">450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-11"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#701-二叉搜索树中的插入操作"><span class="toc-text">701. 二叉搜索树中的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-12"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#700-二叉搜索树中的搜索"><span class="toc-text">700. 二叉搜索树中的搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-13"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-验证二叉搜索树"><span class="toc-text">98. 验证二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-14"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-罗马数字转整数"><span class="toc-text">13. 罗马数字转整数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-15"><span class="toc-text">代码1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码2-样例"><span class="toc-text">代码2 - 样例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Z-字形变换"><span class="toc-text">6. Z 字形变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-16"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#654-最大二叉树"><span class="toc-text">654. 最大二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-17"><span class="toc-text">代码1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码2-4"><span class="toc-text">代码2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-电话号码的字母组合"><span class="toc-text">17. 电话号码的字母组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution1"><span class="toc-text">Solution1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-删除链表的倒数第N个节点"><span class="toc-text">19. 删除链表的倒数第N个节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution1-1"><span class="toc-text">Solution1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-合并两个有序链表"><span class="toc-text">21. 合并两个有序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution1-2"><span class="toc-text">Solution1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-两两交换链表中的节点"><span class="toc-text">24. 两两交换链表中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-18"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-删除排序数组中的重复项"><span class="toc-text">26. 删除排序数组中的重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-19"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105-从前序与中序遍历序列构造二叉树"><span class="toc-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-20"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#106-从中序与后序遍历序列构造二叉树"><span class="toc-text">106. 从中序与后序遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代码1-21"><span class="toc-text">代码1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#652-寻找重复的子树"><span class="toc-text">652. 寻找重复的子树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution1-3"><span class="toc-text">Solution1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-零钱兑换"><span class="toc-text">322. 零钱兑换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-dp自顶向下"><span class="toc-text">Solution - dp自顶向下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-编辑距离"><span class="toc-text">72. 编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-回溯"><span class="toc-text">Solution 回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-DP备忘录"><span class="toc-text">Solution DP备忘录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-DP-Table"><span class="toc-text">Solution DP Table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#354-俄罗斯套娃信封问题"><span class="toc-text">354. 俄罗斯套娃信封问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-1"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#300-最长递增子序列"><span class="toc-text">300. 最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-2"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#583-两个字符串的删除操作"><span class="toc-text">583. 两个字符串的删除操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-3"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#712-两个字符串的最小ASCII删除和"><span class="toc-text">712. 两个字符串的最小ASCII删除和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-4"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#103-二叉树的锯齿形层序遍历"><span class="toc-text">103. 二叉树的锯齿形层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-无reverse"><span class="toc-text">Solution - 无reverse</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-接雨水"><span class="toc-text">42. 接雨水</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-暴力法"><span class="toc-text">Solution - 暴力法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-动态规划-提前遍历出每个位置处的左边最高和右边最高"><span class="toc-text">Solution - 动态规划 提前遍历出每个位置处的左边最高和右边最高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-递减栈"><span class="toc-text">Solution - 递减栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-双指针"><span class="toc-text">Solution - 双指针</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="N3-无重复字符的最长子串"><a href="#N3-无重复字符的最长子串" class="headerlink" title="N3.无重复字符的最长子串"></a>N3.无重复字符的最长子串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<pre><code>输入: &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p>示例 2:</p>
<pre><code>输入: &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p>示例 3:</p>
<pre><code>输入: &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:
int lengthOfLongestSubstring(string s)
{
    bool char_flag[128]; // 记录字符是否出现过
    int char_sub[128]; // 记录字符下标
    memset(char_flag, false, sizeof char_flag);
    int max_result = 0;
    int begin_sub = 0;

    int sub = 0;
    while (sub &lt; s.length())
    {
        char current_char = s[sub];

        if (char_flag[current_char])
        {
            if (sub - begin_sub &gt; max_result)
            {
                max_result = sub - begin_sub;
            }

            for (int i = begin_sub; i &lt; char_sub[current_char]; ++i)
            {
                char_flag[s[i]] = false;
            }
            begin_sub = char_sub[current_char] + 1;
            char_sub[current_char] = sub;
        }
        else
        {
            char_sub[current_char] = sub;
            char_flag[current_char] = true;
        }

        sub++;
        if (sub == s.length())
        {
            if (sub - begin_sub &gt; max_result)
            {
                max_result = sub - begin_sub;
            }
        }

    }

    return max_result;
}
};</code></pre>
<p>思路是按顺序读取char, 如果没有出现过则标记出现记录下标.</p>
<p>如果出现了则用当前下标减去开始下标判断是否更长来记录, 同时更新开始下标为重复字符的下标后一个字符下标.</p>
<p>移动开始下标后 需要取消 新开始标记和旧开始标记之前的char标记</p>
<h4 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h4><pre><code class="c++">class Solution {
public:
    int lengthOfLongestSubstring(string s)
    {
        int heap[128] = {0};
        int res = 0;
        for(int i = 0, j = 0; j &lt; s.size(); ++j)
        {
            heap[s[j]]++; // 标记字符出现
            while(heap[s[j]] &gt; 1) // 再次出现
            {
              /*
              开始符号标记下标 向前滑动 1 将开始下标的字符滑动出去
              如果滑出去的字符是本次遇到的重复字符 则继续 否则一直滑动到重复字符位置
              */
                heap[s[i]]--;
                i++;
            }
            res = max(res, j - i + 1);
        }
        return res;
    }
};</code></pre>
<p>首先看上去 代码就非常的短 我的写了40行而这个仅有10行</p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>我的虽然不是一次滑动一个字符 而是滑动一步到位. 但是仍需要一个for循环来去掉滑出的字符. 所以同样例代码思想.</p>
<p>所以没有必要一次滑动到位, 反正for循环需要执行就在for之中慢慢滑动. <code>这样可以省去记录字符出现的下标</code></p>
<p>我字符出现记录使用的bool数组然而使用<code>int数组却能包含更多的信息</code>.</p>
<p>我原版代码需要额外判定一次是否到了尾部, 当最后一个字符没有重复的时候 循环就结束了.</p>
<h3 id="N34-在排序数组中查找元素的第一个和最后一个位置"><a href="#N34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="N34.在排序数组中查找元素的第一个和最后一个位置"></a>N34.在排序数组中查找元素的第一个和最后一个位置</h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p>示例 1:</p>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]</code></pre><p>示例 2:</p>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target)
    {
        int left = 0;
        int right = nums.size();

        while (left &lt; right)
        {
            int sub = (right + left) &gt;&gt; 1;
            if (target == nums[sub])
            {
                int l_sub, r_sub;
                for (l_sub = sub - 1; l_sub &gt;=0 &amp;&amp; nums[l_sub] == target; --l_sub)
                {

                }
                for (r_sub = sub + 1; r_sub &lt;= nums.size() - 1 &amp;&amp; nums[r_sub] == target; ++r_sub)
                {

                }
                return {l_sub + 1, r_sub - 1};
            }
            else if (target &lt; nums[sub])
            {
                right = sub;
            }
            else
            {
                left = sub + 1;
            }
        }

        return {-1, -1};
    }
};</code></pre>
<p>思路使用二分搜索找到目标元素 然后想左右扩散寻找边界</p>
<h3 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h3><p>统计一个数字在排序数组中出现的次数。</p>
<p>示例 1:</p>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 8
输出: 2</code></pre><p>示例 2:</p>
<pre><code>输入: nums = [5,7,7,8,8,10], target = 6
输出: 0</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="代码1-2"><a href="#代码1-2" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:
    int search(vector&lt;int&gt;&amp; nums, int target)
    {
        int left = 0;
        int right = nums.size();

        while (left &lt; right)
        {
            int sub = (right + left) &gt;&gt; 1;
            if (target == nums[sub])
            {
                int result = 1;
                for (int l_sub = sub - 1; l_sub &gt;=0 &amp;&amp; nums[l_sub] == target; --l_sub)
                {
                    ++result;
                }
                for (int r_sub = sub + 1; r_sub &lt;= nums.size() - 1 &amp;&amp; nums[r_sub] == target; ++r_sub)
                {
                    ++result;
                }
                return result;
            }
            else if (target &lt; nums[sub])
            {
                right = sub;
            }
            else
            {
                left = sub + 1;
            }
        }

        return 0;
    }
};</code></pre>
<p>思路同上, 返回值不同</p>
<h3 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p>示例 1：</p>
<pre><code>输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
将它们合并到一个有序链表中得到。
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><p>示例 2：</p>
<pre><code>输入：lists = []
输出：[]</code></pre><p>示例 3：</p>
<pre><code>输入：lists = [[]]
输出：[]</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="代码1-3"><a href="#代码1-3" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:

    ListNode* Merge(const vector&lt;ListNode*&gt;&amp; lists, int left, int right)
    {
        if (right - left &lt;= 1)
        {
            return lists[left];
        }
        else if (right - left == 2)
        {
            ListNode* node1 = lists[left];
            ListNode* node2 = lists[left + 1];

            if (!node1)
            {
                return node2;
            }
            else if (!node2)
            {
                return node1;
            }

            ListNode* head = new ListNode;
            ListNode* node = head;

            if (node1-&gt;val &lt;= node2-&gt;val)
            {
                head-&gt;val = node1-&gt;val;
                node1 = node1-&gt;next;
            }
            else
            {
                head-&gt;val = node2-&gt;val;
                node2 = node2-&gt;next;
            }

            while (node1 != nullptr || node2 != nullptr)
            {
                if (!node1 || (node2 &amp;&amp; node2-&gt;val &lt;= node1-&gt;val))
                {
                    node-&gt;next = new ListNode(node2-&gt;val);
                    node = node-&gt;next;
                    node2 = node2-&gt;next;
                }
                else if (node2 == nullptr || (node1 &amp;&amp; node1-&gt;val &lt; node2-&gt;val))
                {
                    node-&gt;next = new ListNode(node1-&gt;val);
                    node = node-&gt;next;
                    node1 = node1-&gt;next;
                }
            }

            return head;
        }
        else
        {
            int mid = (left + right) &gt;&gt; 1;
            ListNode* node1 = Merge(lists, left, mid);
            ListNode* node2 = Merge(lists, mid, right);
            ListNode* result = Merge({ node1, node2 }, 0, 2);
            return result;
        }
    }

    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)
    {
        if (lists.empty())
        {
            return nullptr;
        }
        return Merge(lists, 0, lists.size());
    }
};</code></pre>
<p>思路的话比较简单 使用分治和递归. 将若干个<code>ListNode*</code>的合并的最终分解为 两两合并. 然后将合并结果再两两合并</p>
<p>第一版代码 我甚至没有delete临时用的指针… 有内存泄漏的问题  最终提交后 <code>Time-33%</code>…. 好吧</p>
<p>仔细想了下部分地方不需要这么多的拷贝 直接复用已有的<code>ListNode*</code>就行</p>
<h4 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h4><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:

    ListNode* Merge(const vector&lt;ListNode*&gt;&amp; lists, int left, int right)
    {
        if (right - left &lt;= 1)
        {
            return lists[left];
        }
        else if (right - left == 2) // 主要改动从这里开始
        {
            ListNode* node1 = lists[left];
            ListNode* node2 = lists[left + 1];

            if (!node1)
            {
                return node2;
            }
            else if (!node2)
            {
                return node1;
            }

            ListNode* head;
            if (node1-&gt;val &lt;= node2-&gt;val)
            {
                head = node1;
                node1 = node1-&gt;next;
            }
            else
            {
                head = node2;
                node2 = node2-&gt;next;
            }

            ListNode* node = head;

            while (node1 != nullptr || node2 != nullptr)
            {
                if (!node1) // 同时在`node1`或`node2`为空的时候 直接append 避免额外的扫描
                {
                    node-&gt;next = node2;
                    break;
                }
                else if (!node2)
                {
                    node-&gt;next = node1;
                    break;
                }
                else
                {
                    if (node2-&gt;val &lt;= node1-&gt;val)
                    {
                        node-&gt;next = node2;
                        node = node-&gt;next;

                        node2 = node2-&gt;next;
                    }
                    else
                    {
                        node-&gt;next = node1;
                        node = node-&gt;next;

                        node1 = node1-&gt;next;
                    }
                }
            }

            return head;
        }
        else
        {
            int mid = (left + right) &gt;&gt; 1;
            ListNode* node1 = Merge(lists, left, mid);
            ListNode* node2 = Merge(lists, mid, right);
            ListNode* result = Merge({ node1, node2 }, 0, 2);
            return result;
        }
    }

    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)
    {
        if (lists.empty())
        {
            return nullptr;
        }
        return Merge(lists, 0, lists.size());
    }
};</code></pre>
<p>这次改动去掉了所有的new 因为直接复用已有的ListNode即可 同时在<code>node1</code>或<code>node2</code>为空的时候 直接append 避免额外的扫描</p>
<p>从<code>Time-33%</code>变化到了<code>Time-67%</code>  </p>
<h4 id="样例代码-1"><a href="#样例代码-1" class="headerlink" title="样例代码"></a>样例代码</h4><pre><code class="c++">class Solution {
public:
    // 合并两个有序链表
    ListNode* merge(ListNode* p1, ListNode* p2){ // 合并
        if(!p1) return p2;
        if(!p2) return p1;
        if(p1-&gt;val &lt;= p2-&gt;val){
            p1-&gt;next = merge(p1-&gt;next, p2);
            return p1;
        }else{
            p2-&gt;next = merge(p1, p2-&gt;next);
            return p2;
        }
    }

    ListNode* merge(vector&lt;ListNode*&gt;&amp; lists, int start, int end){ // 负责拆分和合并
        if(start == end) return lists[start];
        int mid = (start + end) / 2;
        ListNode* l1 = merge(lists, start, mid);
        ListNode* l2 = merge(lists, mid+1, end);
        return merge(l1, l2);
    }

    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        if(lists.size() == 0) return nullptr;
        return merge(lists, 0, lists.size()-1);
    }
};</code></pre>
<p>这代码太精简了…</p>
<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<pre><code>输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。</code></pre><p>示例 2：</p>
<pre><code>输入: &quot;cbbd&quot;
输出: &quot;bb&quot;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="代码1-中心扩散法"><a href="#代码1-中心扩散法" class="headerlink" title="代码1 - 中心扩散法"></a>代码1 - 中心扩散法</h4><pre><code class="c++">class Solution {
public:
    string longestPalindrome(string s)
    {
        /* 开头老套路 先处理了最简单的输入*/
        if (s.length() &lt;= 1)
        {
            return s;
        }

        /* 记录最大长度*/
        int max_len = 0;

        /* 记录最大长度子串的开始下标 用于return时的substr 解决拷贝问题*/
        int result_begin_sub = 0;
        int i = 0;
        while (i &lt; s.length())
        {
            int l_begin = i, r_begin = i;

            /* 从当前下标开始 找到最长的相同字符子串*/
            /* lbegin指向此子串的开始字符 rbegin指向结尾字符*/
            while (r_begin &lt; s.length() - 1 &amp;&amp; s[r_begin + 1] == s[i])
            {
                r_begin++;
            }
            /* 更新下标 减少循环次数*/
            i = r_begin + 1;

            /* 向左右两侧遍历 相同字符则 向左移动lbegin 向右移动rbegin*/
            do
            {
                l_begin--;
                r_begin++;
            }
            while (l_begin &gt;=0 &amp;&amp; r_begin &lt; s.length() &amp;&amp; s[l_begin] == s[r_begin]);

            /* 更新最大长度*/
            int len = r_begin - l_begin - 1;
            if (len &gt; max_len)
            {
                max_len = len;
                result_begin_sub = l_begin + 1;
            }
        }

        return s.substr(result_begin_sub, max_len);
    }
};</code></pre>
<p>遍历字符串 从当前循环开始下标找到最长的相同字符子串 如a 或 bb 或 ccc</p>
<p>然后向左右两侧遍历 如果左右字符相同 继续遍历 最终得到两个下标</p>
<p>左下标指向当前最大回文子串的左边一个字符 右下标指向右边一个字符</p>
<p>这样就得到了子串的开始下标和长度 更新最大长度 继续遍历</p>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p>示例 1:</p>
<pre><code>输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 
输出：3  
解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</code></pre><p>示例 2:</p>
<pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;
输出：3
解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</code></pre><p>示例 3:</p>
<pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;
输出：0
解释：两个字符串没有公共子序列，返回 0。</code></pre><p>提示:</p>
<pre><code>1 &lt;= text1.length &lt;= 1000
1 &lt;= text2.length &lt;= 1000
输入的字符串只含有小写英文字符。</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="代码1-4"><a href="#代码1-4" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">    int longest(const std::string&amp; text1, const std::string&amp; text2, 
        int text1_sub, int text2_sub)
    {
        if (text1_sub &gt;= text1.length() || text2_sub &gt;= text2.length())
        {
            return 0;
        }
        if (text1[text1_sub] == text2[text2_sub])
        {
            return 1 + longest(text1, text2, text1_sub + 1, text2_sub + 1);
        }
        else
        {
            return max(longest(text1, text2, text1_sub + 1, text2_sub), 
                        longest(text1, text2, text1_sub, text2_sub + 1));
        }
    }

    int longestCommonSubsequence(string text1, string text2)
    {
        return longest(text1, text2, 0, 0);
    }</code></pre>
<p>最简单的思路 然而会超时</p>
<h4 id="代码2-动态规划"><a href="#代码2-动态规划" class="headerlink" title="代码2 动态规划"></a>代码2 动态规划</h4><pre><code class="c++">int longestCommonSubsequence(string text1, string text2)
    {
        int result[1005][1005]{};

        for (int i1 = 0; i1 &lt; text1.length(); ++i1)
        {
            for (int i2 = 0; i2 &lt; text2.length(); ++i2)
            {
                if (text1[i1] == text2[i2])
                {
                    result[i1 + 1][i2 + 1] = result[i1][i2] + 1;
                }
                else
                {
                    result[i1 + 1][i2 + 1] = max(result[i1][i2 + 1], result[i1 + 1][i2]);
                }
            }
        }
        return result[text1.length()][text2.length()];
    }</code></pre>
<p>设text1和text2的解是T</p>
<ul>
<li>如果text1和text2的最后两个字符相等, 则T的最后一个字符也是这个字符</li>
</ul>
<p>这样 text1和text2分别去掉最后一个字符后, T去掉最后一个字符后的T1 是前面两个新字符串的最长公共子序列</p>
<ul>
<li>如果最后两个字符不同, 则T可能是text1去掉最后一个字符后和text2的最长公共子序列 也可能是text2去掉最后一个字符后和text1的最长公共子序列</li>
</ul>
<p>这个可以循环下去, 直到最后两个字符相等 转入上方过程</p>
<p>由于存在多种可能便需要设置result数组存储中间结果<code>result[i][j]</code>是text1前i个字符和text2前j个字符的最长公共子序列长度</p>
<p>数组填充方式 为上方描述的逆过程. </p>
<ul>
<li><p>如果i1 i2所指字符相同 <code>result[i][j]</code>结果是<code>result[i - 1][j - 1] + 1</code><br>表示的是text1前i-1字符和text2前j-1字符最长公共子序列 加上 这个相同的字符 得到前i和前j的最长公共子序列</p>
</li>
<li><p>如果所指字符不同则<code>result[i][j]</code>可能是<code>result[i][j - 1]</code> 也可能是<code>result[i][j - 1]</code>取最大值<br>表示的是前ij的最长公共子序列是 text1前i字符和text2前j-1字符最长公共子序列 或者是 前i-1和前j的最长公共子序列</p>
</li>
</ul>
<p>最终得到结果<code>result[text1.length()][text2.length()]</code> 表示前length1和前length2的最长公共子序列</p>
<h3 id="E53-最大子序和"><a href="#E53-最大子序和" class="headerlink" title="E53.最大子序和"></a>E53.最大子序和</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<pre><code>输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6</code></pre><p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="代码1-5"><a href="#代码1-5" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums)
    {

        vector&lt;int&gt; b(nums.size());
        b[0] = nums[0];

        for (int i = 1; i &lt; nums.size(); ++i)
        {
            if (b[i - 1] &gt; 0)
            {
                b[i] = b[i - 1] + nums[i];
            }
            else
            {
                b[i] = nums[i];
            }
        }

        int result = b[0];
        for (int i = 1; i &lt; b.size(); ++i)
        {
            if (b[i] &gt; result)
            {
                result = b[i];
            }
        }
        return result;
    }
};</code></pre>
<h4 id="代码2-1"><a href="#代码2-1" class="headerlink" title="代码2"></a>代码2</h4><pre><code class="c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums)
    {
        int numss = nums.size();
        int temp = nums[0];
        int result = nums[0];

        for (int i = 1; i &lt; numss; ++i)
        {
            temp = temp &gt; 0 ? temp + nums[i] : nums[i];
            result = result &gt; temp ? result : temp;
        }
        return result;
    }
};</code></pre>
<p>省去了一个vector 代码看起来也简洁不少</p>
<h3 id="H51-amp-H52N皇后"><a href="#H51-amp-H52N皇后" class="headerlink" title="H51&amp;H52N皇后"></a>H51&amp;H52N皇后</h3><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png" alt=""></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例：</p>
<pre><code>输入：4
输出：[
 [&quot;.Q..&quot;,  // 解法 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // 解法 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]</code></pre><p>解释: 4 皇后问题存在两个不同的解法。</p>
<p>提示：</p>
<ul>
<li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-queens" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="代码1-6"><a href="#代码1-6" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:

    bool Check(int n, vector&lt;string&gt;&amp; temp, int row, int column)
    {
        for (int c = 0; c &lt; column; ++c)
        {
            if (temp[row][c] == &#39;Q&#39;)
            {
                return false;
            }
        }

        for (int r = row - 1, c = column - 1 ; r &gt;= 0 &amp;&amp; c &gt;= 0; --r, --c)
        {
            if (temp[r][c] == &#39;Q&#39;)
            {
                return false;
            }
        }

        for (int r = row + 1, c = column - 1 ; r &lt; n &amp;&amp; c &gt;= 0; ++r, --c)
        {
            if (temp[r][c] == &#39;Q&#39;)
            {
                return false;
            }
        }

        return true;
    }

    void Solve(int n, int column, vector&lt;string&gt;&amp; temp, vector&lt;vector&lt;string&gt;&gt;&amp; result)
    {
        if (column &gt;= n)
        {
            result.push_back(temp);
            return;
        }

        for (int i = 0; i &lt; n; ++i)
        {
            temp[i][column] = &#39;Q&#39;;
            if (Check(n, temp, i, column))
            {
                Solve(n, column + 1, temp, result);
            }
            temp[i][column] = &#39;.&#39;;
        }
    }

    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) // H51 N皇后
    {
        vector&lt;vector&lt;string&gt;&gt; result;
        vector&lt;string&gt; temp(n, string(n, &#39;.&#39;));
        Solve(n, 0, temp, result);
        return result;
    }

    int totalNQueens(int n) // H52 N皇后
    {
        return solveNQueens(n).size();
    }
};</code></pre>
<p>不知道第几次做了.. 思路很清晰</p>
<h3 id="N55-跳跃游戏"><a href="#N55-跳跃游戏" class="headerlink" title="N55.跳跃游戏"></a>N55.跳跃游戏</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p>示例 1:</p>
<pre><code>输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</code></pre><p>示例 2:</p>
<pre><code>输入: [3,2,1,0,4]
输出: false</code></pre><p>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jump-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="代码1-7"><a href="#代码1-7" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums)
    {
        int level = 0;
        int numss = nums.size();

        while (level &lt; numss)
        {
            if (nums[level] == 0)
            {
                int back_level = level - 1;
                while (back_level &gt;= 0 &amp;&amp; back_level + nums[back_level] &lt;= level)
                {
                    back_level--;
                }
                if (back_level &lt; 0)
                {
                    break;
                }
                level = back_level + nums[back_level];
            }
            else
            {
                level += nums[level];
            }
        }

        return level + 1 &gt;= numss;
    }
};</code></pre>
<p>能跳则跳最大长度, 不能跳则每一回退一个台阶 回退后的台阶必须能够跳到原台阶的后面位置</p>
<p>如果跳到numss上或者外说明能到, 如果因为回退回到了起点则不能跳过</p>
<h4 id="代码2-2"><a href="#代码2-2" class="headerlink" title="代码2"></a>代码2</h4><pre><code class="c++">class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums)
    {
        int numss = nums.size();
        int max_level = 0;
        for (int i = 0; i &lt; numss; ++i)
        {
            if (i &lt;= max_level)
            {
                max_level = max(max_level, i + nums[i]);
                if (max_level &gt;= numss - 1)
                {
                    return true;
                }
            }
            else
            {
                return false;
            }
        }

        return false;
    }
};</code></pre>
<p>然而真的需要回退吗? 可以遍历nums直接算能到的最大长度. 就算有0存在也不影响最远长度 能跳过0去在遍历到0前 max_level就已经跳过去了</p>
<h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p>
<p><strong>示例 1:</strong><br>输入:</p>
<pre><code>&quot;bbbab&quot;</code></pre><p>输出:</p>
<pre><code>4</code></pre><p>一个可能的最长回文子序列为 “bbbb”。</p>
<p><strong>示例 2:</strong><br>输入:</p>
<pre><code>&quot;cbbd&quot;</code></pre><p>输出:</p>
<pre><code>2</code></pre><p>一个可能的最长回文子序列为 “bb”。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 只包含小写英文字母</li>
</ul>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">class Solution {
public:
    int longestPalindromeSubseq(string s)
    {
        int ws = s.size();
        int dp[ws][ws];
        memset(dp, 0, sizeof dp);

        for (int i = 0; i &lt; ws; ++i)
        {
            dp[i][i] = 1;
        }

        for (int i = 1; i &lt; ws; ++i)
        {
            for (int j = 0; j &lt; ws - i; j += 1)
            {
                if (s[j] == s[j + i])
                {
                    dp[j][j + i] = dp[j + 1][j + i - 1] + 2;
                }
                else
                {
                    dp[j][j + i] = max(
                        dp[j + 1][j + i],
                        dp[j][j + i - 1]
                    );
                }
            }
        }

        return dp[0][ws - 1];
    }
};</code></pre>
<h3 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h3><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:</p>
<pre><code>输入: 123
输出: 321</code></pre><p> 示例 2:</p>
<pre><code>输入: -123
输出: -321</code></pre><p>示例 3:</p>
<pre><code>输入: 120
输出: 21</code></pre><p>注意:</p>
<pre><code>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-integer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="代码1-8"><a href="#代码1-8" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:
    int reverse(int x)
    {
        int result = 0;
        while (x != 0)
        {
            int pop = x % 10;
            x /= 10;
            if (result &gt; INT_MAX / 10 || (result == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0; // 2^31 - 1 = 2147483647
            if (result &lt; INT_MIN / 10 || (result == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; // -2^31 = -2147483648
            result = result * 10 + pop;
        }
        return result;
    }
};</code></pre>
<h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p>
<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>
<p>你需要原地修改栈。</p>
<p>示例1:</p>
<pre><code>输入：A = [2, 1, 0], B = [], C = []
输出：C = [2, 1, 0]</code></pre><p>示例2:</p>
<pre><code>输入：A = [1, 0], B = [], C = []
输出：C = [1, 0]</code></pre><p>提示:</p>
<pre><code>A中盘子的数目不大于14个。</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/hanota-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hanota-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="代码1-9"><a href="#代码1-9" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:
    void hanota(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C)
    {
        int n = A.size();
        move(n, A, B, C);
    }

    void move(int n, vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C){
        if (n == 1)
        {
            C.push_back(A.back());
            A.pop_back();
            return;
        }

        move(n-1, A, C, B);    // 将A上面n-1个通过C移到B
        C.push_back(A.back());  // 将A最后一个移到C
        A.pop_back();          // 这时，A空了
        move(n-1, B, A, C);     // 将B上面n-1个通过空的A移到C
    }
};</code></pre>
<h3 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h3><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:</p>
<pre><code>输入: 3
输出: &quot;III&quot;</code></pre><p>示例 2:</p>
<pre><code>输入: 4
输出: &quot;IV&quot;</code></pre><p>示例 3:</p>
<pre><code>输入: 9
输出: &quot;IX&quot;</code></pre><p>示例 4:</p>
<pre><code>输入: 58
输出: &quot;LVIII&quot;
解释: L = 50, V = 5, III = 3.</code></pre><p>示例 5:</p>
<pre><code>输入: 1994
输出: &quot;MCMXCIV&quot;
解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="代码1-10"><a href="#代码1-10" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:
    string intToRoman(int num)
    {
        std::string result;

        auto p = [&amp;](auto a, auto b)
        {
            result += a;
            num -= b;
        };

        int time = num / 1000;
        for (int i = 0; i &lt; time; ++i)
        {
            p(&quot;M&quot;, 1000);
        }

        if (num &gt;= 900)
        {
            p(&quot;CM&quot;, 900);
        }
        else if (num &gt;= 500)
        {
            p(&quot;D&quot;, 500);
        }
        else if (num &gt;= 400)
        {
            p(&quot;CD&quot;, 400);
        }
        time = num / 100;
        for (int i = 0; i &lt; time; ++i)
        {
            p(&quot;C&quot;, 100);
        }


        if (num &gt;= 90)
        {
            p(&quot;XC&quot;, 90);
        }
        else if (num &gt;= 50)
        {
            p(&quot;L&quot;, 50);
        }
        else if (num &gt;= 40)
        {
            p(&quot;XL&quot;, 40);
        }
        time = num / 10;
        for (int i = 0; i &lt; time; ++i)
        {
            p(&quot;X&quot;, 10);
        }


        if (num &gt;= 9)
        {
            p(&quot;IX&quot;, 9);
        }
        else if (num &gt;= 5)
        {
            p(&quot;V&quot;, 5);
        }
        else if (num &gt;= 4)
        {
            p(&quot;IV&quot;, 4);
        }
        time = num;
        for (int i = 0; i &lt; time; ++i)
        {
            p(&quot;I&quot;, 1);
        }


        return result;
    }
};</code></pre>
<p>一堆if else 当时看到后第一时间想到的便是这个做法 然而代码太长了. 然而程序中都是重复的逻辑, 看一下样例答案</p>
<h4 id="代码2-3"><a href="#代码2-3" class="headerlink" title="代码2"></a>代码2</h4><pre><code class="c++">class Solution {
public:
    string intToRoman(int num) {
        int values[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};
        string reps[]={&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;};

        string res;
        for (int i=0; i&lt;13; i++)
        {
            while (num&gt;=values[i])
            {
                num -= values[i];
                res += reps[i];
            }
        }
        return res;
    }
};</code></pre>
<p>同样的逻辑 样例代码却能够使用两个数组来打成….. 太妙了 而且修改起来也比较方便</p>
<h3 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h3><p>Invert a binary tree.</p>
<p>Example:</p>
<pre><code>Input:

     4
   /   \
  2     7
 / \   / \
1   3 6   9
Output:

     4
   /   \
  7     2
 / \   / \
9   6 3   1</code></pre><p>Trivia:<br>This problem was inspired by this original tweet by Max Howell:</p>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p>
<pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root)
    {
        if (!root)
        {
            return nullptr;
        }
        TreeNode* temp = root-&gt;left;
        root-&gt;left = root-&gt;right;
        root-&gt;right = temp;

        invertTree(root-&gt;left);
        invertTree(root-&gt;right);

        return root;
    }
};</code></pre>
<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h3><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>进阶：</p>
<pre><code>你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</code></pre><p>示例：</p>
<pre><code>输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</code></pre><p>提示：</p>
<pre><code>树中节点的数量少于 4096
-1000 &lt;= node.val &lt;= 1000</code></pre><pre><code class="c++">/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root)
    {
        if (!root)
        {
            return root;
        }
        connectTwoNode(root-&gt;left, root-&gt;right);
        return root;
    }

    void connectTwoNode(Node* node1, Node* node2)
    {
        if (!node1 || !node2)
        {
            return;
        }

        node1-&gt;next = node2;
        connectTwoNode(node1-&gt;left, node1-&gt;right);
        connectTwoNode(node2-&gt;left, node2-&gt;right);
        connectTwoNode(node1-&gt;right, node2-&gt;left);
    }
};</code></pre>
<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h3><p>给定一个二叉树，原地将它展开为一个单链表。</p>
<p>例如，给定二叉树</p>
<pre><code>    1
   / \
  2   5
 / \   \
3   4   6</code></pre><p>将其展开为：</p>
<pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6</code></pre><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root)
    {
        if (!root)
        {
            return;
        }

        flatten(root-&gt;left);
        flatten(root-&gt;right);

        TreeNode* right = root-&gt;right;
        root-&gt;right = root-&gt;left;
        root-&gt;left = nullptr;

        TreeNode* temp = root;
        while (temp-&gt;right)
        {
            temp = temp-&gt;right;
        }

        temp-&gt;right = right;
    }
};</code></pre>
<h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 *<em>key *</em>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。</li>
</ol>
<p><strong>说明：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<p><strong>示例:</strong></p>
<pre><code>root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

    5
   / \
  4   6
 /     \
2       7

另一个正确答案是 [5,2,6,null,4,null,7]。

    5
   / \
  2   6
   \   \
    4   7</code></pre><h4 id="代码1-11"><a href="#代码1-11" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    int GetMin(TreeNode* root)
    {
        while (root-&gt;left)
        {
            root = root-&gt;left;
        }
        return root-&gt;val;
    }

    TreeNode* deleteNode(TreeNode* root, int key)
    {
        if (!root)
        {
            return nullptr;
        }

        if (root-&gt;val == key)
        {
            if (!root-&gt;left)
            {
                return root-&gt;right;
            }
            else if (!root-&gt;right)
            {
                return root-&gt;left;
            }
            else
            {
                root-&gt;val = GetMin(root-&gt;right);
                root-&gt;right = deleteNode(root-&gt;right, root-&gt;val);
            }

        }
        else if (root-&gt;val &lt; key)
        {
            root-&gt;right = deleteNode(root-&gt;right, key);
        }
        else if (root-&gt;val &gt; key)
        {
            root-&gt;left = deleteNode(root-&gt;left, key);
        }

        return root;
    }
};</code></pre>
<h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt=""></p>
<pre><code>输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：root = [40,20,60,10,30,50,70], val = 25
输出：[40,20,60,10,30,50,70,null,null,25]</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
输出：[4,2,7,1,3,5]</code></pre><p><strong>提示：</strong></p>
<ul>
<li>给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li>
<li>每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li>
<li><code>-10^8 &lt;= val &lt;= 10^8</code></li>
<li>新值和原始二叉搜索树中的任意节点值都不同</li>
</ul>
<h4 id="代码1-12"><a href="#代码1-12" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val)
    {
        if (!root)
        {
            return new TreeNode(val);
        }
        if (val &lt; root-&gt;val)
        {
            root-&gt;left = insertIntoBST(root-&gt;left, val);
        }
        else if (val &gt; root-&gt;val)
        {
            root-&gt;right = insertIntoBST(root-&gt;right, val);
        }
        return root;
    }
};</code></pre>
<h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. 二叉搜索树中的搜索</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>例如，</p>
<pre><code>给定二叉搜索树:

        4
       / \
      2   7
     / \
    1   3

和值: 2</code></pre><p>你应该返回如下子树:</p>
<pre><code>      2     
     / \   
    1   3</code></pre><p>在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>。</p>
<h4 id="代码1-13"><a href="#代码1-13" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val)
    {
        if (!root)
        {
            return nullptr;
        }

        if (root-&gt;val == val)
        {
            return root;
        }
        else if (val &lt; root-&gt;val)
        {
            return searchBST(root-&gt;left, val);
        }
        else if (val &gt; root-&gt;val)
        {
            return searchBST(root-&gt;right, val);
        }

        return root;
    }
};</code></pre>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><code>输入:
    2
   / \
  1   3
输出: true</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre><h4 id="代码1-14"><a href="#代码1-14" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root, TreeNode* min, TreeNode* max)
    {
        if (!root)
        {
            return true;
        }
        if (min &amp;&amp; root-&gt;val &lt;= min-&gt;val)
        {
            return false;
        }
        if (max &amp;&amp; root-&gt;val &gt;= max-&gt;val)
        {
            return false;
        }
        return isValidBST(root-&gt;left, min, root) &amp;&amp;
                isValidBST(root-&gt;right, root, max);
    }

    bool isValidBST(TreeNode* root)
    {
        return isValidBST(root, nullptr, nullptr);
    }
};</code></pre>
<h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<pre><code>字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</code></pre><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: &quot;III&quot;
输出: 3</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: &quot;IV&quot;
输出: 4</code></pre><p><strong>示例 3:</strong></p>
<pre><code>输入: &quot;IX&quot;
输出: 9</code></pre><p><strong>示例 4:</strong></p>
<pre><code>输入: &quot;LVIII&quot;
输出: 58
解释: L = 50, V= 5, III = 3.</code></pre><p><strong>示例 5:</strong></p>
<pre><code>输入: &quot;MCMXCIV&quot;
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><p><strong>提示：</strong></p>
<ul>
<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>
<li>IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>
<li>关于罗马数字的详尽书写规则，可以参考 。</li>
</ul>
<h4 id="代码1-15"><a href="#代码1-15" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:
    int romanToInt(string s)
    {
        std::string k[] = {&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;};
        int v[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4 ,1};

        int result = 0;
        int s_sub = 0;
        int k_sub = 0;
        bool flag = true;

        while (s_sub &lt; s.length())
        {
            flag = true;

            int i = 0;
            for (;i &lt; k[k_sub].length(); ++i)
            {
                if (s[s_sub + i] != k[k_sub][i])
                {
                    k_sub++;
                    flag = false;
                    break;
                }
            }

            if (flag)
            {
                s_sub += i;
                result += v[k_sub];
            }
        }
        return result;
    }
};</code></pre>
<p>第一次写出的代码没有通过是因为使用了Map存储的kv然后使用iterator++遍历, 然而iterator遍历并不是按照初始化的顺序而是按照k的大小</p>
<h4 id="代码2-样例"><a href="#代码2-样例" class="headerlink" title="代码2 - 样例"></a>代码2 - 样例</h4><pre><code class="c++">class Solution {
public:
    int romanToInt(string s)
    {
        int m[256];
        m[&#39;I&#39;] = 1;
        m[&#39;V&#39;] = 5;
        m[&#39;X&#39;] = 10;
        m[&#39;L&#39;] = 50;
        m[&#39;C&#39;] = 100;
        m[&#39;D&#39;] = 500;
        m[&#39;M&#39;] = 1000;
        int result=0;
        for(int i = 0; i &lt; s.size(); i++)
        {
            if(m[s[i]]&gt;=m[s[i+1]])
            {
                result+=m[s[i]];
            }
            else
            {
                result-=m[s[i]];
            }
        }
        return result;
    }
};</code></pre>
<p>根据的原理是 把一个小值放在大值的左边，就是做减法，否则为加法。</p>
<p>此外样例中的m数组设计的也是很巧妙, 只初始化自己要使用的部分, <strong>打破了我数组需要连续使用的思维定式</strong></p>
<h3 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. Z 字形变换</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p>
<pre><code>L   C   I   R
E T O E S I I G
E   D   H   N</code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<pre><code>string convert(string s, int numRows);</code></pre><p><strong>示例 1:</strong></p>
<pre><code>输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3
输出: &quot;LCIRETOESIIGEDHN&quot;</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4
输出: &quot;LDREOEIIECIHNTSG&quot;
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G</code></pre><h4 id="代码1-16"><a href="#代码1-16" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:
    string convert(string s, int numRows)
    {
        vector&lt;vector&lt;char&gt;&gt; vec(numRows, vector&lt;char&gt;(s.length(), &#39; &#39;));

        int column = 0;
        int ss = 0;

        while (ss &lt; s.length())
        {
            for (int i = 0; ss &lt; s.length() &amp;&amp; i &lt; numRows; ++i)
            {
                vec[i][column] = s[ss++];
            }
            column++;

            for (int i = numRows - 2; ss &lt; s.length() &amp;&amp; i &gt;= 1; --i)
            {
                vec[i][column] = s[ss++];
                column++;
            }
        }

        std::string result;
        for (int i = 0; i &lt; numRows; ++i)
        {
            for (int j = 0; j &lt; s.length(); ++j)
            {
                if (vec[i][j] != &#39; &#39;)
                {
                    result += vec[i][j];
                }
            }
        }

        return result;
    }
};</code></pre>
<h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">654. 最大二叉树</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ol>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
</ol>
<p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<p><strong>示例 ：</strong></p>
<pre><code>输入：[3,2,1,6,0,5]
输出：返回下面这棵树的根节点：

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1</code></pre><p><strong>提示：</strong></p>
<ol>
<li>给定的数组的大小在 [1, 1000] 之间。</li>
</ol>
<h4 id="代码1-17"><a href="#代码1-17" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {
public:

    int GetMaxSub(vector&lt;int&gt;&amp; nums, int left, int right)
    {
        int result = left;

        for (int i = left + 1; i &lt; right; ++i)
        {
            if (nums[i] &gt; nums[result])
            {
                result = i;
            }
        }

        return result;
    }

    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums)
    {
        int max_sub = GetMaxSub(nums, 0, nums.size());

        TreeNode* root = new TreeNode(nums[max_sub]);

        ConstructMaximumBinaryTree(nums, 0, max_sub, nums.size(), root);

        return root;
    }

    void ConstructMaximumBinaryTree(vector&lt;int&gt;&amp; nums, int left, int mid, int right, TreeNode* root)
    {
        if (left &lt; mid)
        {
            int l_max = GetMaxSub(nums, left, mid);
            root-&gt;left = new TreeNode(nums[l_max]);
            ConstructMaximumBinaryTree(nums, left, l_max, mid, root-&gt;left);
        }

        if (mid + 1 &lt; right)
        {
            int r_max = GetMaxSub(nums, mid + 1, right);
            root-&gt;right = new TreeNode(nums[r_max]);
            ConstructMaximumBinaryTree(nums, mid + 1, r_max, right, root-&gt;right);
        }
    }
};</code></pre>
<p>自己的第一个思路就是通过ConstructMaximumBinaryTree给传入的root节点构造左子树和右子树</p>
<p>然后递归的给root的左子树和右子树构造子树</p>
<p>每次传入left mid right将数组切分为两段 左段构造root的左子树 右段构造root的右子树</p>
<h4 id="代码2-4"><a href="#代码2-4" class="headerlink" title="代码2"></a>代码2</h4><pre><code class="c++">class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums)
    {
        return constructMaximumBinaryTree(nums, 0, nums.size());
    }

    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums, int left, int right)
    {
        if (left + 1 &gt; right)
        {
            return nullptr;
        }

        int max_sub = left;
        for (int i = left + 1; i &lt; right; ++i)
        {
            if (nums[i] &gt; nums[max_sub])
            {
                max_sub = i;
            }
        }

        TreeNode* node = new TreeNode(nums[max_sub]);
        node-&gt;left = constructMaximumBinaryTree(nums, left, max_sub);
        node-&gt;right = constructMaximumBinaryTree(nums, max_sub + 1, right);

        return node;
    }
};</code></pre>
<p>题解的答案更加的简洁每次的constructMaximumBinaryTree仅负责构造一个节点返回回去成为左节点或者右节点</p>
<p>同时给构造出的节点赋值左节点和右节点.</p>
<p>相对我的代码构造左节点和右节点 这里淡化了左右节点的区别. 通过传入的参数即可知道是左右节点然后赋值给left right</p>
<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt=""></p>
<p><strong>示例:</strong></p>
<pre><code>输入：&quot;23&quot;
输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</code></pre><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><pre><code class="c++">​class Solution {
public:
    vector&lt;string&gt; letterCombinations(string digits)
    {
        vector&lt;string&gt; result;
        if (digits.empty())
        {

        }
        else
        {
            solve(digits, 0, &quot;&quot;, result);
        }
        return result;
    }

    void solve(const string&amp; digits, int sub, string temp, vector&lt;string&gt;&amp; result)
    {
        if (sub == digits.size())
        {
            result.push_back(temp);
        }
        else
        {
            char begin = (digits[sub] - &#39;2&#39;) * 3 + &#39;a&#39;;
            switch (digits[sub])
            {
                case &#39;2&#39;:
                case &#39;3&#39;:
                case &#39;4&#39;:
                case &#39;5&#39;:
                case &#39;6&#39;:
                {
                    for (int i = 0; i &lt; 3; ++i)
                    {
                        char a = begin + i;
                        solve(digits, sub + 1, temp + a, result);
                    }
                    break;
                }
                case &#39;7&#39;:
                {
                    for (int i = 0; i &lt; 4; ++i)
                    {
                        char a = begin + i;
                        solve(digits, sub + 1, temp + a, result);
                    }
                    break;
                }
                case &#39;8&#39;:
                {
                    begin += 1;
                    for (int i = 0; i &lt; 3; ++i)
                    {
                        char a = begin + i;
                        solve(digits, sub + 1, temp + a, result);
                    }
                    break;
                }
                case &#39;9&#39;:
                {
                    begin += 1;
                    for (int i = 0; i &lt; 4; ++i)
                    {
                        char a = begin + i;
                        solve(digits, sub + 1, temp + a, result);
                    }
                    break;
                }
            }
        }
    }
};</code></pre>
<h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定一个链表，删除链表的倒数第 _n _个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre><p><strong>说明：</strong></p>
<p>给定的 <em>n</em> 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<h4 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h4><pre><code class="c++">​/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n)
    {
        if (!head)
        {
            return nullptr;
        }

        ListNode* node = head;
        ListNode* temp = node;
        ListNode* last_temp = nullptr;

        int now_sub = 0;

        while (node-&gt;next)
        {
            if (now_sub == n - 1)
            {
                last_temp = temp;
                temp = temp-&gt;next;
                node = node-&gt;next;
            }
            else
            {
                node = node-&gt;next;
                now_sub++;
            }
        }

        if (temp == head)
        {
            head = head-&gt;next;
        }
        else
        {
            last_temp-&gt;next = temp-&gt;next;
        }
        return head;
    }
};</code></pre>
<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""></p>
<pre><code>输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：l1 = [], l2 = []
输出：[]</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：l1 = [], l2 = [0]
输出：[0]</code></pre><p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<h4 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h4><pre><code class="c++">​/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)
    {
        if (!l1)
        {
            return l2;
        }
        if (!l2)
        {
            return l1;
        }

        ListNode* head = nullptr;
        if (l1-&gt;val &lt; l2-&gt;val)
        {
            head = l1;
            l1 = l1-&gt;next;
        }
        else
        {
            head = l2;
            l2 = l2-&gt;next;
        }
        ListNode* temp = head;

        while (l1 || l2)
        {
            if (!l1)
            {
                temp-&gt;next = l2;
                break;
            }
            else if (!l2)
            {
                temp-&gt;next = l1;
                break;
            }
            else
            {
                if (l1-&gt;val &lt; l2-&gt;val)
                {
                    temp-&gt;next = l1;
                    l1 = l1-&gt;next;
                }
                else
                {
                    temp-&gt;next = l2;
                    l2 = l2-&gt;next;
                }
                temp = temp-&gt;next;
            }
        }
        return head;
    }
};</code></pre>
<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt=""></p>
<pre><code>输入：head = [1,2,3,4]
输出：[2,1,4,3]</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：head = []
输出：[]</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：head = [1]
输出：[1]</code></pre><p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h4 id="代码1-18"><a href="#代码1-18" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* node)
    {
        if (!node)
        {
            return nullptr;
        }

        ListNode* temp = node-&gt;next;
        if (!temp)
        {
            return node;
        }

        ListNode* back = temp-&gt;next;
        temp-&gt;next = node;

        node-&gt;next = swapPairs(back);

        return temp;
    }
};</code></pre>
<h3 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h3><p>Difficulty: <strong>简单</strong></p>
<p>给定一个排序数组，你需要在 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<pre><code>给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>示例 2:</strong></p>
<pre><code>给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}</code></pre><h4 id="代码1-19"><a href="#代码1-19" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">​class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums)
    {
        if (nums.empty())
        {
            return 0;
        }

        int t = 1;
        int num = nums[0];

        for (int i = 1; i &lt; nums.size(); ++i)
        {
            if (nums[i] == num)
            {
                continue;
            }
            num = nums[i];
            nums[t++] = nums[i];
        }
        return t;
    }
};</code></pre>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<pre><code>前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]</code></pre><p>返回如下的二叉树：</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre><h4 id="代码1-20"><a href="#代码1-20" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder)
    {
        return build(preorder, 0, preorder.size(), 
        inorder, 0, inorder.size());
    }

    TreeNode* build(vector&lt;int&gt;&amp; preorder, int preb, int pree,
     vector&lt;int&gt;&amp; inorder, int inb, int ine)
    {
        if (preb == pree)
        {
            return nullptr;
        }

        TreeNode* root = new TreeNode(preorder[preb]);

        int in_root;
        for (in_root = inb; in_root &lt; ine; ++in_root)
        {
            if (preorder[preb] == inorder[in_root])
            {
                break;
            }
        }

        int num = in_root - inb;

        root-&gt;left = build(preorder, preb + 1, preb + 1 + num, inorder, inb, in_root);
        root-&gt;right = build(preorder, preb + 1 + num, pree, inorder, in_root + 1, ine);

        return root;
    }
};</code></pre>
<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<pre><code>中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]</code></pre><p>返回如下的二叉树：</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre><h4 id="代码1-21"><a href="#代码1-21" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="C++">​/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder)
    {
        return build(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }

    TreeNode* build(vector&lt;int&gt;&amp; inorder, int inb, int ine, vector&lt;int&gt;&amp; postorder, 
    int pob, int poe)
    {
        if (inb == ine)
        {
            return nullptr;
        }

        TreeNode* root = new TreeNode(postorder[poe - 1]);

        int in_root;
        for (in_root = inb; in_root &lt; ine; ++in_root)
        {
            if (inorder[in_root] == postorder[poe - 1])
            {
                break;
            }
        }

        int num = in_root - inb;

        root-&gt;left = build(inorder, inb, in_root, postorder, pob, pob + num);
        root-&gt;right = build(inorder, in_root + 1, ine, postorder, pob + num, poe - 1);

        return root;
    }
};</code></pre>
<h3 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/" target="_blank" rel="noopener">652. 寻找重复的子树</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p>
<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<p><strong>示例 1：</strong></p>
<pre><code>        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4</code></pre><p>下面是两个重复的子树：</p>
<pre><code>      2
     /
    4</code></pre><p>和</p>
<pre><code>    4</code></pre><p>因此，你需要以列表的形式返回上述重复子树的根结点。</p>
<h4 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1"></a>Solution1</h4><pre><code class="c++">​/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    vector&lt;TreeNode*&gt; result_;

    map&lt;string, int&gt; node_map_;

    vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root)
    {
        solve(root);

        return result_;
    }

    string solve(TreeNode* root)
    {
        if (!root)
        {
            return &quot;#&quot;;
        }

        string left = solve(root-&gt;left);
        string right = solve(root-&gt;right);

        string sum = left + &quot;,&quot; + right + &quot;,&quot; + to_string(root-&gt;val);

        if (node_map_.find(sum) == node_map_.end())
        {
            node_map_.insert({sum, 1});
        }
        else
        {
            if (node_map_[sum] == 1)
            {
                result_.push_back(root);
            }
            node_map_[sum]++;
        }

        return sum;
    }
};</code></pre>
<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：coins = [2], amount = 3
输出：-1</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：coins = [1], amount = 0
输出：0</code></pre><p><strong>示例 4：</strong></p>
<pre><code>输入：coins = [1], amount = 1
输出：1</code></pre><p><strong>示例 5：</strong></p>
<pre><code>输入：coins = [1], amount = 2
输出：2</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li>
<li><code>0 &lt;= amount &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<h4 id="Solution-dp自顶向下"><a href="#Solution-dp自顶向下" class="headerlink" title="Solution - dp自顶向下"></a>Solution - dp自顶向下</h4><pre><code class="c++">​class Solution {
public:

    vector&lt;int&gt; table;
    // map&lt;int, int&gt; table;

    int dp(vector&lt;int&gt;&amp; coins, int amount)
    {
        if (amount == 0)
        {
            return 0;
        }
        else if (amount &lt; 0)
        {
            return -1;
        }
        else if (table[amount] != 0)
        {
            return table[amount];
        }

        int result = INT_MAX;
        for (int i = 0; i &lt; coins.size(); ++i)
        {
            int temp = dp(coins, amount - coins[i]);
            if (temp &lt; 0)
            {
                continue;
            }
            result = min(temp + 1, result);
        }

        result = (result == INT_MAX ? -1 : result);
        table[amount] = result;

        return result;
    }

    int coinChange(vector&lt;int&gt;&amp; coins, int amount)
    {
        if (amount &lt; 1) 
        {
            return 0;
        }
        table.resize(amount + 1);
        return dp(coins, amount);
    }
};</code></pre>
<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h3><p>Difficulty: <strong>困难</strong></p>
<p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code>所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
输出：3
解释：
horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)
rorse -&gt; rose (删除 &#39;r&#39;)
rose -&gt; ros (删除 &#39;e&#39;)</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;
输出：5
解释：
intention -&gt; inention (删除 &#39;t&#39;)
inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)
enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)
exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)
exection -&gt; execution (插入 &#39;u&#39;)</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
<h4 id="Solution-回溯"><a href="#Solution-回溯" class="headerlink" title="Solution 回溯"></a>Solution 回溯</h4><pre><code class="c++">class Solution {
public:

    int min_time = INT_MAX;

    int minDistance(string word1, string word2)
    {
        minDistance(word1, word2, 0, 0, 0);
        return min_time;
    }

    void minDistance(string word1, string word2, int ws1, int ws2, int time)
    {
        if (time &gt;= min_time)
        {
            return;
        }

        if (ws2 == word2.length() || ws1 == word1.length())
        {
            for (int i = 0; i &lt; min(ws1, ws2); ++i)
            {
                if (word1[i] != word2[i])
                {
                    return;
                }
            }
            time += word1.length() &gt; word2.length() ? word1.length() - word2.length() :  word2.length() - word1.length();
            if (time &lt; min_time)
            {
                min_time = time;
            }
        }
        else
        {
            if (word1[ws1] == word2[ws2])
            {
                minDistance(word1, word2, ws1 + 1, ws2 + 1, time);
            }
            else
            {
                char back = word1[ws1];
                word1[ws1] = word2[ws2];
                minDistance(word1, word2, ws1 + 1, ws2 + 1, time + 1);
                word1[ws1] = back;

                string back_str = word1;
                word1.erase(ws1, 1);
                minDistance(word1, word2, ws1, ws2, time + 1);
                word1 = back_str;

                word1.insert(ws1, 1, word2[ws2]);
                minDistance(word1, word2, ws1 + 1, ws2 + 1, time + 1);
            }
        }
    }
};</code></pre>
<h4 id="Solution-DP备忘录"><a href="#Solution-DP备忘录" class="headerlink" title="Solution DP备忘录"></a>Solution DP备忘录</h4><pre><code class="c++">​class Solution {
public:

    map&lt;string, int&gt; bwl;
    int minDistance(string word1, string word2)
    {
        return minDistance(word1, word2, word1.length() - 1, word2.length() - 1);
    }

    int minDistance(const string&amp; word1, const string&amp; word2, int ws1, int ws2)
    {
        if (ws1 == -1) return ws2 + 1;
        if (ws2 == -1) return ws1 + 1;

        string key = to_string(ws1) + &quot;#&quot; + to_string(ws2);
        if (bwl.find(key) != bwl.end())
        {
            return bwl[key];
        }

        if (word1[ws1] == word2[ws2])
        {
            bwl[key] = minDistance(word1, word2, ws1 - 1, ws2 - 1);
        }
        else
        {
            bwl[key] = min({
                minDistance(word1, word2, ws1, ws2 - 1), // 插入
                minDistance(word1, word2, ws1 - 1, ws2 - 1), // 替换
                minDistance(word1, word2, ws1 - 1, ws2) // 删除
            }) + 1;
        }

        return bwl[key];
    }
};</code></pre>
<h4 id="Solution-DP-Table"><a href="#Solution-DP-Table" class="headerlink" title="Solution DP Table"></a>Solution DP Table</h4><pre><code class="c++">class Solution {
public:

    int minDistance(string word1, string word2)
    {
        int dp[word1.length() + 1][word2.length() + 1];

        dp[0][0] = 0;
        for (int i = 1; i &lt;= word2.length(); ++i)
        {
            dp[0][i]  = i;
        }
        for (int i = 1; i &lt;= word1.length(); ++i)
        {
            dp[i][0] = i;
        }

        for (int ws1 = 1; ws1 &lt;= word1.length(); ++ws1)
        {
            for (int ws2 = 1; ws2 &lt;= word2.length(); ++ws2)
            {
                if (word1[ws1 - 1] == word2[ws2 - 1])
                {
                    dp[ws1][ws2] = dp[ws1 - 1][ws2 - 1];
                }
                else
                {
                    dp[ws1][ws2] = min({
                        dp[ws1 - 1][ws2 - 1],
                        dp[ws1][ws2 - 1],
                        dp[ws1 - 1][ws2]
                    }) + 1;
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
};</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用回溯法的代码超时了, 而且回溯解法里面对字符串进行了实打实的修改</p>
<p>从回溯法转向DP备忘录优化了一个参数 使用返回值返回答案而不是单独的time参数. DP备忘录由于使用了递归所以使用的空间大, 效率也低 </p>
<p>观察DP备忘录<br><code>dp[ws1][ws2]</code>只跟<code>dp[ws1-1][ws2-1]</code>, <code>dp[ws1][ws2-1]</code>和<code>dp[ws1-1][ws2]</code>有关进而自然的转向DP Table</p>
<p>Dp Table这里数组一般都需要多开一行+一列 对应代码里面的<code>length()+1</code>, 否则下标0含有两层意思 一是空串时长度为0 二是非空串是含有0这个有效下标</p>
<p>所以将非空串的下标改为从1开始</p>
<h3 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. 俄罗斯套娃信封问题</a></h3><p>Difficulty: <strong>困难</strong></p>
<p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 <code>(w, h)</code> 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<p><strong>说明:</strong><br>不允许旋转信封。</p>
<p><strong>示例:</strong></p>
<pre><code>输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:
    int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes)
    {
        if (envelopes.empty())
        {
            return 0;
        }

        sort(envelopes.begin(), envelopes.end(), [](const auto&amp; lhs, const auto&amp; rhs){
            if (lhs[0] != rhs[0])
            {
                return lhs[0] &lt; rhs[0];
            }
            else
            {
                return lhs[1] &gt; rhs[1];
            }
        });

        int nums[envelopes.size()];

        for (int i = 0; i &lt; envelopes.size(); ++i)
        {
            nums[i] = envelopes[i][1];
        }

        int dp[envelopes.size()];
        int result = 1;
        for (int i = 0; i &lt; envelopes.size(); ++i)
        {
            dp[i] = 1;
            for (int j = 0; j &lt; i; ++j)
            {
                if (nums[j] &lt; nums[i] &amp;&amp; dp[j] &gt;= dp[i])
                {
                    dp[i] = dp[j] + 1;

                    if (dp[i] &gt; result)
                    {
                        result = dp[i];
                    }
                }
            }
        }

        return result;
    }
};</code></pre>
<h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<pre><code>输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：nums = [0,1,0,3,2,3]
输出：4</code></pre><p><strong>示例 3：</strong></p>
<pre><code>输入：nums = [7,7,7,7,7,7,7]
输出：1</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li><code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以设计时间复杂度为 <code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code> 的解决方案吗？</li>
<li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li>
</ul>
<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums)
    {
        int dp[nums.size()];
        dp[0] = 1;

        for (int i = 1; i &lt; nums.size(); ++i)
        {
            dp[i] = 1;
            for (int j = 0; j &lt; i; ++j)
            {
                if (nums[j] &lt; nums[i] &amp;&amp; dp[j] &gt;= dp[i])
                {
                    dp[i] = dp[j] + 1;
                }
            }
        }

        int result = 0;
        for (int i = 0; i &lt; nums.size(); ++i)
        {
            if (dp[i] &gt; result)
            {
                result = dp[i];
            }
        }
        return result;
    }
};</code></pre>
<h3 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. 两个字符串的删除操作</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定两个单词 _word1 _和 _word2_，找到使得 _word1 _和 _word2 _相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p><strong>示例：</strong></p>
<pre><code>输入: &quot;sea&quot;, &quot;eat&quot;
输出: 2
解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot;</code></pre><p><strong>提示：</strong></p>
<ol>
<li>给定单词的长度不超过500。</li>
<li>给定单词中的字符只含有小写字母。</li>
</ol>
<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:
    int minDistance(string word1, string word2)
    {   
        int ws1 = word1.size();
        int ws2 = word2.size();

        int dp[ws1 + 1][ws2 + 1];

        for (int i = 0; i &lt;= ws1; ++i)
        {
            dp[i][0] = i;
        }
        for (int i = 0; i &lt;= ws2; ++i)
        {
            dp[0][i] = i;
        }

        for (int i = 1; i &lt;= ws1; ++i)
        {
            for (int j = 1; j &lt;= ws2; ++j)
            {
                if (word1[i - 1] == word2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else
                {
                    dp[i][j] = min(
                        dp[i - 1][j],
                        dp[i][j - 1]
                    ) + 1;
                }
            }
        }

        return dp[ws1][ws2];
    }
};</code></pre>
<h3 id="712-两个字符串的最小ASCII删除和"><a href="#712-两个字符串的最小ASCII删除和" class="headerlink" title="712. 两个字符串的最小ASCII删除和"></a><a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/" target="_blank" rel="noopener">712. 两个字符串的最小ASCII删除和</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定两个字符串<code>s1, s2</code>，找到使两个字符串相等所需删除字符的ASCII值的最小和。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入: s1 = &quot;sea&quot;, s2 = &quot;eat&quot;
输出: 231
解释: 在 &quot;sea&quot; 中删除 &quot;s&quot; 并将 &quot;s&quot; 的值(115)加入总和。
在 &quot;eat&quot; 中删除 &quot;t&quot; 并将 116 加入总和。
结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入: s1 = &quot;delete&quot;, s2 = &quot;leet&quot;
输出: 403
解释: 在 &quot;delete&quot; 中删除 &quot;dee&quot; 字符串变成 &quot;let&quot;，
将 100[d]+101[e]+101[e] 加入总和。在 &quot;leet&quot; 中删除 &quot;e&quot; 将 101[e] 加入总和。
结束时，两个字符串都等于 &quot;let&quot;，结果即为 100+101+101+101 = 403 。
如果改为将两个字符串转换为 &quot;lee&quot; 或 &quot;eet&quot;，我们会得到 433 或 417 的结果，比答案更大。</code></pre><p><strong>注意:</strong></p>
<ul>
<li><code>0 &lt; s1.length, s2.length &lt;= 1000</code>。</li>
<li>所有字符串中的字符ASCII值在<code>[97, 122]</code>之间。</li>
</ul>
<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {
public:
    int minimumDeleteSum(string s1, string s2)
    {
        int ws1 = s1.size();
        int ws2 = s2.size();

        int dp[ws1 + 1][ws2 + 1];

        dp[0][0] = 0;

        for (int i = 1; i &lt;= ws1; ++i)
        {
            dp[i][0] = dp[i - 1][0] + s1[i - 1];
        }
        for (int i = 1; i &lt;= ws2; ++i)
        {
            dp[0][i] = dp[0][i - 1] + s2[i - 1];
        }

        for (int i = 1; i &lt;= ws1; ++i)
        {
            for (int j = 1; j &lt;= ws2; ++j)
            {
                if (s1[i - 1] == s2[j - 1])
                {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else
                {
                    dp[i][j] = min(
                        dp[i][j - 1] + s2[j - 1],
                        dp[i - 1][j] + s1[i - 1]
                    );
                }
            }
        }

        return dp[ws1][ws2];
    }
};</code></pre>
<h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层序遍历</a></h3><p>Difficulty: <strong>中等</strong></p>
<p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7</code></pre><p>返回锯齿形层序遍历如下：</p>
<pre><code>[
  [3],
  [20,9],
  [15,7]
]</code></pre><h4 id="Solution-无reverse"><a href="#Solution-无reverse" class="headerlink" title="Solution - 无reverse"></a>Solution - 无reverse</h4><pre><code class="c++">​/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) 
    {
        if (!root)
        {
            return {};
        }

        deque&lt;TreeNode*&gt; nodes_last;
        deque&lt;TreeNode*&gt; nodes_next;
        nodes_last.push_back(root);
        bool r_to_l = false;

        vector&lt;vector&lt;int&gt;&gt; result;
        while (!nodes_last.empty())
        {
            vector&lt;int&gt; temp;
            temp.reserve(nodes_last.size());
            if (r_to_l)
            {
                while (!nodes_last.empty())
                {
                    TreeNode* node = nodes_last.back();
                    nodes_last.pop_back();
                    if (node-&gt;right)
                    {
                        nodes_next.push_front(node-&gt;right);
                    }
                    if (node-&gt;left)
                    {
                        nodes_next.push_front(node-&gt;left);
                    }
                    temp.push_back(node-&gt;val);
                }
            }
            else
            {
                while (!nodes_last.empty())
                {
                    TreeNode* node = nodes_last.front();
                    nodes_last.pop_front();
                    if (node-&gt;left)
                    {
                        nodes_next.push_back(node-&gt;left);
                    }
                    if (node-&gt;right)
                    {
                        nodes_next.push_back(node-&gt;right);
                    }
                    temp.push_back(node-&gt;val);
                }
            }
            result.push_back(move(temp));
            r_to_l = !r_to_l;
            nodes_next.swap(nodes_last);
        }
        return result;
    }
};</code></pre>
<h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></h3><p>Difficulty: <strong>困难</strong></p>
<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt=""></p>
<pre><code>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </code></pre><p><strong>示例 2：</strong></p>
<pre><code>输入：height = [4,2,0,3,2,5]
输出：9</code></pre><p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>0 &lt;= n &lt;= 3 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li>
<li><code>0 &lt;= height[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li>
</ul>
<h4 id="Solution-暴力法"><a href="#Solution-暴力法" class="headerlink" title="Solution - 暴力法"></a>Solution - 暴力法</h4><pre><code class="c++">​class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) 
    {
        int n = 0;
        int sum_rain = 0;
        while (true)
        {
            int sum_wall_n = 0;
            n++;
            int left_wall = INT_MAX;
            int right_wall = INT_MIN;
            for (int i = 0; i &lt; height.size(); ++i)
            {
                if (height[i] &gt;= n)
                {
                    sum_wall_n++;

                    left_wall = min(i, left_wall);
                    right_wall = max(i, right_wall);
                }
            }
            if (sum_wall_n &gt;= 2)
            {
                int rain = right_wall - left_wall - 1 - (sum_wall_n - 2);
                sum_rain += rain;
            }
            else
            {
                break;
            }
        }
        return sum_rain;
    }
};</code></pre>
<p>一层一层判断, 当前层可存储雨水等于 当前层最左侧墙和当前层最右侧墙之间的数量 减去之间墙的数量 得到空位的数量 也就是雨水</p>
<p>时间复杂度O(n^2) 空间复杂度O(1). </p>
<p>另外一种暴力方法是每次计算当前位置最多积多少水, 上面的暴力方法是一层一层计算 这里是一列一列计算. 需要从当前位置分别向左和右遍历找到两边的最高墙<br>较矮的一边减去当前墙高度即为当前位置最多积累的雨水. 时间和空间复杂度同上</p>
<h4 id="Solution-动态规划-提前遍历出每个位置处的左边最高和右边最高"><a href="#Solution-动态规划-提前遍历出每个位置处的左边最高和右边最高" class="headerlink" title="Solution - 动态规划 提前遍历出每个位置处的左边最高和右边最高"></a>Solution - 动态规划 提前遍历出每个位置处的左边最高和右边最高</h4><pre><code class="c++">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) 
    {
        if (height.empty())
        {
            return 0;
        }

        const int HEI_SIZE = height.size();

        vector&lt;int&gt; left_max;
        vector&lt;int&gt; right_max;
        left_max.resize(HEI_SIZE);
        right_max.resize(HEI_SIZE);

        left_max[0] = height[0];
        right_max[HEI_SIZE - 1] = height[HEI_SIZE - 1];
        for (int i = 1; i &lt; HEI_SIZE; ++i)
        {
            left_max[i] = max(left_max[i - 1], height[i]);
        }
        for (int i = HEI_SIZE - 2; i &gt;= 0; --i)
        {
            right_max[i] = max(right_max[i + 1], height[i]);
        }

        int sum_rain_ret = 0;
        for (int i = 1; i &lt; HEI_SIZE; ++i)
        {
            int rain = min(left_max[i], right_max[i]) - height[i];
            sum_rain_ret += max(rain, 0);
        }
        return sum_rain_ret;
    }
};</code></pre>
<h4 id="Solution-递减栈"><a href="#Solution-递减栈" class="headerlink" title="Solution - 递减栈"></a>Solution - 递减栈</h4><pre><code class="c++">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) 
    {
        if (height.empty())
        {
            return 0;
        }

        int sum_rain_ret = 0;
        stack&lt;int&gt; height_stack;
        for (int i = 0; i &lt; height.size(); ++i)
        {
            while (!height_stack.empty() &amp;&amp; height[i] &gt;= height[height_stack.top()])
            {
                int last_wall = height_stack.top(); // last_wall的高度 小于 i的高度 也小于 llast_wall的高度
                height_stack.pop();

                if (height_stack.empty())
                {
                    break;
                }
                int llast_wall = height_stack.top(); // 这里不进行pop()是因为 
                // llast_wall的高度 小于 lllast_wall llast_wall 可能小于i的高度 这之间依然可能积水

                int distance = i - llast_wall - 1; // 间距
                int rain = min(height[llast_wall], height[i]) - height[last_wall];
                sum_rain_ret += rain * distance;
            }
            height_stack.push(i);
        }
        return sum_rain_ret;
    }
};</code></pre>
<p>代码比较难理解 结合<code>[4,2,0,3,2,5]</code>输入走一遍就好理解了 <code>ans=9</code></p>
<h4 id="Solution-双指针"><a href="#Solution-双指针" class="headerlink" title="Solution - 双指针"></a>Solution - 双指针</h4><pre><code class="c++">class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) 
    {
        if (height.empty())
        {
            return 0;
        }

        int left_max_sub = 0;
        int right_max_sub = height.size() - 1;

        int left = left_max_sub + 1;
        int right = right_max_sub - 1;

        int sum_rain_ret = 0;
        while (left &lt;= right)
        {
            if (height[left_max_sub] &lt; height[right_max_sub])
            {
                if (height[left] &lt; height[left_max_sub])
                {
                    sum_rain_ret += height[left_max_sub] - height[left];
                }
                else
                {
                    left_max_sub = left;
                }
                left++;
            }
            else
            {
                if (height[right] &lt; height[right_max_sub])
                {
                    sum_rain_ret += height[right_max_sub] - height[right];
                }
                else
                {
                    right_max_sub = right;
                }
                right--;
            }
        }
        return sum_rain_ret;
    }
};</code></pre>
<p>left_max_sub一定是left左边最高的墙, 但是right_max_sub不一定是left右边最高的墙. 也就是说右边的墙高度 大于等于 right_max_sub</p>
<p>所以当left_max_sub的墙的高度小于right_max_sub的时候 上面的问题就不存在了, 因为取决于更矮的墙</p>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2023 lsmg
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
