<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windows下Unity内存泄露排查</title>
      <link href="/2024/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-Windows%E4%B8%8BUnity%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%8E%92%E6%9F%A5/"/>
      <url>/2024/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-Windows%E4%B8%8BUnity%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目使用Unity开发，使用过程中可以明显内存有异常增长，所以排查了一下原因，做一下记录。</p><p>分三步描述</p><ol><li>寻找异常内存分配时的地址</li><li>寻找异常内存分配的堆栈</li><li>寻找对应的项目代码</li></ol><h1 id="寻找异常内存分配时的地址"><a href="#寻找异常内存分配时的地址" class="headerlink" title="寻找异常内存分配时的地址"></a>寻找异常内存分配时的地址</h1><h2 id="后台用的工具"><a href="#后台用的工具" class="headerlink" title="后台用的工具"></a>后台用的工具</h2><p>使用massif可以详细打印内存分配时的堆栈信息，但是没有Windows版本，询问GPT后得到了下面几个工具。</p><ol><li>Unity自带的Profile</li><li>vs2022</li><li>vmmap64</li></ol><h2 id="工具一，Unity自带的Profile"><a href="#工具一，Unity自带的Profile" class="headerlink" title="工具一，Unity自带的Profile"></a>工具一，Unity自带的Profile</h2><p>拍摄两个快照，发现内存异常增长的部分被划分到了Unknown，也不会显示堆栈所以需要换工具。</p><h2 id="工具二，vs2022"><a href="#工具二，vs2022" class="headerlink" title="工具二，vs2022"></a>工具二，vs2022</h2><p>Attach到Unity之后使用<strong>堆快照</strong>无法发现明显的内存增长，换工具。</p><h2 id="工具三vmmap64"><a href="#工具三vmmap64" class="headerlink" title="工具三vmmap64"></a>工具三vmmap64</h2><p>附加到Unity进程之后会自动拍摄快照，之后隔一段时间手动F5刷新一下。之后点击Timeline，选择对应的时间范围，可以看到这期间的内存新增申请。可以明显看到不是Heap在增长，而是Private Data在增长, 且都是相同的524284K，符合内存泄露的特征。</p><p>所以下一步需要找到不断申请的524284K的Private Data是谁申请的。</p><p>观察一下分配的虚拟内存是524284K，但这并不是实际占用的物理内存，最终占用的物理内存是258000K左右(另一部分保留了)。可以理解为这一块内存是逐渐从0K占用逐渐增长到了258000K。</p><p>每次F5刷新时，可以看到新的524284K大小的虚拟内存申请和对应的起始地址如0xA0000，之后Unity会顺序写入直到0xA0000+258000K。</p><p>了解到这一点之后，可以使用硬件断点设置写内存断点，当向指定地址写入时触发断点，进而查看堆栈。</p><p>所以需要一个内存地址，从上文可以看到内存是逐渐从0xA0000到0xA0000+258000K，所以拍摄快照时，如果内存使用到了0xA0000+1000K，则其必定会访问到0xA0000+10000K，所以对0xA0000+10000K下断点等待Unity的访问。</p><h1 id="寻找异常内存分配的堆栈"><a href="#寻找异常内存分配的堆栈" class="headerlink" title="寻找异常内存分配的堆栈"></a>寻找异常内存分配的堆栈</h1><h2 id="Windbg"><a href="#Windbg" class="headerlink" title="Windbg"></a>Windbg</h2><p>Attach到Unity进程，之后恢复Unity运行，返回vmmap64拍摄快照之后，立刻返回Windbg将Unity暂停。</p><p>回到vmmap64，查看最新的524284K的起始地址和已经使用大小，计算一个将来会访问的地址0xA123456。</p><p>回到windbg使用ba w 4 0xA123456 设置硬件断点，之后恢复Unity的运行，等到Unity访问到524284K内存块中的0xA123456时就会触发断点。此时就获得了向这块异常内存块写入数据时的堆栈。</p><h1 id="寻找对应的项目代码"><a href="#寻找对应的项目代码" class="headerlink" title="寻找对应的项目代码"></a>寻找对应的项目代码</h1><h2 id="查看Unity源码"><a href="#查看Unity源码" class="headerlink" title="查看Unity源码"></a>查看Unity源码</h2><p>找到对应的相关代码，是有开关的功能，查找开关的开启和关闭的接口。回到项目中找使用接口的代码，找到问题代码。</p><p>最终是因为开始Profile后没有关闭，导致Unity的Profile一直运行，内存一直增长。</p><h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><p>vmmap64中显示这块内存分配到了PrivateData, vs2022的堆快照无法发现问题, 暂不清楚Unity是如何使用内存的。</p>]]></content>
      
      
      <categories>
          
          <category> 个人记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CMake项目常见的编译加速方式汇总</title>
      <link href="/2024/11/%E4%BC%98%E5%8C%96-%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F2/"/>
      <url>/2024/11/%E4%BC%98%E5%8C%96-%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F2/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本文主要介绍CMake项目，在不改动或较小改动项目代码的情况下，如何减少编译时间。同时简要介绍其原理和使用场景。包含ccache，编译集群，CMake依赖优化，避免动态编译宏和UnityBuild。</p><h1 id="加快编译速度"><a href="#加快编译速度" class="headerlink" title="加快编译速度"></a>加快编译速度</h1><p>分通解，增量编译和全量编译三个方面来介绍。通解开启简单方便，增量编译减小项目重编范围。全量编译减少编译数量。</p><h2 id="通解"><a href="#通解" class="headerlink" title="通解"></a>通解</h2><h3 id="使用ccache"><a href="#使用ccache" class="headerlink" title="使用ccache"></a>使用ccache</h3><h4 id="原理及使用场景"><a href="#原理及使用场景" class="headerlink" title="原理及使用场景"></a>原理及使用场景</h4><p>ccache会缓存编译结果，在编译文件和编译宏未发生变化时，直接返回缓存的编译结果。</p><p>使用场景：在文件内容未变化时加速效果近乎100%，开启简单方便。</p><p>单机器，搭配make使用时，效果有限。</p><p>2024-12-02更新：了解到存在远程ccache。AB机器相同代码的情况下，如果A机器编译过一次传到远端，B机器编译时make判定全量编译，ccache会从远端下载A机器的编译结果。这时效果就很明显。</p><h4 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h4><p>使用<code>yum install ccache</code>安装</p><p>在CMake中添加如下内容开启ccache</p><pre><code class="CMake">find_program(CCACHE_PROGRAM ccache)if(CCACHE_PROGRAM)    message(STATUS &quot;Found ccache: ${CCACHE_PROGRAM}&quot;)    set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE_PROGRAM})    set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM})else()    message(WARNING &quot;ccache not found, proceeding without ccache&quot;)endif()</code></pre><p><strong>验证方式</strong></p><p><code>ccache -s</code>直接查看命中缓存次数。</p><pre><code class="sh">$ ccache -s                        cache directory                     /root/.ccachecache hit (direct)                   467cache hit (preprocessed)               2cache miss                          1009files in cache                      1701 这里是缓存命中的次数cache size                         656.0 Mbytesmax cache size                       1.0 Gbytes</code></pre><h3 id="使用编译集群"><a href="#使用编译集群" class="headerlink" title="使用编译集群"></a>使用编译集群</h3><h4 id="原理及使用场景-1"><a href="#原理及使用场景-1" class="headerlink" title="原理及使用场景"></a>原理及使用场景</h4><p>cpp项目编译时，每个源码文件都是一个编译单元，所以可以使用多线程并行编译。编译集群简单粗暴增加编译的并行数量。</p><p>使用场景：大规模编译时效果明显，收费。</p><h4 id="开启方式-1"><a href="#开启方式-1" class="headerlink" title="开启方式"></a>开启方式</h4><p>公司内部<a href="https://devops.woa.com/console/turbo/card-matrix/task/init" target="_blank" rel="noopener">devops</a>中就有编译加速，接入很简单。</p><h2 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h2><p>介绍如何减少不必要的编译项目。</p><h3 id="如何发现不必要的编译项目？"><a href="#如何发现不必要的编译项目？" class="headerlink" title="如何发现不必要的编译项目？"></a>如何发现不必要的编译项目？</h3><p>CMake生成后，使用Make编译时，会打印一些日志，如下所示。</p><pre><code class="txt">$ make MyExecutable              Scanning dependencies of target MyExecutable[ 33%] Building CXX object CMakeFiles/MyExecutable.dir/src/main.cpp.o[ 66%] Building CXX object CMakeFiles/MyExecutable.dir/src/Foo.cpp.o[100%] Linking CXX executable MyExecutable[100%] Built target MyExecutable</code></pre><p>从日志可以看到在编译MyExecutable时, Make将main.cpp.o和Foo.cpp.o重新编译，说明这两个文件所依赖的文件发生了变化。</p><p>将在<strong>依赖优化原理</strong>处介绍如何查看其依赖内容。这里只需要知道通过日志，可以观察本次编译的内容是否符合预期，如果发现不该编译的文件进行了编译，则可以查看其依赖内容，判断是否可以进行优化。</p><h3 id="CMake依赖优化"><a href="#CMake依赖优化" class="headerlink" title="CMake依赖优化"></a>CMake依赖优化</h3><h4 id="依赖优化原理"><a href="#依赖优化原理" class="headerlink" title="依赖优化原理"></a>依赖优化原理</h4><p>CMake生成之后会生成如下所示的depend.make文件</p><pre><code class="txt"># depend.makeCMakeFiles/MyExecutable.dir/src/Foo.cpp.o: ../src/Foo.cppCMakeFiles/MyExecutable.dir/src/Foo.cpp.o: src/version.hCMakeFiles/MyExecutable.dir/src/main.cpp.o: ../src/Foo.hCMakeFiles/MyExecutable.dir/src/main.cpp.o: ../src/main.cpp</code></pre><p>depend.make文件中描述了文件间的依赖情况。Foo.cpp.o依赖Foo.cpp和version.h。当version.h的<strong>修改时间戳</strong>变化时，会导致Foo.cpp.o重新生成。</p><p>如不想让冒号左侧的文件重新生成，则需要保证冒号右侧文件的<strong>修改时间戳</strong>不发生变化。如果内容无变化，但是<strong>修改时间戳</strong>发生变化，同样会导致左侧文件重新生成。</p><p>项目中存在的协议文件，需要转换后生成代码文件才能在代码中使用。如果转换时使用批量处理，会导致协议文件未变化，但代码文件发生了变化。代码文件发生变化后，所有依赖此代码文件的目标都会重新生成。</p><p>正确的做法应该是在协议文件发生变化时，再进行代码文件生成。手动识别较繁琐，正好CMake提供了此功能。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>编译时存在动态生成文件时</p><p>弊：需要理清生成文件的依赖关系</p><h4 id="开启方式-2"><a href="#开启方式-2" class="headerlink" title="开启方式"></a>开启方式</h4><pre><code class="CMake">set(XML_SRCS)file(GLOB CFG_FILES &quot;*.xml&quot;)set(GameResFile GameRes.h)# 主要命令，定义了产出文件GameResFile，生成脚本ConvertGameRes.sh，生成GameResFile所需的文件CFG_FILESadd_custom_command(OUTPUT ${GameResFile}        COMMAND bash ConvertGameRes.sh        DEPENDS ${CFG_FILES}        WORKING_DIRECTORY ${RES}/script/one)# 将所有动态生成文件添加到一个目标如XmlHeaders中list(APPEND XML_SRCS ${GameResFile})add_custom_target(XmlHeaders ALL DEPENDS ${XML_SRCS})# 需要使用GameRes.h的服务添加XmlHeaders为依赖add_dependencies(AServer XmlHeaders)</code></pre><p>编译AServer时会检查其依赖XmlHeaders是否有变化，XmlHeaders检查XML_SRCS即GameResFile是否需要重新生成。</p><p>当GameResFile的依赖文件CFG_FILES发生变化或产物GameResFile不存在时，调用ConvertGameRes.sh进行生成。</p><h3 id="避免使用频繁变化的编译宏"><a href="#避免使用频繁变化的编译宏" class="headerlink" title="避免使用频繁变化的编译宏"></a>避免使用频繁变化的编译宏</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在CMake中可以使用add_definitions添加编译宏，之后在代码文件中即可使用此宏获取对应的内容。如下所示打印编译时间。</p><pre><code class="txt"># 定义BUILD_TIME宏add_definitions(-DBUILD_TIME=\&quot;${BUILD_TIME}\&quot;)# 使用宏std::cout &lt;&lt; &quot;Current machine IP address: &quot; &lt;&lt; BUILD_TIME &lt;&lt; std::endl;</code></pre><p>编译宏会存储到如下CMake生成的flags.make中</p><pre><code class="make"># CMAKE generated file: DO NOT EDIT!# Generated by &quot;Unix Makefiles&quot; Generator, CMake Version 3.17# compile CXX with /usr/bin/c++CXX_DEFINES = -DBUILD_TIME=123</code></pre><p>每当编译宏发生变化时flags.make的修改时间也会发生变化。在build目录中搜索依赖此文件的内容，如下所示。</p><pre><code class="txt">$ grep -R &quot;flags.make&quot; ./*                   ./build.make:include CMakeFiles/MyExecutable.dir/flags.make./build.make:CMakeFiles/MyExecutable.dir/src/main.cpp.o: CMakeFiles/MyExecutable.dir/flags.make./build.make:CMakeFiles/MyExecutable.dir/src/Foo.cpp.o: CMakeFiles/MyExecutable.dir/flags.make</code></pre><p>可以看到main.cpp.o和Foo.cpp.o都依赖了flags.make。</p><p>所以每当cmake重新生成，宏内容发生变化时，flags.make也会发生变化，导致依赖flags.make的文件重新生成。</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>项目存在变化的编译宏时使用。</p><h4 id="开启方式-3"><a href="#开启方式-3" class="headerlink" title="开启方式"></a>开启方式</h4><pre><code class="txt">// 文件CompileVersion.cpp.in#define _BUILDDATE &quot;@BUILDDATE@&quot;#define _BUILDIP &quot;@BUILDIP@&quot;#include &quot;CompileVersion.h&quot;std::string GetCompileVersionStr(){    std::string strVersion;    strVersion += &quot;\033[40;32mSo Build Date   \033[0m: &quot;_BUILDDATE&quot;\n&quot;;    strVersion += &quot;\033[40;32mSo Build Host   \033[0m: &quot;_BUILDIP&quot;\n&quot;;    return strVersion;}// 文件 CompileVersion.h#pragma once#include &lt;string&gt;std::string GetCompileVersionStr();// 文件 CMakeconfigure_file(CompileVersion.cpp.in CompileVersion.cpp)</code></pre><p>configure_file会将模板CompileVersion.cpp.in中@BUILDDATE@替换成CMake中BUILDDATE变量。同时将产出放在cpp中，对外提供h文件。这样当版本信息发生变化时仅会编译CompileVersion.cpp</p><h2 id="全量编译"><a href="#全量编译" class="headerlink" title="全量编译"></a>全量编译</h2><h3 id="使用UnityBuild"><a href="#使用UnityBuild" class="headerlink" title="使用UnityBuild"></a>使用UnityBuild</h3><h4 id="原理及使用场景-2"><a href="#原理及使用场景-2" class="headerlink" title="原理及使用场景"></a>原理及使用场景</h4><p>默认的编译方式会逐个处理每个编译文件，如果A.cpp和B.cpp都include了common.h，编译A.cpp和B.cpp时common.h会被处理两次。将A.cpp和B.cpp合并为一个编译单元后，common.h仅会被处理一次。</p><p>弊：命名空间污染，重新编译范围扩大，同时手动组织比自动组织效果更好。</p><h4 id="自动组织开启方式-cmake3-16添加"><a href="#自动组织开启方式-cmake3-16添加" class="headerlink" title="自动组织开启方式 cmake3.16添加"></a>自动组织开启方式 cmake3.16添加</h4><pre><code class="CMake"># CMake中打开UnityBuildSET(CMAKE_UNITY_BUILD OFF)# 设置成一个文件所需的数量set(CMAKE_UNITY_BUILD_BATCH_SIZE 16）# 关闭指定文件的UnityBuild，使其单独编译set_source_files_properties(A.cpp PROPERTIES SKIP_UNITY_BUILD_INCLUSION ON)</code></pre><h4 id="手动组织开启方式-cmake3-18添加"><a href="#手动组织开启方式-cmake3-18添加" class="headerlink" title="手动组织开启方式 cmake3.18添加"></a>手动组织开启方式 cmake3.18添加</h4><p>这里项目未实际使用，直接粘贴的<a href="https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD_MODE.html#prop_tgt:UNITY_BUILD_MODE" target="_blank" rel="noopener">文档</a>的内容。</p><pre><code class="CMake">add_library(example_library            source1.cxx            source2.cxx            source3.cxx            source4.cxx)set_target_properties(example_library PROPERTIES                      UNITY_BUILD_MODE GROUP                      )set_source_files_properties(source1.cxx source2.cxx source3.cxx                            PROPERTIES UNITY_GROUP &quot;bucket1&quot;                            )set_source_files_properties(source4.cxx                            PROPERTIES UNITY_GROUP &quot;bucket2&quot;                            )</code></pre><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>项目中未使用的内容</p><ol><li>编译速度-使用PCH，使用后未发现明显的加速效果。</li><li>链接速度-使用多线程链接器，加快链接速度，目前链接很快，倾向于不做改动。</li></ol><h1 id="加快部署速度"><a href="#加快部署速度" class="headerlink" title="加快部署速度"></a>加快部署速度</h1><p>简单的快速部署方式：常用的SSH工具由于权限一般不能使用，问GPT生成一个带账号密码以及能够接受文件的HTTPServer，功能只需要在接受文件并校验后，替换文件，执行服务器重启脚本。可以将脚本输出放到HTTP的回包中，上传文件和接收文件时进行压缩和解压缩，降低对带宽的需求。</p><p>需要部署服务器时可以通过curl命令直接上传文件后触发部署。</p>]]></content>
      
      
      <categories>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMAKE&amp;Make</title>
      <link href="/2024/07/CPP-CMAKE/"/>
      <url>/2024/07/CPP-CMAKE/</url>
      
        <content type="html"><![CDATA[<h1 id="aux-source-directory"><a href="#aux-source-directory" class="headerlink" title="aux_source_directory"></a>aux_source_directory</h1><p>今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.<br>可能会存在一些问题</p><p><a href="https://cmake.org/cmake/help/latest/command/aux_source_directory.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/latest/command/aux_source_directory.html</a></p><pre><code class="cmake"># 必须片段# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo1)# 指定生成目标add_executable(Demo main.cc)# 多文件# 如果一味地在add_executable中添加源文件, 会导致太长了# 将dir目录中所有源文件保存在变量中aux_source_directory(. DIR_SOURCE)# 将变量赋值给Demoadd_executable(Demo ${DIR_SOURCE})# 多文件多目录# 需要在主目录和子文件夹中都编写CMakeLists.txt文件# 主文件添加子目录add_subdirectory(dir1)# 添加链接库target_link_libraries(Demo Foo)# dir1目录中aux_source_directory(. DIR1_SOURCE)# 生成链接库 Foo 在主文件中添加即可add_library(Foo ${DIR1_SOURCE})</code></pre><h1 id="CMAKE和MAKE之间的区别"><a href="#CMAKE和MAKE之间的区别" class="headerlink" title="CMAKE和MAKE之间的区别"></a>CMAKE和MAKE之间的区别</h1><p><a href="https://my.oschina.net/xunxun/blog/86781" target="_blank" rel="noopener">博客原文</a></p><p>自己的理解<br>通过为cmake编写CMakeList文件, cmake即可按照规则生成相应的Makefile文件<br>然后make读取Makefile文件就可以按照规则将源代码编译</p><p>总的来说cmake就是为make生成Makefile文件, (Makefile文件可以自己编写, 也可以用Cmake生成)<br>应该是编写CMakeList的代码量少于或者简单于Makefile, 简化了操作</p><h1 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a>find_package</h1><p><a href="https://zhuanlan.zhihu.com/p/97369704" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/97369704</a></p><p><a href="https://www.jianshu.com/p/a0915895dbbc" target="_blank" rel="noopener">https://www.jianshu.com/p/a0915895dbbc</a></p><p>find_package 存在两个模式</p><ul><li>module模式</li><li>config模式</li></ul><pre><code class="cmake">find_package(GLEW REQUIRED) # 先module模式再config模式find_package(GLEW REQUIRED CONFIG) # 使用config模式</code></pre><p><strong>module模式</strong></p><pre><code class="cmake">find_package(GLEW REQUIRED)if (GLEW_FOUND)    message(&quot;cannot find glew&quot;)endif()</code></pre><p>通过上述命令查找glew库，首先会去cmake的modules目录下查找对应的cmake文件。</p><p>glew对应的cmake文件为<code>FindGLEW.cmake</code></p><pre><code class="txt">C:/Application/Code/cmake-3.19.0-rc2-win64-x64/share/cmake-3.19/Modules/FindGLEW.cmake</code></pre><p><strong>config模式</strong></p><p>如果module模式对应的cmake文件不存在则启动config模式。</p><p>config模式会在如下目录搜索对应的配置文件<code>glew-config.cmake</code>或<code>GLEWConfig.cmake</code></p><p>W代表windows平台 U代表unix平台</p><pre><code class="txt">&lt;prefix&gt;/                                                       (W)&lt;prefix&gt;/(cmake|CMake)/                                         (W)&lt;prefix&gt;/&lt;name&gt;*/                                               (W)&lt;prefix&gt;/&lt;name&gt;*/(cmake|CMake)/                                 (W)&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/                 (U)&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/                       (U)&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/(cmake|CMake)/         (U)&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/         (W/U)&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/               (W/U)&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/(cmake|CMake)/ (W/U)</code></pre><p>prefix生成规则如下</p><ol><li>查找<code>GLEW_ROOT</code>的cmake变量</li><li>使用命令行<code>cmake -DCMAKE_PREFIX_PATH=/tmp/test</code></li><li>特定的cmake变量如<code>GLEW_DIR</code> <code>CMAKE_PREFIX_PATH</code></li></ol><pre><code class="cmake"># glew-config.cmakefind_path(GLEW_INCLUDE_DIR glew/include/)find_library(GLEW_LIBRARY NAMES glew32 PATHS glew/lib/Release/x64)if (GLEW_INCLUDE_DIR AND GLEW_LIBRARY)    set(GLEW_FOUND TRUE)endif()</code></pre><h1 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h1><pre><code class="shell">## CMake根目录生成Makefile# 使用all走这里all: cmake_check_build_system    $(CMAKE_COMMAND) -E cmake_progress_start /tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles /tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles/progress.marks    $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 all    $(CMAKE_COMMAND) -E cmake_progress_start /tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles 0.PHONY : all# 直接使用目标untitled4untitled4: cmake_check_build_system    $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 untitled4.PHONY : untitled4## CMakeFiles/Makefile2# Convenience name for target.untitled4: CMakeFiles/untitled4.dir/rule.PHONY : untitled4# Build rule for subdir invocation for target.CMakeFiles/untitled4.dir/rule: cmake_check_build_system    $(CMAKE_COMMAND) -E cmake_progress_start /tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles 3    $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 CMakeFiles/untitled4.dir/all    $(CMAKE_COMMAND) -E cmake_progress_start /tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles 0.PHONY : CMakeFiles/untitled4.dir/rule# All Build rule for target.CMakeFiles/untitled4.dir/all:    $(MAKE) $(MAKESILENT) -f CMakeFiles/untitled4.dir/build.make CMakeFiles/untitled4.dir/depend    $(MAKE) $(MAKESILENT) -f CMakeFiles/untitled4.dir/build.make CMakeFiles/untitled4.dir/build    @$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles --progress-num=1,2,3 &quot;Built target untitled4&quot;.PHONY : CMakeFiles/untitled4.dir/all##Shell# 生成depend$ make -f CMakeFiles/untitled4.dir/build.make CMakeFiles/untitled4.dir/dependScanning dependencies of target untitled4# 变更文件./CMakeFiles/untitled4.dir/depend.internal./CMakeFiles/untitled4.dir/depend.make./CMakeFiles/untitled4.dir/CXX.includecache# 构建$make -f CMakeFiles/untitled4.dir/build.make CMakeFiles/untitled4.dir/build[100%] Building CXX object CMakeFiles/untitled4.dir/Base.cpp.o[100%] Linking CXX executable untitled4</code></pre><pre><code class="shell"># ./CMakeFiles/untitled4.dir/depend.internalCMakeFiles/untitled4.dir/Base.cpp.o /tmp/tmp.3r11cPofBP/Base.cpp /tmp/tmp.3r11cPofBP/Base.hCMakeFiles/untitled4.dir/main.cpp.o /tmp/tmp.3r11cPofBP/Base.h /tmp/tmp.3r11cPofBP/main.cpp# ./CMakeFiles/untitled4.dir/depend.makeCMakeFiles/untitled4.dir/Base.cpp.o: ../Base.cppCMakeFiles/untitled4.dir/Base.cpp.o: ../Base.hCMakeFiles/untitled4.dir/main.cpp.o: ../Base.hCMakeFiles/untitled4.dir/main.cpp.o: ../main.cpp</code></pre><pre><code class="shell"># 生成依赖CMakeFiles/untitled4.dir/depend:    cd /tmp/tmp.3r11cPofBP/cmake-build-debug &amp;&amp; $(CMAKE_COMMAND) -E cmake_depends &quot;Unix Makefiles&quot; /tmp/tmp.3r11cPofBP /tmp/tmp.3r11cPofBP /tmp/tmp.3r11cPofBP/cmake-build-debug /tmp/tmp.3r11cPofBP/cmake-build-debug /tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles/untitled4.dir/DependInfo.cmake --color=$(COLOR).PHONY : CMakeFiles/untitled4.dir/depend# 构建CMakeFiles/untitled4.dir/build: untitled4.PHONY : CMakeFiles/untitled4.dir/builduntitled4: CMakeFiles/untitled4.dir/main.cpp.ountitled4: CMakeFiles/untitled4.dir/Base.cpp.ountitled4: CMakeFiles/untitled4.dir/build.makeuntitled4: CMakeFiles/untitled4.dir/link.txt    @$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) &quot;Linking CXX executable untitled4&quot;    $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/untitled4.dir/link.txt --verbose=$(VERBOSE)CMakeFiles/untitled4.dir/main.cpp.o: CMakeFiles/untitled4.dir/flags.makeCMakeFiles/untitled4.dir/main.cpp.o: ../main.cpp    @$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) &quot;Building CXX object CMakeFiles/untitled4.dir/main.cpp.o&quot;    /usr/bin/g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/untitled4.dir/main.cpp.o -c /tmp/tmp.3r11cPofBP/main.cpp</code></pre><p>CMake识别变更和重新编译，是通过比对冒号左右两个文件的最后修改时间。<br>A：B A依赖B，如果B的修改时间晚于A说明A需要重新构建。</p><pre><code class="cmake">set(CurrentProtoGenP2P ${P2P_OUT_PATH_PATH}/${ProtoName}.proto.tars_Api.p2p.h)add_custom_command(OUTPUT ${CurrentProtoGenP2P}  COMMAND sh -c &quot;python2 ${P2P_SELECT_AND_BUILD} ${P2P_OUT_PATH_PATH} ${AllDirs} ${PROTOBUF_ROOT}/include/include ${Protoc} ${ProtoFile}&quot;  DEPENDS ${Protoc} ${ProtoFile}  WORKING_DIRECTORY ${Dir})list(APPEND Srcs ${CurrentProtoGenP2P})</code></pre><h1 id="include-directory"><a href="#include-directory" class="headerlink" title="include_directory"></a>include_directory</h1><p>搜寻头文件的顺序</p><ol><li>&lt;&gt; 搜索顺序: -I指定的路径, 搜索-isystem, 系统路径, -idirafter</li><li>“” 搜索顺序: 当前路径, 搜索-iquote, -I指定的路径, 搜索-isystem, 系统路径, -idirafter</li><li>CMake中include_directory对应-I</li></ol><pre><code class="CMake">function(add_unique list_var element)   # 获取当前列表   set(current_list ${${list_var}})   # 检查元素是否已经在列表中   list(FIND current_list ${element} index)   if(index EQUAL -1)      # 如果元素不在列表中，添加它      list(APPEND current_list ${element})      # 更新原始列表变量      set(${list_var} ${current_list} PARENT_SCOPE)   endif()endfunction()foreach(include_dir ${include_dirs})   message(&quot;add dir ${include_dir}&quot;)   include_directories(${include_dir})endforeach()function(include_directories_recursively base_dir dst)    # 获取当前目录的所有子目录    set(include_dirs)    file(GLOB_RECURSE header_files &quot;${base_dir}/*.h&quot; &quot;${base_dir}/*.hpp&quot;)    foreach(header_file ${header_files})        get_filename_component(header_dir ${header_file} DIRECTORY)        add_unique(include_dirs &quot;-idirafter ${header_dir}&quot;)    endforeach()    string(REPLACE &quot;;&quot; &quot; &quot; include_dirs &quot;${include_dirs}&quot;)    set(${dst} &quot;${${dst}} ${include_dirs}&quot; PARENT_SCOPE)endfunction()set(DIR_AFTER)include_directories_recursively(${CMAKE_CURRENT_SOURCE_DIR} DIR_AFTER)include_directories_recursively(${PUBINCLUDE} DIR_AFTER)message(&quot;${DIR_AFTER}&quot;)</code></pre><ol><li>idirafter 能不能起作用</li><li>为什么Make没问题</li></ol><pre><code class="CMake">function(add_unique list_var element)    # 获取当前列表    set(current_list ${${list_var}})    # 检查元素是否已经在列表中    list(FIND current_list ${element} index)    if(index EQUAL -1)        # 如果元素不在列表中，添加它        list(APPEND current_list ${element})        # 更新原始列表变量        set(${list_var} ${current_list} PARENT_SCOPE)    endif()endfunction()function(include_directories_recursively base_dir dst)    # 获取当前目录的所有子目录    set(include_dirs)    file(GLOB_RECURSE header_files &quot;${base_dir}/*.h&quot; &quot;${base_dir}/*.hpp&quot;)    foreach(header_file ${header_files})        get_filename_component(header_dir ${header_file} DIRECTORY)        add_unique(include_dirs &quot;-idirafter ${header_dir}&quot;)    endforeach()    string(REPLACE &quot;;&quot; &quot; &quot; include_dirs &quot;${include_dirs}&quot;)    set(${dst} &quot;${${dst}} ${include_dirs}&quot; PARENT_SCOPE)endfunction()set(DIR_AFTER)include_directories_recursively(${CMAKE_CURRENT_SOURCE_DIR} DIR_AFTER)include_directories_recursively(${PUBINCLUDE} DIR_AFTER)message(&quot;${DIR_AFTER}&quot;)set(SVR_NAME &quot;NewMainSvr&quot;)message(&quot;server name ${SVR_NAME}&quot;)file(GLOB_RECURSE PRJ_SRCS &quot;*.cpp&quot; &quot;*.c&quot;)#添加目标add_library(${SVR_NAME} SHARED ${PRJ_SRCS})#链接库target_link_libraries(${SVR_NAME} ${COMMON_LIBS})target_link_libraries(${SVR_NAME} &quot;i18n&quot;)set_target_properties(${SVR_NAME} PROPERTIES COMPILE_FLAGS &quot;-D__HIGH_PERFORMANCE__ ${COMMON_CPP_FLAGS} ${DIR_AFTER}&quot;)</code></pre><h1 id="CMAKE优化依赖生成"><a href="#CMAKE优化依赖生成" class="headerlink" title="CMAKE优化依赖生成"></a>CMAKE优化依赖生成</h1><pre><code class="CMake"># 生成file(GLOB CFG_FILES &quot;XML&quot;)foreach (CFG_FILE ${CFG_FILES})    get_filename_component(FILE_NAME ${CFG_FILE} NAME_WE)    set(OUT_H ${RES_INCLUDE}/${FILE_NAME}.h)    message(${OUT_H})    add_custom_command(OUTPUT ${OUT_H}            COMMAND bash ConvertCfg.sh ${CFG_FILE}            DEPENDS ${CFG_FILE}            WORKING_DIRECTORY ${RES}/script/one    )    list(APPEND XML_SRCS ${OUT_H})endforeach ()add_custom_target(XmlHeaders ALL DEPENDS ${XML_SRCS})# 添加依赖add_dependencies(${SVR_NAME} XmlHeaders)</code></pre><h1 id="CMake打进版本信息"><a href="#CMake打进版本信息" class="headerlink" title="CMake打进版本信息"></a>CMake打进版本信息</h1><pre><code class="CMake"># C.h.in#define BUILD_STAMP &quot;@BUILDDATE@&quot;# CMakeexecute_process(                COMMAND date +%F_%R:%S                OUTPUT_VARIABLE BUILDDATE                OUTPUT_STRIP_TRAILING_WHITESPACE)# 会自动填充.h.in中的值configure_file(C.h.in C.h)# 项目中include .h使用宏即可</code></pre><p><strong>不能使用add_definitions -D宏来打包, 否则每次触发cmake时, 宏的改变会导致全体重新编译.</strong></p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何更好的添砖加瓦2</title>
      <link href="/2024/06/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E7%89%882/"/>
      <url>/2024/06/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E7%89%882/</url>
      
        <content type="html"><![CDATA[<p>本文是2024年上半年的经验总结</p><h2 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h2><p><strong>学习新东西和分享内容虽好, 但要避免乌龙</strong></p><p>实验的场景有问题, 最后得出的结论确实想要的, 分享出去之后才发现场景的问题, 导致结论也是错的.</p><p><strong>工具最好配备文档, 继续常见问题</strong></p><p>写了工具之后, 其他人使用过程中免不了有疑问, 如果逐一回答则会耗费精力, 所以最好把常见的写到文档中, 其他人有问题, 先让对面去看文档.</p><p><strong>分享出去的工具, 在精不在多</strong></p><p>多了之后, 不精的工具会耗费精力去答疑和修改, 所以分享就要分享好用的, 而不是随手写的就分享出去.</p><p><strong>多多钻研和发现值得思考的内容</strong></p><ol><li>编译出的elf文件为什么这么大? elf文件中有哪些内容? 这些内容中哪些可以减小? 如何减小? 减小了有何影响, 这里搞完之后收获还是有的.</li><li>elf文件变大之后, gdb分析变慢, 对gdb使用火焰图发现是在解析符号表, 所以才会卡慢.</li><li>服务器占用xx内存, 这些内存占用必定有他的原因和使用位置, 如何对这些进行分析整理?</li></ol><p><strong>总迭代时间超过半年的编译发布流水线的更新记录和反思</strong></p><p>编译发布流水线经过多次修改, 有的修改甚至到了重写地步, 总结发现下为什么没有一开始就能发现这些问题.</p><ol><li>初版直接把本地的编译命令放到了流水线的shell脚本中, 开了超多条流水线, 每条都写了很多代码</li><li>写了个超长的函数更新各个submodule, 流水线的更新并不好用</li><li>要求自动更新服务器, 修改编译上传脚本将版本号保存到本地, 修改发布脚本支持读取</li><li>要求能够发布IDC的版本, 将原本初版的流水线完全拷贝了一份用来编译release版本, 区分了space导致release和debug无法混发到腾讯云</li><li>要求支持指定submodule的分支发布, 发现改所有的流水线代码比较麻烦, <strong>统一了更新部分</strong></li><li>发布重试的要求, <strong>统一了构建部分</strong></li><li>要求增加海外部分, 如果再开一条流水线将会导致数量继续增加. 直接把构建部分全写到了脚本来控制.</li><li>上传有失败, 增加了上传重试</li><li>分支有/增加了转义</li><li>流水线加上了code_branch分组功能, 防止冲突.</li><li>用分支名命名感觉还是有点问题, <strong>目前看还能抗住</strong></li><li>异常错误处理, 编译会有编译加速失败, <strong>这个还没加重试</strong></li><li>目前一个发布环境也会有多套了, <strong>不能再只用idc, test当做版本号标识了</strong>.</li><li>一步到位, 把相关信息作为msg发到平台, 更新的时候不再读取本地版本号. 不使用花里胡哨的版本号标识, 直接使用构建信息.</li></ol><p><strong>多多学习和消化公司已有的学习资源</strong></p><ol><li>Q-Learning和KM内容太多了, 可以用来扩充知识面, 还能选取感兴趣的点进行深入学习.</li><li>还可以看看已经公开的晋升文档, 看看其他人搞了什么内容, 从中选取自己感兴趣的点.</li></ol><p><strong>平时遇到的问题尽量都进行记录</strong></p><p>及时总结反思，发现问题，尽量避免后续再次出现。对自己每周每月的提升有所了解。</p><p><strong>晨会</strong></p><p>晨会同步进度. 非业务负责的也能听懂做了什么, 还剩余哪些没做。有风险及时同步，为什么有风险, 原因是什么。</p><p><strong>联调</strong></p><p>及时了解相关关系人员, 自己功能提前完成后, 即使了解和催促下相关人员, 提前联调后释放出来，防止处理其他问题时还需要抽时间联调，打乱节奏。</p><p><strong>结合业务学习技术</strong></p><p>只是想着学技术容易找不到发力点，同时学习之后不便于验证。但是结合业务学习，就有发力点，同时可以尝试进行验证。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p><strong>详细了解需求的背景和要求后再动手</strong></p><ol><li>防止一句话需求的理解存在偏差</li><li>防止实现错误, 最后还要进行修改, 如果带到了测试环境甚至线上, 修改的难度和不稳定会越来越大.</li></ol><p><strong>需求做到位即可, 防止做了没必要且无用的内容</strong></p><p>需求中一个功能本来可以用简单的方法实现, 却用了复杂的实现方式, 最后反而效果不好, 得不偿失.</p><p><strong>需求实现成本高的地方和产品沟通</strong></p><p>看看能不能换成本较低, 效果略微降低的方案.</p><p><strong>服务器命名问题</strong></p><p>新加了一大批服务器, 起初我想通过命名给这些服务器赋予功能, 但是会导致服务器的名字难以记忆, 最后分离了开来, 命名使用了简单的方式, 至于服务器的功能则额外加了一张功能表.</p><p><strong>加深自己参与的服务器各个模块的理解</strong></p><p>这样才能在商定各个服务器分工的时候, 给出合理的解释, 方便进行快速的分工.</p><p><strong>开工前的协议制定</strong></p><p>优先和其他开发定协议，协议一次性定好之后汇总发布出来，单条发送不便于查看。</p><p><strong>处理需求时进行记录</strong></p><p>配置和代码是分离的，需要记录需要改哪些配置，防止后续代码提交后存在配置未提交。</p>]]></content>
      
      
      <categories>
          
          <category> 个人记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>massif使用</title>
      <link href="/2024/04/Linux-massif/"/>
      <url>/2024/04/Linux-massif/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>现在内存量大管饱, 优化几兆甚至几十兆, 大部分时候收益不高. 但同一个实例创造大量副本, 且这些副本共存的情况下(1000个), 优化单个实例内存的收益就会上升(1MBx1000=1GB).</p><p>进行内存优化, 首先要知晓一个实例都涉及了哪些内存分配, 由于涉及位置多和熟悉程度等原因, 导致人肉观察效率很低, 所以需要借助工具.</p><p>工具需要能够详细记录一个实例每次申请的内存大小和申请位置, 将申请大小降序排序之后, 能够方便的找到优化起来收益较大的点.</p><h1 id="massif"><a href="#massif" class="headerlink" title="massif"></a>massif</h1><p>massif就是这样的工具</p><p>样例代码</p><pre><code class="cpp">$ cat m1.cpp     #include &lt;map&gt;#include &lt;thread&gt;int foo(){    std::map&lt;int, int&gt; m;    for (int i = 0; i &lt; 1000; ++i)    {        m[i] = i;    }    return 0;}int main(){    std::thread t([](){foo();});    t.join();    return 0;}</code></pre><p>如下是massif导出的结果, 可以看到有栈被打印出来, 后面会对这些内容做简要说明</p><pre><code class="txt">$ cat 2.ms  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)--------------------------------------------------------------------------------  0      3,994,759           56,656           40,632        16,024            0#### new分配了40,632B内存 ####71.72% (40,632B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.#### 第一个组成部分 40,000B 用 -&gt; 开头-&gt;70.60% (40,000B) 0x4037D5: __gnu_cxx::new_allocator&lt;std::_Rb_tree_node&lt;std::pair&lt;int const, int&gt; &gt; &gt;::allocate(unsigned long, void const*) (new_allocator.h:104)| -&gt;70.60% (40,000B) 0x403401: std::_Rb_tree&lt;int, std::pair&lt;int const, int&gt;, std::_Select1st&lt;std::pair&lt;int const, int&gt; &gt;, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;::_M_get_node() (stl_tree.h:370)|   -&gt;70.60% (40,000B) 0x402B80: std::_Rb_tree_node&lt;std::pair&lt;int const, int&gt; &gt;* std::_Rb_tree&lt;int, std::pair&lt;int const, int&gt;, std::_Select1st&lt;std::pair&lt;int const, int&gt; &gt;, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;::_M_create_node&lt;std::piecewise_construct_t const&amp;, std::tuple&lt;int const&amp;&gt;, std::tuple&lt;&gt; &gt;(std::piecewise_construct_t const&amp;, std::tuple&lt;int const&amp;&gt;&amp;&amp;, std::tuple&lt;&gt;&amp;&amp;) (stl_tree.h:403)|     -&gt;70.60% (40,000B) 0x402913: std::_Rb_tree_iterator&lt;std::pair&lt;int const, int&gt; &gt; std::_Rb_tree&lt;int, std::pair&lt;int const, int&gt;, std::_Select1st&lt;std::pair&lt;int const, int&gt; &gt;, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;::_M_emplace_hint_unique&lt;std::piecewise_construct_t const&amp;, std::tuple&lt;int const&amp;&gt;, std::tuple&lt;&gt; &gt;(std::_Rb_tree_const_iterator&lt;std::pair&lt;int const, int&gt; &gt;, std::piecewise_construct_t const&amp;, std::tuple&lt;int const&amp;&gt;&amp;&amp;, std::tuple&lt;&gt;&amp;&amp;) (stl_tree.h:1669)|       -&gt;70.60% (40,000B) 0x40265D: std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;::operator[](int const&amp;) (stl_map.h:465)|         -&gt;70.60% (40,000B) 0x40134E: foo() (m1.cpp:8)|           -&gt;70.60% (40,000B) 0x4013AE: main::{lambda()|             -&gt;70.60% (40,000B) 0x402243: void std::_Bind_simple&lt;main::{lambda()|               -&gt;70.60% (40,000B) 0x40219A: std::_Bind_simple&lt;main::{lambda()|                 -&gt;70.60% (40,000B) 0x402133: std::thread::_Impl&lt;std::_Bind_simple&lt;main::{lambda()|                   -&gt;70.60% (40,000B) 0x40ED4EF: execute_native_thread_routine (thread.cc:84)|                     -&gt;70.60% (40,000B) 0x5545EA4: start_thread (pthread_create.c:307)|                       -&gt;70.60% (40,000B) 0x5858B0C: clone (in /usr/lib64/libc-2.17.so)|  #### 第二个组成部分 576B 用 -&gt; 开头                       -&gt;01.02% (576B) 0x4012784: allocate_dtv (dl-tls.c:317)| -&gt;01.02% (576B) 0x4012784: _dl_allocate_tls (dl-tls.c:533)|   -&gt;01.02% (576B) 0x554687B: allocate_stack (allocatestack.c:539)|     -&gt;01.02% (576B) 0x554687B: pthread_create@@GLIBC_2.2.5 (pthread_create.c:447)|       -&gt;01.02% (576B) 0x40ED73E: __gthread_create (gthr-default.h:662)|         -&gt;01.02% (576B) 0x40ED73E: std::thread::_M_start_thread(std::shared_ptr&lt;std::thread::_Impl_base&gt;) (thread.cc:142)|           -&gt;01.02% (576B) 0x4014CD: std::thread::thread&lt;main::{lambda()|             -&gt;01.02% (576B) 0x4013CC: main (m1.cpp:15)|               -&gt;00.10% (56B) in 1+ places, all below ms_print&#39;s threshold (01.00%)</code></pre><p>使用grep提取实际分配内存的大小和位置并进行排序, 可以看到0x4037D5分配了40000B的内存, 回上文中查找, 找到是<code>0x40134E: foo() (m1.cpp:8)</code>触发的分配.</p><pre><code class="txt">$ grep &quot;^-&gt;&quot; 2.ms | grep -v &quot;all below ms_print&quot; | awk -F &#39;[():]&#39; &#39;{gsub(&quot;,&quot;,&quot;&quot;);print $2,$3}&#39; | sort -nr40000B  0x4037D5576B  0x4012784</code></pre><p>假设上文是一个副本分配的内存, 再进行一次副本创建则会得到下面的结果.</p><pre><code class="txt">$ grep &quot;^-&gt;&quot; 3.p | grep -v &quot;all below ms_print&quot; | awk -F &#39;[():]&#39; &#39;{gsub(&quot;,&quot;,&quot;&quot;);print $2,$3}&#39; | sort -nr80000B  0x4037D5576B  0x4012784</code></pre><p>用两次0x4037D5位置的内存相减, 差值就是一个副本所需要的大小</p><p>将所有差值排序后 就是一个副本涉及的新增的内存, 可以根据地址从大到小逐一排查是否可以进行优化(如副本见共享同一份数据, 避免多次创建)</p><pre><code class="txt">40000B 0x4037D5</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><pre><code class="sh"># threshold默认是1, 越小记录的精度越高, 如果过大会导致记录被合并无法展示细节, 这里指定的0,001# m1是二进制名称 valgrind --tool=massif --threshold=0.001 ./m1</code></pre><p>问题: massif默认会记录程序从启动开始所有的内存, 且是基于无法控制且数量有限的快照机制</p><ol><li>如果服务器需要较长时间初始化, 则会在初始化时消耗掉所有快照, 无法记录后续副本创建的分配.</li><li>快照是无法控制的, 无法方便的获得副本创建前后的内存消耗</li></ol><p>所以需要手动进行快照</p><pre><code class="sh"># A窗口$ valgrind --tool=massif --threshold=0.001 --vgdb=yes --vgdb-error=0 ./m1==28781== Massif, a heap profiler==28781== Copyright (C) 2003-2017, and GNU GPL&#39;d, by Nicholas Nethercote==28781== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info==28781== Command: ./m1==28781== ==28781== (action at startup) vgdb me ... ==28781== ==28781== TO DEBUG THIS PROCESS USING GDB: start GDB like this==28781==   /path/to/gdb ./m1==28781== and then give GDB the following command==28781==   target remote | /usr/local/libexec/valgrind/../../bin/vgdb --pid=28781==28781== --pid is optional if only one valgrind process is running==28781== </code></pre><pre><code class="sh"># B窗口gdb ./m1# 输入上文的提示target remote | /usr/local/libexec/valgrind/../../bin/vgdb --pid=28781# 副本创建之前下断点b 6# 运行r# 此时来到副本创建之前的位置# 手动拍摄快照记录到1.mmonitor detailed_snapshot 1.m # 再次运行# 此时将要创建第二个副本, 也就意味着第一个副本创建完毕# 手动拍摄快照记录到2.mmonitor detailed_snapshot 2.m # 杀掉valgrindmonitor v.kill# 退出gdbquit</code></pre><p>对快照的原始数据进行处理, 就得到了开头的2.ms文件和格式化后的文件, 使用Excel对1.mp和2.mp相同地址的部分计算差值即可.</p><pre><code class="sh">ms_print 1.m &gt; 1.msms_print 2.m &gt; 2.msgrep &quot;^-&gt;&quot; 1.ms | grep -v &quot;all below ms_print&quot; | awk -F &#39;[():]&#39; &#39;{gsub(&quot;,&quot;,&quot;&quot;);print $2,$3}&#39; | sort -nr &gt; 1.mpgrep &quot;^-&gt;&quot; 2.ms | grep -v &quot;all below ms_print&quot; | awk -F &#39;[():]&#39; &#39;{gsub(&quot;,&quot;,&quot;&quot;);print $2,$3}&#39; | sort -nr &gt; 2.mp</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常事UP</title>
      <link href="/2024/03/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E5%B8%B8%E4%BA%8BUP/"/>
      <url>/2024/03/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E5%B8%B8%E4%BA%8BUP/</url>
      
        <content type="html"><![CDATA[<h1 id="旅游想省1000多块钱买了2号回程机票，后面有人一起合租，改成4号"><a href="#旅游想省1000多块钱买了2号回程机票，后面有人一起合租，改成4号" class="headerlink" title="旅游想省1000多块钱买了2号回程机票，后面有人一起合租，改成4号"></a>旅游想省1000多块钱买了2号回程机票，后面有人一起合租，改成4号</h1><p>原价890，改签费530，机票差价1100, 花了1630还不是和团一个飞机。最后团的飞机降价了还不到1600，最后2500买了1600的机票，血亏900.</p><p>后面出去还是早点组团订机票，不要心疼这一点了。</p><ol><li>电子设备: 手环, 手机, 手机充电器线, 耳机, 充电宝</li><li>洗面奶, 保湿, 几个牙线</li><li>证件类: 护照, 身份证, 港澳通行证(可无)</li><li>现金2W, 交通卡, visa卡, 手机卡, 卡针</li><li>路雷他定, 地奈德, 口罩</li><li>袜子内衣x3(4) 优先破旧的, 背心裤子x2, 外套?</li><li>遮阳伞</li><li>牙刷, 牙膏, 小洗衣液</li><li>眼镜布</li><li>指甲刀</li></ol><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><ol><li>visa卡换绑定手机</li><li>胡子, 手脚指甲</li><li>手环充满电(续航开一下)</li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排行榜</title>
      <link href="/2024/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%8E%92%E8%A1%8C%E6%A6%9C/"/>
      <url>/2024/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%8E%92%E8%A1%8C%E6%A6%9C/</url>
      
        <content type="html"><![CDATA[<ol><li>排行榜到处都是</li><li>什么样的场景下使用什么样的排行榜设计? 为什么? 选取这个有什么优点和缺点, 是否牺牲了什么.</li></ol><p>魔法棒: 即时(瞬间更新), 无上限, 支持多种子表单(年季月周日时分, 标签), 数据绝对安全, 不消耗硬件(网卡, 磁盘, CPU, 内存), 先到先得.</p><p>数据: 玩家ID, 数据值. 两个int64_t 16B, 亿人, 100 000 000 * 16 = 1600MB? 玩家ID做Key会不会有啥问题? 有没有其他数据?</p><p>CPU, 即时(瞬间更新):<br>无上限: 存储 + 更新限制<br>一键瞬间导出多种报表(年季月周日时分, 标签)<br>数据绝对安全<br>网卡: 分标签拉取? 子表单, 数据量怎么说都不会小, 分页拉取是必须的.<br>存储: 磁盘, 内存 只是玩家ID, 数据值的话 貌似不成问题.<br>先到先得: 稳定排序</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编译加速</title>
      <link href="/2023/12/%E4%BC%98%E5%8C%96-%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F/"/>
      <url>/2023/12/%E4%BC%98%E5%8C%96-%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="编译时间统计"><a href="#编译时间统计" class="headerlink" title="编译时间统计"></a>编译时间统计</h2><pre><code class="shell"># g++.shreal_compiler=&quot;/usr/bin/g++&quot;filename=$(echo $* | grep -o &quot;\ -c .*&quot;)output=&quot;/root/stat.log&quot;/usr/bin/time -f &quot;%U-%S $filename&quot; -a -o $output $real_compiler $*# $export CXX=g++.shmkdir b2 &amp;&amp; cd b2 &amp;&amp; cmake .. -DCMAKE_BUILD_TYPE=debug &amp;&amp; make -j24 BigWorldServer</code></pre><h2 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h2><pre><code class="shell">nm a.cpp.o | awk &#39;NF&gt;=2 {print $(NF-1)}&#39; | sort | uniq -c     15 b bss段   2506 n debug符号   2394 r rodate段     36 t text段      1 T global text?     71 u unique global symbol    448 U 未定义符号, 链接阶段会去寻找    426 V 弱符号      4 w   11854 W 弱未定义符号</code></pre><h1 id="全量编译"><a href="#全量编译" class="headerlink" title="全量编译"></a>全量编译</h1><ol><li>减少非必须要的编译项目<ol><li>单元测试类</li></ol></li><li>unitybuild减少编译单元(核心是减少头文件的重复编译)<ol><li>将多个cpp合并编译. 减少重复头文件的耗时</li></ol></li><li>使用预编译头减少编译单元的耗时(核心是减少头文件的重复编译)<ol><li>将耗时常用且不经常修改的加入到其中</li></ol></li><li>proto<ol><li>避免协议文件被头文件引用, 采用前置声明+定义和实现分离的方式, 将协议头文件放到cpp文件中.</li><li>避免超大proto文件, 根据使用范围和频率进行分割, 减少proto变更影响的范围.</li><li><strong>自动生成的proto是重灾区, 这些proto代码一个比一个量大.</strong></li></ol></li></ol><h1 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h1><p>CMake相关</p><ol><li>优化CMake等脚本, 不每次全量生成新文件, 而是配置依赖变更后才生成, 减少非必要的变更.</li></ol><p>枚举解耦<strong>未实操</strong></p><ol><li>减少枚举文件变更导致的重编, 提供STR到INT的映射<ol><li>开发期做这种替换</li><li>发布期换回正常方式</li></ol></li></ol><h1 id="链接加速"><a href="#链接加速" class="headerlink" title="链接加速"></a>链接加速</h1><p><a href="https://github.com/rui314/mold" target="_blank" rel="noopener">mold</a></p><p>更好的链接算法和使用多线程链接</p><p>使用之前</p><pre><code class="txt"> Performance counter stats for &#39;make BigWorldServer&#39;:         29,993.61 msec task-clock                #    0.999 CPUs utilized                         148      context-switches          #    0.005 K/sec                                  26      cpu-migrations            #    0.001 K/sec                             777,595      page-faults               #    0.026 M/sec                     &lt;not supported&gt;      cycles                                                         &lt;not supported&gt;      instructions                                                   &lt;not supported&gt;      branches                                                       &lt;not supported&gt;      branch-misses                                                     30.008942931 seconds time elapsed      27.920985000 seconds user       2.075018000 seconds sys</code></pre>]]></content>
      
      
      <categories>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方向选择</title>
      <link href="/2023/12/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/"/>
      <url>/2023/12/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<ol><li>深入业务, 不只关注分配到的任务, 看看任务的上下游 关注下整体实现, 毕竟其他服务器的代码都有, 甚至还可以看公共服务的代码<ol><li>从客户端数据进来到回包回去的流程, 确实可以看看</li><li>对整体有把握才能知道可以优化的地方.</li></ol></li><li>性能压测, 编译优化</li><li>KM, 对于某个需求点(如排行榜), 可以看看一个排行榜有多少种实现方式, 每种方法的坑.</li><li>KM, 可以多看看极有可能发现预期之外的感兴趣的点, 一旦用到项目上直接UPUP.</li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>不喜欢这个方面还是算了, 有开源的不用白不用. 项目里的无锁队列一年半了也没认真看过.</p><h1 id="工具侧"><a href="#工具侧" class="headerlink" title="工具侧"></a>工具侧</h1><p>针对开发中遇到的问题, 对于能够自动化的想法提供自动化工具, 优化已有工具的体验.</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>工具与工具之间独立性强, 很容易就能写出一个新的工具, 投入少见效快</li><li>对于新的工具, 每次处理的时候也算是能了解一点内容</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>后续需要进行工具的维护, 占用时间</li><li>工具就算写好了搭配上文档, 也会有人@你去处理, 占用时间, 重复操作比较麻烦.</li><li>难于出什么深度内容</li></ol><h2 id="做过的尝试"><a href="#做过的尝试" class="headerlink" title="做过的尝试"></a>做过的尝试</h2><ol><li>GM工具优化: 这个一直在用, 属于是评价比较好的, 改动也不是很大, 主要是提高了效率.</li><li>Wireshark抓包, 后台抓包工具: 前者运行在Windows机器无法支持解密, 也没法进行良好的操作和筛选. 后者运行在服务器, 支持解析. 最终都是没有太合适的应用场景, 没人用, 也就没维护了, 预期有更高级版本, 但是现在不想写工具.</li><li>服务器自动冒烟: 这个也是在用, 自动构建内网or外网的服务器, 发布服务器和配置. py脚本也不太熟练, 写的时候也比较折磨.</li><li>日志分析: 相对简单的脚本, 但是人要一直投入在上面. 就算有文档也会被@去处理. 后面尝试接入骏鹰来解决, 但感觉可能又要维护骏鹰.</li></ol><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p>最近半年也算是没有写新的工具, 主要是维护自动冒烟, 日志分析(可能要负责维护骏鹰).</p><p>目前比较排斥写工具类的, 感觉没有学到太多的深度的东西, 写了之后就要负责维护和答疑甚至绑在上面操作.</p><h1 id="服务器优化"><a href="#服务器优化" class="headerlink" title="服务器优化"></a>服务器优化</h1><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>感觉比较高大上, 而且难点是找到问题在哪里</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>做起来太难了, 完全没这方面经验, 没有什么大的成果.</p><h2 id="做过的尝试-1"><a href="#做过的尝试-1" class="headerlink" title="做过的尝试"></a>做过的尝试</h2><p>Prometheus+Grafana提供的火焰图插件: 感觉这个也没什么深度的样子, 只做了一个火焰图的插件, 感觉虽然能看到 但还是找不到热点的优化方法, 不是很便宜大碗. 受限于采集频率</p><p>编译加速: 这个感觉还是挺爽的, 文件变更数量较少情况下, 编译速度大幅优化了. <strong>但是没能做到进一步深入优化</strong>.</p><p>bpf: 这个最终甚至都没学完, 也是感觉无法落地.</p><p>服务器二进制包大小优化: 都是有损优化, 想无损的话还是没啥用途.</p><h2 id="体验-1"><a href="#体验-1" class="headerlink" title="体验"></a>体验</h2><p>高大上, 经验积累性质强, 成本高, 难于出成果.</p><h1 id="业务仔"><a href="#业务仔" class="headerlink" title="业务仔"></a>业务仔</h1><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><p>培养代码的基本功</p><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><p>适量的话倒是没什么缺点</p><h2 id="体验-2"><a href="#体验-2" class="headerlink" title="体验"></a>体验</h2><p>一直在积累相关的经验, 最近半年整理的也发布出去了, 后面也打算继续整理和发布, 也算是正向的吧.</p><p>反正需求一直会有的, 这方面还是不太额外花时间了.</p><h1 id="重构or架构优化"><a href="#重构or架构优化" class="headerlink" title="重构or架构优化"></a>重构or架构优化</h1><h2 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h2><h2 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h2><ol><li>这个更难了, 上面的优化章节还不需要对服务器有太多深入了解, 这里就需要找到问题, 并且有能力进行改动.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方向选择 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何更好的添砖加瓦</title>
      <link href="/2023/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E7%89%88/"/>
      <url>/2023/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>记录总结了从7月到11月积累的非技术经验, 涉及添砖加瓦方方面面.</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是自己从7月到11月积累的部分非技术经验, 总结了工作记录中遇到的问题. 由于是个人经验积累, 适用性不强, 也不是大而全. 发布出来主要还是用于自己自勉, 整理了, 不发出来有感觉浪费.</p><h1 id="史山之从设计到制作"><a href="#史山之从设计到制作" class="headerlink" title="史山之从设计到制作"></a>史山之从设计到制作</h1><h2 id="需求设计"><a href="#需求设计" class="headerlink" title="需求设计"></a>需求设计</h2><p><strong>需求评审</strong><br>评审时, 如果不是很确定这部分功能, 自己负责的服务器能不能做, 就不要承接下来, 最后发现做不了, 再转手.</p><p><strong>需求文档到手</strong></p><ol><li>从需求文档中找到需求点, 协商好需求点由哪个服务器来处理, 防止开发重复内容或者无人处理. 或者由于种种原因是对方压根做不了, 只能自己来做.</li><li>尽量避免想当然的情况, 比如文档中说每天增加一次挑战次数, 但是没有提初始次数是多少次, 这时候最好沟通下.</li><li>虽然可能不清楚其他需求, 但还是尽量能够判断下和其他需求是否有重叠, 导致出现边界情况, 对好这个时候怎么处理.</li></ol><p><strong>需求文档看完, 开工之前, 先定协议</strong></p><p>定完协议之后, 各个参与人就可以独立开发. 如果先开发再定协议, 可能导致后定的协议不便于所有人使用.</p><p><strong>开工之前, 进行下预期设计, 同时评估时间</strong></p><ol><li>写代码之前先在vscode进行下预期设计, 写写伪代码. 虽然需求可能要的比较紧急, 但花一点时间提前设计下, 比直接撸起袖子开干还是感觉最终效率好很多.<ol><li>代码放到哪个模块</li><li>这个功能大概是什么流程</li></ol></li><li>预期设计完成后, 根据<strong>功能点和设计</strong>, 能够更加准确的进行排期.</li><li>根据需求工作量确定下复杂程度. 虽然完善的设计很重要, 但有时会因为过于完善, 导致简单的需求变得非常复杂, 同时后续也不一定用得上这次设计的完善机制.</li><li>预期下异常情况处理和兜底处理</li></ol><h2 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h2><p><strong>将重复的项目抽取出来</strong><br>第一次做的时候, 可能考虑到需求比较简单或者时间不足, 一个功能就放在了一起实现, 但是后续又双叒叕用到这个功能了.对于个人提升来说, 就可以考虑抽取出来了.</p><p><strong>做好兼容性处理</strong></p><p>负责的功能要将兼容性处理做完善, 能够做到其他人无感知是最好的. 不要想着其他人只需要小小的一点处理就能解决, 到时候不管提示再多次都会有人@问什么问题的, 所以最优解是其他人无感知.</p><p><strong>预估时间后无法完成后, 要及时周知相关人员</strong></p><p>应该及时通知，否则默认你这边完成了, 其他人进行了一些处理, 导致不必要的问题出现.</p><p><strong>开发的时候加足DEBUG日志</strong></p><ol><li>遇到问题的时, 查日志相对看代码是效率非常高的解决方式.</li><li>加日志的位置和内容还是吃经验. 个人感觉站在将来查问题的角度去加日志有帮助.</li><li>DEBUG日志一般会在线上关闭, 一些重要内容就要注意使用更高的等级, 否则一点日志都没, 外网问题全靠复现才能查.</li></ol><p><strong>个人统一的工具仓库</strong><br>工作中难免会写出来一些小工具, 提供给他人使用的时候一般都是放到公共代码库中, 这个时候工具就会在本地和公共代码库有两份, 注意只在一个地方修改, 否则容易出现不一致.</p><p><strong>需求中途变更后简化代码</strong></p><p>代码设计初期一般会留有一些考虑能够应对需求变化，但是需求变化后可能会导致实现可以简化，这个时候继续复用复杂的代码还是简化代码就需要考虑了.</p><p><strong>代码尽量一步成型</strong><br>个人感觉修改次数越多, 出问题的概率越高, 修改了这里忘记了同步修改其他地方是重灾区.</p><p><strong>避免设计无用的东西</strong><br>一些本来加个函数就能解决问题的, 是否要抽成一个模块就要仔细考虑下了.</p><p><strong>数值类配置化or计算化</strong></p><ol><li>数值类的最好不要写死<ol><li>如果是配置中的值，配置变了，写死的数值就会导致问题</li><li>还可能导致本来热更就能搞定的，需要重新编译服务器</li></ol></li><li>尽量不要写死参数, 配置或者计算得来, 否则后面还需要同步修改.</li></ol><p><strong>减少通用错误码的使用</strong></p><p>如果错误码一对一能够及时发现问题, 如果是多个地方使用的, 只能靠日志+看代码路径了.</p><p><strong>客户端参数校验</strong></p><p>老生常谈了, 基本上每本书里都会提这点, 这次就出现了所有服务器都没校验的一个操作, 甚至是客户端都没检验.</p><p><strong>状态校验放错了位置. 写的时候还是没考虑好运行路径</strong></p><p>加代码的时候, 仔细考虑好相关的运行路径. 可能某个分支下, 这次加的就是有问题的.</p><p><strong>加快调试速度</strong></p><p>需求写完之后, 想要测试下自己的代码, 尽量将GM工具完善好, 否则每次修改代码都要重复操作好几步, 导致花费的时间反而比加一下工具要多.</p><ul><li>副作用, GM工具要标注下使用场景, 否则错误场景使用后容易出乌龙问题.</li></ul><h1 id="史山之从修改到回归"><a href="#史山之从修改到回归" class="headerlink" title="史山之从修改到回归"></a>史山之从修改到回归</h1><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p><strong>修改前-不确定是bug还是feature时要进行确认</strong><br>否则可能将feature作为bug处理了, 后续还要改回来, 造成不必要的时间浪费或者麻烦.</p><p><strong>修改前-遇到BUG还是感觉留下现场，比重启解决问题更加重要</strong></p><p>问题可以后面解决，复现问题可能再也没有机会了</p><p><strong>修改前-简单方式解决问题</strong></p><p>对于一个小bug, 简单的打个补丁就可以解决的话, 还是偏向于打补丁. 至于刨根问题解决虽然好, 但是一旦牵扯过多, 然后自己对项目不了解, 大刀阔斧重构容易出问题.</p><p><strong>查问题中-用物体的事件经过查问题挺方便的</strong></p><p>事件驱动的场景下, 可以先查询顶层都有那些事件, 看看这些事件的内容和实际是否正确, 比一下钻到底层查问题要快很多.</p><p><strong>影响扩大-确定修改后果, 注意一个函数都有哪些作用</strong></p><ol><li>一个函数可能不是你想的那种作用, 或者带有一些条件, 再或者是副作用. 之前没有使用过的, 不熟悉的最好看一看实现.</li><li>修改一处代码的时候, 考虑全面是否会波及其他调用方</li></ol><p><strong>影响扩大-抽取函数注意不要影响到原区域功能</strong></p><p>发现一段代码可以复用的时候, 会从其他函数中将这个函数抽取出来. 但是抽出来的函数增加代码的时候, 注意不要影响到原位置. 如在抽取出来的函数中, 由于其他需求, 增加了一层判断, 导致原位置(抽取函数前的位置)功能被影响.</p><p><strong>影响扩大-enum中增加新类型</strong></p><p>enum中增加新类型后要注意看看这个enum的使用位置, 如果只是关注自己新写的代码忽略旧代码, 可能导致旧代码的判断过不去.</p><p><strong>修改后-BUG修复关联BUG单</strong></p><p>否则后续会忘记为啥修改这里, 当时是什么BUG做出的这样的处理.</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>尽可能进行全面的自测</strong></p><p>真的有某些代码是依靠BUG运行的, 修复BUG之后反而运行不了了, 所以基本的测试是必需的, 能想到的可能影响到的地方, 最好也是自测一下. 想到的地方不去测一下的话, 可能就是想到的这个地方出了问题.</p><p><strong>A通过B通过不等于A+B通过</strong></p><p>一个功能还是完整的测试吧，A功能虽然等于B+C功能，但B和C功能分别正确 不一定B+C就是正确的</p><p><strong>自动化测试</strong></p><p>一些功能测起来可能比较麻烦, 使用自动化工具会方便很多, 比如pyclient完全模拟一个客户端, 写代码有时候比点来点去构建测试环境方便很多.</p><h1 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h1><p><strong>问题的优先级安排</strong></p><p>并行处理任务的时候, 注意优先级的安排. 可能当前的工作进行到一半, 有其他高优先级的工作要做的话, 还是要切过去. 尤其是查BUG到一半的时候, 很容易上头, 导致又多查了半天.</p><p><strong>充分关注自己的工作</strong></p><p>其他人都开始要联调了, 自己的功能还没发布到服务器上. 虽然当时在处理其他问题, 但还是已经做过的善后优先一些.</p><p><strong>不懂就问</strong></p><p>文档较少, 全靠口口相传, 遇到不懂得项目, 一定要进行询问, 不能常识性的去做.</p><p><strong>重视不起眼的小问题，可能背后的原因是非常离谱的</strong></p><p>遇到过不止1-2次了, 看起来就是很小的一个问题, 深究起来问题可能一串一串的.</p><p><strong>特殊处理</strong></p><p>没有注释的代码, 可能使用了一些特殊规定, 如果错误删掉了就会影响到功能. 比如数值是0的时候, 按照1来处理, 看描述很简单, 但是实际代码可能没有那么直观.</p><p><strong>预期下当前所做是不是可以解决最终问题, 而不是当前某一步</strong></p><p>当前所做可能确实能解决当前问题, 但是不一定能解决最终问题. 比如传输日志之前需要压缩, 压缩成几个小包也是压缩, 压缩成超大包也是压缩, 但是压缩成超大包可能不利于传输和解压.</p><p><strong>去看看别人负责的模块, 不要只顾自己的模块</strong></p><p>对于多模块(多服务器)后台, 多去关注下自己负责模块之外的内容, 这样对项目了解的更深.</p><p><strong>问题的原因, 不一定是第一印象想到的点</strong></p><p>遇到问题即使下意识感觉问题就是那里, 也一定要确认下. 可能并不是那样.</p><h1 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h1><p><strong>他人回复的内容一定要仔细理解，不要含主观臆断</strong></p><ol><li>X场景下，……………………………（省略），这个功能就不需要了。（非X场景是需要的，不能直接删掉这个功能）</li><li>今天晚上就合入版本了（几点？能不能在全量发布服务器前完成，而不是晚上这种模糊时间）</li></ol><p><strong>后台开发代表全部后台, 前台开发代表全部前台</strong></p><p>后台有多个服务器，每个服务器不同的人负责，前台可能认为后台是一个整体，所以找你沟通的时候最好不要只考虑本服务器的事情, 有需要就拉上其他服务器的一起建群.</p><p><strong>帮忙</strong></p><p>帮忙处理东西的时候，要问清楚原因, 搞清楚要做啥, 不能只是直接照做.</p><p><strong>对应的事情尽量给对应的人去做</strong></p><p>运维可以通过内网传输日志, 比通过sz和rz快和稳定很多.</p><h1 id="36技"><a href="#36技" class="headerlink" title="36技"></a>36技</h1><p><strong>CR发起前可以自己整一个临时CR看看代码</strong></p><p>每次提交代码前, 全局的看一看自己的代码, 可能功能正确, 但是有不小心动到其他地方的代码.</p><p><strong>测试代码在最终CR的时候要及时去掉 使用TODO 名字方便检索</strong></p><p>使用TODO标记测试代码, 提交前批量查找下, 全部去掉.</p><p><strong>不建议手动操作流水线</strong></p><p>流水线中某一步错误后, 尽量重新触发流水线. 手动执行错误的一步, 很容易出错, 漏掉某些操作.</p><p><strong>自动化操作没有监管人</strong></p><p>流水线有的没有人监管, 即使将结果通知到了使用者, 使用者可能也会忽视结果, 导致有错误没有发现, 进而导致其他问题. 所以错误提示要尽可能的明显.</p><p><strong>压测和扩容</strong></p><ol><li>压测<ol><li>压测场景和实际场景不匹配<ol><li>出现问题之后，都能发现问题，关键是出现问题前发现限制点</li></ol></li></ol></li><li>扩容<ol><li>重要节点前, 预备一些机器, 否则出问题的时候, 机器没办法即时拿到.</li></ol></li></ol><p><strong>发现问题比解决问题更重要</strong></p><p>性能优化感觉难点是发现性能问题, 包括编译加速. (20%的问题造成了80%的负面影响, 如果去处理另外80%的问题收益就很低)</p><p><strong>指定时间点触发的循环定时器, 每轮都计算下时间相比固定时间的更加稳定</strong></p><p><strong>尽量统一函数对统一内容进行清除, 比如标志位, 这样方便发现错误清理的地方</strong></p><p><strong>测试东西或者搞新东西的时候, 注意不要影响到旧功能</strong></p><p>该开测试空间的开测试空间, 防止影响到其他空间</p>]]></content>
      
      
      <categories>
          
          <category> 个人记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现火焰图半自由</title>
      <link href="/2023/11/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-PrometheusX%E7%81%AB%E7%84%B0%E5%9B%BE/"/>
      <url>/2023/11/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-PrometheusX%E7%81%AB%E7%84%B0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Linux服务器端可以使用profile生成火焰图. profile从运行开始收集数据, 结束运行时将结果输出, 过了这村就没这店.</p><p>有没有可能持续使用profile进行采集, 将数据收集起来, 然后查询任意时间段的火焰图?</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>答案是√, 使用Prometheus存储profile采集的数据, 使用Grafana的火焰图插件(V9.5.2)将结果展示出来. <strong>本文结束, 感谢观看!</strong></p><h1 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h1><ol><li><p>profile的原始数据是栈调用(隐含时间信息), 火焰图是树状结构(丢失时间信息), 如果想要查询任意时间段就要存储原始栈调用数据和其对应的时间.</p></li><li><p>Grafana提供了火焰图插件, 但是只接受火焰图数据, Prometheus中存储的原始栈数据无法直接使用.</p></li><li><p>Grafana和Prometheus对字符串的处理能力极差</p></li></ol><p>所以需要实现一个Proxy, 接受Grafana的查询请求, 转去请求Prometheus, 将结果进行处理后返回Grafana进行展示.</p><h1 id="PrometheusProxy实现"><a href="#PrometheusProxy实现" class="headerlink" title="PrometheusProxy实现"></a>PrometheusProxy实现</h1><h2 id="profile输出"><a href="#profile输出" class="headerlink" title="profile输出"></a>profile输出</h2><p><code>threadname;stack0;stack1;stack2 num</code></p><p><code>threadname;stack1;stack4;stack2 num</code></p><p>线程名, 栈帧, 采集到的数量. 这些数据将会上报到Prometheus中进行存储.</p><p>上报的格式需要依照Prometheus要求进行下格式化, 这里就不详细介绍了, 只需要知道Prometheus中存储了这些原始的数据(时间, 栈, 对应采集的次数)即可.</p><h2 id="Grafana查询协议"><a href="#Grafana查询协议" class="headerlink" title="Grafana查询协议"></a>Grafana查询协议</h2><pre><code class="txt"># URL/api/v1/query_range# BODYend=1694848740&amp;query=cpu_func_profile{processname=&quot;HelloServer&quot;}&amp;start=1694827140&amp;step=15</code></pre><p>start 起始时间<br>end 结束时间<br>query 向Prometheus请求的表达式<br>step 步长</p><h2 id="Prometheus协议"><a href="#Prometheus协议" class="headerlink" title="Prometheus协议"></a>Prometheus协议</h2><pre><code class="go">// Prometheus请求协议即是上面的Grafana协议// Prometheus回应协议是如下结构对应的json数据type PrometheusReportData struct {    Status string `json:&quot;status&quot;`    Data   struct {        ResultType string `json:&quot;resultType&quot;`        Result     []struct {            Metric struct {                Name     string `json:&quot;__name__&quot;`                Instance string `json:&quot;instance&quot;`                Job      string `json:&quot;job&quot;`                Stack    string `json:&quot;stack&quot;`            } `json:&quot;metric&quot;`            Values [][]any `json:&quot;values&quot;`        } `json:&quot;result&quot;`    } `json:&quot;data&quot;`}</code></pre><p>将完整的Grafana请求转发给Prometheus, Prometheus会进行筛选和合并后返回, 所以无需对结果进行额外处理, 只需要从其中拿到汇总后的栈数据即可.</p><p>stack: 这个是我们上报的栈数据<code>stack0;stack1;stack2</code></p><p>Values: 是Value的数组, Value有且仅有两个元素, 第一个元素是数据对应的时间戳, 第二个元素是栈数据的<code>num</code></p><p>所以遍历所有数据统计出一个<code>map&lt;stack, num&gt;</code>, Prometheus的任务就完成了.</p><h2 id="Grafana火焰图插件回包json格式"><a href="#Grafana火焰图插件回包json格式" class="headerlink" title="Grafana火焰图插件回包json格式"></a>Grafana火焰图插件回包json格式</h2><pre><code class="go">type Metric struct {    Name     string `json:&quot;__name__&quot;`    Instance string `json:&quot;instance&quot;`    Job      string `json:&quot;job&quot;`    Label    string `json:&quot;label&quot;`    Level    string `json:&quot;level&quot;`    Self     string `json:&quot;self&quot;`    Value    string `json:&quot;value&quot;`}type Result struct {    Metric Metric `json:&quot;metric&quot;`    Values string `json:&quot;values&quot;`}type PrometheusFlameData struct {    Status string `json:&quot;status&quot;`    Data   struct {        ResultType string   `json:&quot;resultType&quot;`        Result     []Result `json:&quot;result&quot;`    } `json:&quot;data&quot;`}</code></pre><p>PrometheusFlameData的其他数据从Prometheus的回包中拷贝过来即可, 重要的是PrometheusFlameData.Result</p><p>Result.Values: 是Value的数组, Value有且仅有两个元素, 第一个元素是数据对应的时间戳, 第二个元素是栈数据的<code>num</code>, <strong>这个已经不重要了, 火焰图并不需要每个节点的时间, 可以任意填充.</strong>, 如<code>[[1684829000,&quot;1&quot;]]</code></p><p>Result.Metric: 将栈数据转换成多叉树后, 前序遍历节点后得到的结果.</p><ul><li>Label: 函数名称(节点名称)</li><li>level: 层级</li><li>self: 自己作为栈最后一帧的数据数量</li><li>value: 自己和子节点所有self的合</li></ul><h2 id="PrometheusProxy处理"><a href="#PrometheusProxy处理" class="headerlink" title="PrometheusProxy处理"></a>PrometheusProxy处理</h2><p>将Grafana的请求原封不动, 转发给Prometheus进行处理, Prometheus数据返回后Proxy进行处理转换为火焰图插件数据格式, 进而返回给Grafana.</p><h1 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h1><h2 id="Prometheus存储数据的原理"><a href="#Prometheus存储数据的原理" class="headerlink" title="Prometheus存储数据的原理"></a>Prometheus存储数据的原理</h2><p>从上文<code>Prometheus协议</code>的格式来看, stack部分和values部分是分开的, 如果一个stack在多个时间被采集到, 只会存储新数据的时间和次数到values中.</p><p>这里提到的stack实际是一个字段, 此外还有线程名, 进程名等字段. 如果一整条上报数据是一样的, Prometheus只会存储时间和次数部分, 如果整条上报数据有一丝一毫差别 就会导致整条数据被记录一次. 导致空间占用暴增(因为stack很长).</p><p>说人话就是不要在字段中增加随机值, 否则会导致上报数据无法复用, 每次上报都要存储完成数据, 导致存储量爆炸.</p><h2 id="C-编译选项"><a href="#C-编译选项" class="headerlink" title="C++编译选项"></a>C++编译选项</h2><p>profile打印出完成的栈结构 需要在程序编译的时候 指定<code>-fno-omit-frame-pointer</code></p><h2 id="针对指定的URL和内容过滤"><a href="#针对指定的URL和内容过滤" class="headerlink" title="针对指定的URL和内容过滤"></a>针对指定的URL和内容过滤</h2><p>Grafana查询的URL是<code>/api/v1/query_range</code>, 对应的标签是cpu_func_profile, 可以只针对这种情况处理.</p><p>其他情况使用doProxy直接转发, 否则无法使用自动补全等一些提示</p><h2 id="profile采集频率"><a href="#profile采集频率" class="headerlink" title="profile采集频率"></a>profile采集频率</h2><p>由于profile需要消耗机器CPU, 可以采用每隔X分钟后运行Y分钟的profile, 将数据格式化后供Prometheus提取.</p><h2 id="半自由"><a href="#半自由" class="headerlink" title="半自由"></a>半自由</h2><p>火焰图准确与否与采集频率有很大关系, profile持续运行会消耗很多的CPU, 所以目前是采取了运行X分钟停止Y分钟的做法, 如果能持续运行profile就能解决这个问题.</p><h1 id="扩展-倒转火焰图"><a href="#扩展-倒转火焰图" class="headerlink" title="扩展-倒转火焰图"></a>扩展-倒转火焰图</h1><pre><code class="txt">func1#func2#func3func1#func3func2#func3func4#func3</code></pre><p>如上四个调用栈, 从火焰图上无法轻易看出来func3占用了过多的CPU, 换一种思路将栈倒过来, 就能发现func3占用了过多CPU, 这一步操作只需要在PrometheusProxy中调用一个函数倒转切割后的栈,就能实现.</p>]]></content>
      
      
      <categories>
          
          <category> 项目制作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>写博客技巧</title>
      <link href="/2023/11/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/11/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="写博客技巧"><a href="#写博客技巧" class="headerlink" title="写博客技巧"></a>写博客技巧</h1><h2 id="文章分类和特点"><a href="#文章分类和特点" class="headerlink" title="文章分类和特点"></a>文章分类和特点</h2><p><strong>分类</strong></p><ul><li>大众科普</li><li>方案创新</li><li>项目总结</li><li>深度技术</li></ul><p><strong>特点</strong></p><ul><li>受众多样</li><li>通俗大众</li><li>传播属性</li><li>格式灵活</li></ul><h2 id="写文章的价值和作用"><a href="#写文章的价值和作用" class="headerlink" title="写文章的价值和作用"></a>写文章的价值和作用</h2><ol><li>温故而知新</li><li>便于传播分享, 及时发现问题</li><li>提高技术影响力</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>事前<ol><li>同理心, 确定目标读者</li><li>攒素材, 积累文章素材</li><li>定好题, 确定文章主题</li><li>搭骨架, 确定文章结构</li></ol></li><li>事中<ol><li>画好图, 绘制文章配图</li><li>有干货, 提升文章内容</li><li>勤润色, 反复润色文章</li></ol></li><li>事后<ol><li>练内功, 扩大阅读范围</li></ol></li></ol><h4 id="同理心-认知偏差"><a href="#同理心-认知偏差" class="headerlink" title="同理心-认知偏差"></a>同理心-认知偏差</h4><p>了解之后就难于理解不了解人的想法, 下意识认为对方已经了解某些知识点</p><ul><li>一些基础概念, 读者不一定了解</li><li>因果关系需要更进一步解释</li><li>站在读者角度考虑, 最好的方式是找没有背景同学检验</li><li>面相受众 What, Why, How</li><li>外行人看不懂, 内行人没必要看</li></ul><p>检测知识的最终途径, 将其传播给另一个没有背景的人</p><h4 id="攒素材"><a href="#攒素材" class="headerlink" title="攒素材"></a>攒素材</h4><p>写文章的时候捉襟见肘, 不要在决定写文章的时候 才去找素材. 素材积累之后可以整理出来.</p><p>有些粗粗看过的, 可能含有非常多的点</p><h4 id="定好主题"><a href="#定好主题" class="headerlink" title="定好主题"></a>定好主题</h4><p>确定主要范围, 不要歪楼, 不相关的简单介绍.</p><p>确定知识边界, 普适性的文章, 不需要从识字教起.</p><ul><li>工作总结</li><li>学习材料</li><li>热点话题</li><li>观察生活</li><li>深挖本质</li><li>巧用对比</li></ul><p>主题上升, 和更大的主题联系起来, 变归纳为聚焦</p><p>主题写明动作和动机</p><p>结构化思维: 穿线(讲通, 将多个知识点联系起来, 如从电路讲到程序运行), 归纳(小主题归纳到一个大范围,看看范围都有啥), 深挖(逐字逐句), 聚焦(只讨论关注的点, 将关注的点讲明白)</p><p>获取主题灵感: 发散思维, 逻辑思维, 同理心. 在平时多去关注一些</p><p>确认分享欲, 搜索相关主题(穿线很少), 思考对其他人是否有价值, 属于那种灵感来源, 主题上升, 标题是否是文章主要内容的一句话概括</p><p>标题小技巧, 图片中</p><h4 id="搭骨架"><a href="#搭骨架" class="headerlink" title="搭骨架"></a>搭骨架</h4><p>主题有了 素材有了</p><p>有规律 贴近旧有认知 利于大脑记忆</p><p>金字塔原理: 结构化思考, 沟通, 写作. 一本大厚书 芭芭拉明托</p><p><strong>结构化思维</strong></p><ul><li><p>梅切原则: 相互独立(没有交集), 完全穷尽(没有空隙)</p></li><li><p>简单性原理: 文章不需要面面俱到, 主线不相关内容, 可以考虑删减. 结构简单, 文字简省.</p></li><li><p>不要用复杂的东西解释另一个复杂的东西, 文章结构不要太复杂(精简层数 每层中case精简)</p></li></ul><h4 id="画好图"><a href="#画好图" class="headerlink" title="画好图"></a>画好图</h4><p>字不如数, 数不如表, 表不如图. 人脑处理图片相比文字更快</p><p>配图不一定需要时专业的, 主要目的是帮助理解 不一定需要多么严谨, 放在文章中能说明问题就好.</p><h4 id="有干货"><a href="#有干货" class="headerlink" title="有干货"></a>有干货</h4><p>取决于文章主题, 是否是水货</p><h4 id="勤润色"><a href="#勤润色" class="headerlink" title="勤润色"></a>勤润色</h4><p>语言晦涩, 排版不好, 多迭代, 反复打磨文章</p><p>语言精简(不能无脑删减), 内容分段, 准确(善用专业词汇 鼠标点两下(双击), 准确数字(90%)), 生动, 例子(不求多 命中要害, 极端例子 说明问题)</p><p>发表之前至少自己读一次. 善用AI润色, 重新解读不要机翻 机械搬</p><h4 id="练内功"><a href="#练内功" class="headerlink" title="练内功"></a>练内功</h4>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UP月记录</title>
      <link href="/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E6%9C%88%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E6%9C%88%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="月记录备份"><a href="#月记录备份" class="headerlink" title="月记录备份"></a>月记录备份</h1><h2 id="2023-07"><a href="#2023-07" class="headerlink" title="2023-07"></a>2023-07</h2><p>以后写工具应该注意，一个工具放两个代码库维护是容易出问题的，能统一尽量统一，统一不了应该只在一个里面修改</p><ol><li>对方回复的内容一定要仔细理解，不要含主观臆断<ol><li>X场景下，……………………………（省略），这个功能就不需要了。（非X场景是需要的，不能直接删掉这个功能）</li><li>今天晚上就合入版本了（几点？能不能在全量发布服务器前完成，而不是晚上这种模糊时间）</li></ol></li><li>需求中途变更<ol><li>代码设计初期一般会留有一些考虑能够应对需求变化，但是需求变化后可能会导致实现可以简化，这个时候继续服用复杂的代码还是简化代码就需要考虑了</li></ol></li><li>多沟通协调<ol><li>后台有多个服务器，每个服务器不同的人负责，前台可能认为后台是一个整体，所以找你沟通的时候最好不要只考虑本服务器的事情。<ol><li>我这里完成了 前台认为所有服务器完成了</li></ol></li><li>对方代码还没合入的时候，你说对面完成了，结果实际没完成</li></ol></li><li>测试<ol><li>一个功能还是完整的测试吧，A功能虽然等于B+C功能，但B和C功能分别正确 不一定B+C就是正确的<ol><li>pyclient加上这个还是很方便的</li></ol></li></ol></li><li>GM工具<ol><li>GM工具好多都是有使用场景的，非使用场景使用会出现问题，所以还是要标注清楚</li></ol></li><li>流水线异常<ol><li>流水线异常的时候手动操作了报错部分，然而报错导致后续操作也被中断了，但是忘记了操作后续部分，只操作了报错部分<ol><li>流水线都现成的了 直接用吧 别手动操作了、</li></ol></li><li>新版服务器未更新到目标服务器 出了N个乌龙BUG单</li></ol></li></ol><h2 id="2023-08"><a href="#2023-08" class="headerlink" title="2023-08"></a>2023-08</h2><ol><li>兜底方案<ol><li>当时在众多人说自己无法进入游戏的时候，都没有去考虑补上兜底方案<ol><li>因为当时考虑到这些都是异常情况，正常情况玩家地图上是不会有自己的主城，只要是正常环境就没有问题</li><li>然而遇到了Logic崩溃了，Logic没有记录选州成功，此时大地图已经选州了，玩家游戏直接卡死，之后才把兜底补上。这次就不是异常情况了，是正常情况下可能会出现的问题了。</li></ol></li></ol></li><li>一个不起眼的小问题，可能背后的原因是非常离谱的。<ol><li>dev环境选州Logic崩溃，竟然是由于Logic代码写错的原因（为啥外网没有遇到呢？）</li><li>测试反馈添加的主城全部报错30000，结果是因为roleId循环的，已经添加主城的roleId再次添加主城，由于兜底机制+指定roleId主城存在就会将roleId顺延，顺延之后的就是空roleid，后面就拿不到离线时间的数据</li></ol></li><li>注重系统整体架构的设计<ol><li>有输入相比自己死磕能够成长的更快<ol><li>看看其他人的方案拆解<ol><li>不能同一帧将所有点位检查这种情况，才想到要延时进行刷新。</li><li>不能是单单的将需求点列出来，需要对应到具体的改动是啥，这样评估时间才准确。</li><li>注意下时间评估这里，目前我评估的时间还是非常的不准确的</li></ol></li><li>看看其他人的cr，不然自己没有负责过的模块 是一点都不清楚<ol><li>同时看了之后还有和其他人PK的机会</li><li>看看其他人的设计，学一学自己将来才可能遇到，不然都是在自己思维下兜圈子</li><li>看看别人的CR和方案，这里为什么这么设计，自己想的话如何设计，一下对比就出来了。进行后续沟通还能了解到更多。</li></ol></li></ol></li><li>之前看到帝国觉醒只是想到了战斗服需要在压力场景下减少发包<ol><li>但是大地图是不是需要呢？完全没有考虑过，大地图是否需要<ol><li>大地图实际是不需要的，至少目前的同步机制是够用的</li><li>战斗服可能是需要的，不过后面就没跟进了解了</li></ol></li><li>24年2月又做了不下发其他人的PET, 我为什么没想到呢?</li></ol></li><li>千人测试的时候，重启城郊会导致战斗服也需要重启的问题</li><li>千人测试的时候，Logic崩溃导致事件完成了任务没有完成</li></ol></li><li>输入<ol><li>代码</li><li>CR</li><li>方案拆解和评估</li><li>KM文章</li><li>开源项目</li></ol></li><li>注意点（不要将问题带到线上，这样处理起来非常的麻烦，而且会增加不靠谱）<ol><li>异常情况处理</li><li>兜底</li><li>自测</li></ol></li><li>需求拆解和方案评估<ol><li>不能是单单的将需求点列出来，需要对应到具体的改动是啥，这样评估时间才准确。</li><li>注意某些重要的异常情况处理和兜底处理</li></ol></li><li>之前删掉了一段代码，导致城郊出现问题，忘记为啥删除的了，后面修BUG还是带上BUG单的链接把<ol><li>没有强制检查, 保持的不太好</li></ol></li><li>防御性编程，校验外部传进来的参数</li><li>野怪最大等级改了获取位置，写代码的将等级为0认为是错误，直接返回了, 对于能跑的屎山小心动.<ol><li>然而赏金这里有特殊处理，等级是0则按1级</li></ol></li></ol><h2 id="2023-09"><a href="#2023-09" class="headerlink" title="2023-09"></a>2023-09</h2><ol><li>遇到BUG还是感觉留下现场，比重启解决问题更加重要<ol><li>问题可以后面解决，复现问题可能再也没有机会了</li></ol></li><li>编码规范<ol><li>空指针这种错误都犯了<ol><li>改一个位置的时候，尤其要注意使用的所有参数，这些参数可能在外面并没有校验</li><li>改代码比新写代码更容易出现</li></ol></li></ol></li><li>帮忙<ol><li>帮忙处理东西的时候，一定要搞清楚，问清楚。自己也要看清楚，不能只是不带脑子的执行了。</li></ol></li><li>注意可能发生死循环代码的兜底<ol><li>服务器更新脚本中就遇到了，重复的更新服务器。</li></ol></li><li>数值类的最好不要写死<ol><li>如果是配置中的值，配置变了，写死的数值就会导致问题</li><li>还可能导致本来热更就能搞定的，需要重新编译服务器</li></ol></li><li>可能还是要减少通用错误码的使用, 兜底的通用错误码竟然用到了.</li><li>客户端参数校验<ol><li>没想到出现了非联盟成员拆联盟建筑的问题。</li></ol></li><li>压测<ol><li>压测场景和实际场景不匹配<ol><li>出现问题之后，都能发现问题，关键是出现问题前发现限制点</li></ol></li><li>扩容<ol><li>寻路服爆炸了，然而没有办法扩容，没有机器。</li></ol></li></ol></li><li>重新编译的问题，没想到还学到了不少。<ol><li>tars文件重新生成的问题<ol><li>先用md5比对写了一版</li><li>结果还是直接用CMake写最好，几行的事情</li></ol></li><li>CMake和Make的基本原理</li><li>依赖分析，编译加速？</li></ol></li></ol><h2 id="2023-10"><a href="#2023-10" class="headerlink" title="2023-10"></a>2023-10</h2><ol><li>迁移日志<ol><li>最后日志传输工作给了运维来搞，自己搞还是太麻烦了<ol><li>该找运维的找运维了</li></ol></li><li>不要压缩超大包，或者进行分卷了<ol><li>解压起来对磁盘要求太高了(预期下当前所做是不是可以解决问题, 而不是只顾当前压缩)</li></ol></li></ol></li><li>性能优化感觉难点是发现性能问题, 包括编译加速. (20%的问题造成了80%的负面影响, 如果去处理另外80%的问题收益就很低)</li><li>下午看了看相关的博客，还是感觉要坚持输入一些内容，整理整理哪些可以看吧<ol><li>阮一峰, 内部论坛</li></ol></li><li>接触了下战斗服和逻辑服的代码, 把相关环境也搭建好了, 后续也确实看过几次对应的代码.</li><li>终于把之前想过的时间触发器抽了个Module出来, 后面就可以复用了. 写Module之前vscode中写下预期设计挺好的, 继续坚持了.</li><li>做事之前尽量确认好, 不然竹篮打水一场空, 时间浪费不少.<ol><li>需求理解一定要正确, 仔仔细细逐句逐句的看需求点.</li><li>看看需求的特殊要求, 比如退盟之后是否重置, 这个影响到了数据记录到哪里.</li><li>还得考虑下客户端是否支持</li><li>考虑下实现的复杂程度, 可能预期很简单, 但是因为牵扯过多或者不支持导致变得复杂.</li></ol></li><li>指定时间点触发的循环定时器, 每轮都计算下时间相比固定时间的更加稳定.</li><li>主城周围搜索物体, 采用涡旋状搜索, 类似蚊香.</li><li>有的功能大地图并不知道有没有, 还是说下不知道之类的吧, 最后接下来了发现是别人的工作.</li><li>代码BUG<ol><li>显性BUG, 状态校验放错了位置. 写的时候还是没考虑好运行路径.</li><li>隐形BUG, 抽函数后加东西, 导致相对于原有增加了一些功能, 这种是很危险的抽函数.</li></ol></li><li>看到小问题的时候 深究深究就会发现可能并不是那么简单<ol><li>转表工具报错, 空白列占位</li></ol></li><li>尽量统一函数对统一内容进行清除, 比如标志位, 这样方便发现错误清理的地方</li><li>指针判空, break<ol><li>这次是在JavaScript中没有判空, 有的block没有数据</li></ol></li><li>遇到问题即使下意识感觉问题就是那里, 也一定要确认下. 可能并不是那样.</li><li>如果解决一个小bug, 完美的方式改动很多的话, 感觉不如简单的处理下.<ol><li>长久来说, 还是要考虑下解决这个问题, 算是一个优化点? </li></ol></li><li>尽量不要写死参数, 配置或者计算得来, 否则后面还需要同步修改.</li><li>测试东西或者搞新东西的时候, 注意不要影响到旧的东西, 该开测试空间的开测试空间<ol><li>这次自动提单提了2K+, 如果不是提到了临时空间 估计直接爆炸了.</li></ol></li></ol><h2 id="2023-11"><a href="#2023-11" class="headerlink" title="2023-11"></a>2023-11</h2><ol><li>配置化<ol><li>IDC的流水线配置化了, 一些写死的内容移到了外面, 同时把流水线进行了统一, 不然一下改几条流水线直接升天</li></ol></li><li>查BUG<ol><li>仔细检查触发条件, 为什么这个场景触发了, 其他类似场景没触发, 这两个场景看起来很相似, 哪里有区别</li></ol></li><li>隐形问题, <strong>只有监控没有报警or明显提醒, 几乎相当于没有监控</strong>.<ol><li>磁盘炸了, 服务器对外无法提供服务.</li></ol></li><li>降本增效<ol><li>对于非重要数据, 用了Prometheus的双写服务, 把数据向自己搭建的服务器上同步一份, 这样就不用在腾讯云存储太长时间</li></ol></li><li>写BUG<ol><li>城郊里的功能 没有加开关, 影响到了大地图</li></ol></li><li>坚持记录每天所做所想, 不然忘了自己做了啥还是难受.</li><li>公共位置要使用公共账号和密码, 不把自己账号密码存进去, 容易出问题</li><li>当时看到经分文档里两个说明很别扭, ABBA格式, 不是ABAB, 想着容易出错, 结果真的把AB用反了.</li><li>7月就记录过了, GM工具标注使用场景, 结果到了11月还是没几个工具标注, 复习下.</li><li>JPS寻路算法学习, 这个得出的就不是最短路径</li><li><strong>移动接口的调用地方太多了, 结果搞出来了一个死循环的移动, A向B移动被修正到C点, A向B移动. 能够统一调用位置就好了.</strong></li><li>有的需求来来回回改的太多了, 加上后面加了新需求, 旧的代码没有删掉, 新旧代码同时作用导致表现有问题.<ol><li>说的就是回城控制</li></ol></li></ol><h2 id="2023-12"><a href="#2023-12" class="headerlink" title="2023-12"></a>2023-12</h2><ol><li>编译大小分析<ol><li>-fno-loop-optimize这个拖了很久,还搞了个乌龙出来</li><li><em>编译的时候没有-r, 用release和debug版本比较的, 最重要的是通知到群里的是乌龙信息</em></li></ol></li><li>日志分析, 看了看骏鹰的日志清洗相关的内容, 写了一个ES导出脚本, 这下可以一次查询所有的日志了, 还不会占用IO. 顺便把WARN也导出了, 只需要改一个字段.<ol><li><em>这个轮子是真TM的难用. 用开源的你就大大方方的用, 结果旧版本+乱搭配</em></li><li><em>后面还是尽量充当制定规则的, 整好文档, 减少被@的次数</em></li></ol></li><li>深入浅出编译链接, 看了看留了点印象, 但是也不太深</li><li>尝试优化elf文件大小<ol><li><em>大小可以减少, 得看看副作用具体是啥, 文档描述的不太清楚</em></li><li><em>变迁一下, elf是object文件合并的, 直接去统计下object文件获取更好, 已经帮忙分割开了.</em></li><li>两个方面<ol><li>整体优化, 通过添加编译选项, 去除非必要的debug信息</li><li>单独优化, 查看较大的object文件分析原因</li></ol></li></ol></li><li>gdb卡慢的原因分析<ol><li><em>目前来看就是卡在了符号表这里, 首次运行慢, 后续运行快</em></li><li><em>好像是首次跑火焰图</em></li></ol></li><li>C++避免重定义, 定义和声明分开<ol><li>增加inline</li><li>定义放到不会被include的文件中, 如cpp, h文件可能目前没有被include但是将来不一定</li></ol></li><li>小需求<ol><li>死亡军队过期兜底删除<ol><li><em>现在写别人分配的一句话需求, 小心不少了, 基本都会问清楚.</em></li></ol></li><li>城郊拾取不再强行要求有军队</li><li>联盟领地buff</li></ol></li><li>怪物组复活和自动拾取逻辑修改<ol><li>怪物组复活这里最开始通过事件处理已经理不清了, 换成了定时器检测.</li><li>自动拾取这里有一个参数一直都用错了, 最后的目标不一定是击败者</li><li><em>感觉开始处理还是取巧了一些, 结果后面要重写了</em></li></ol></li><li>查看是啥问题导致global更新不上去的, 打包global版本服务器<ol><li><em>很迷的问题, 换成request好了一点</em></li></ol></li><li>竞技场支持怪物组和BOSS<ol><li><em>小需求, 但是这个需求整体还是很大的, 周边系统还是要去看一看</em></li><li>JJC需求</li><li>定时器修改</li></ol></li><li>堡垒刷新bug的修复, <em>当时刷新理解的有偏差, 导致写了bug出来, 进了新的阶段刷新不出新堡垒</em>, 验收和测试也没发现, 最后修的时候真的是火急火燎的.</li></ol><h2 id="2024-1"><a href="#2024-1" class="headerlink" title="2024-1"></a>2024-1</h2><ol><li>整了个编译发布流水线的历史变更记录, 希望能总结出一点东西, 毕竟这个东西变更了太多版本了, 为什么没有一开始一步到位, 是有哪些问题之类的.</li><li>bug部分和up部分都拆出去了, 这里就搞下汇总之类的, bug那边也能写点记录, 方便后续查看</li><li>上周六终于是找了个腾讯学堂的视频看完了, 写了点总结, 这貌似是我接近两年来, 第一次看完历史视频并写笔记? 之前只整理过直播如何写博客的</li><li>占矿<ol><li>起初是想用击败者, <strong>结果参数用错了</strong>, 参数并不是击败者. 不过就算是<strong>用对了, 也会有参数为空的情况出现</strong>.</li><li>改成从战败者的follower中选取, 但是被击败这个事件中, 野怪的follower信息被清理了, 所以提前进行判断, 结果发起的<strong>MoveTo会被后续的覆盖</strong>, 改成立即移动之后依然有问题.</li><li>此外还有一个问题, 依赖战死和取消战斗状态, 提前之后就会被影响.</li><li>直接改成了从玩所有军队中获取, 改回了之前的阶段, 结果军队列表中存在死亡的军队. 过滤了死亡军队目前正常了.</li></ol></li><li>我大意了.jpg<ol><li>事件监听错, 本该是A事件, 结果监听了B事件.</li><li>误删正常代码</li></ol></li><li>考虑不全面<ol><li>参数未判断, 0范围的视野也进行了添加.</li><li>开服日期之前启动服务器, 此时计时器需要为负天数. (这里还出过一个时区的问题)</li><li>恢复为旧的代码时, 旧代码已经不能执行了.</li></ol></li><li>做了没必要的<ol><li>直接过滤掉所有可能阻挡位置的遗忘堡垒点位, 不要为了展示高超的技术写复杂了.(之前做了太多额外功能了 百分比阻挡这些, 直接粗暴点就好)</li></ol></li></ol><h2 id="2024-2"><a href="#2024-2" class="headerlink" title="2024-2"></a>2024-2</h2><ol><li>增加成员变量之后需要考虑,构造函数, 拷贝构造函数, 移动构造函数, 赋值运算符<ol><li>漏掉之后会导致新字段丢失的问题, 比较难查.</li></ol></li><li>添加1和添加2分两步的RPC操作, 添加1到添加2之间会有时间间隔, 添加1之后执行的操作没有添加2的信息.<ol><li>有新增添加或者修改操作的时候, 可能添加1也需要修改, 支持直接添加这些字段, 分两步会有时间间隔.</li></ol></li><li>一些内容可以和策划对, 更简单的实现是否可行<ol><li>从击败军队还是所有军队中选一只去占矿</li></ol></li><li>看了podagent的实现, 本身podagent不需要任何特殊配置, 依托游戏服务器启动时向其中注册(socket)信息.</li></ol><h2 id="2024-3"><a href="#2024-3" class="headerlink" title="2024-3"></a>2024-3</h2><h2 id="2024-4"><a href="#2024-4" class="headerlink" title="2024-4"></a>2024-4</h2>]]></content>
      
      
      <categories>
          
          <category> 个人记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏设计</title>
      <link href="/2023/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="游戏设计"><a href="#游戏设计" class="headerlink" title="游戏设计"></a>游戏设计</h1><h2 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h2><h3 id="可靠UDP的实现"><a href="#可靠UDP的实现" class="headerlink" title="可靠UDP的实现"></a>可靠UDP的实现</h3><p>资料学习<br>TCP为什么可靠<br>超时重传、流量控制和拥塞控制<br>TCP使用基于ACK的方式来处理分组丢失。如果每次只发送一个分组，等到ACK到达后再发送后续分组，这种简单的模式下依然存在着下面的问题。</p><ol><li>要等待ACK多长时间？</li><li>分组或ACK丢失了怎么办？<br>由于网络传输是双向的，发送一个分组后等待ACK，会导致发送方向或接收方向的网络处于相对空闲的状态。为了提高效率，需要向网络中发送多个分组。虽然提升了效率，但也带来了更多的问题</li><li>一次发送多少个分组？</li><li>分组较多时，以什么样的时间间隔发送分组？</li><li>接收方如何知道哪些分组被接收到了，哪些还没有？<br>发送分组数和发送间隔，受接收方处理效率及网络通道处理效率的限制<br>超时重传<br>虽然可以选取过去一段时间分组的平均RTT来预测接下来一段时间分组的平均RTT，但由于平均值的局限性，会存在大量低于和高于平均值的RTT，高于平均值的RTT的分组将会被认为丢失，然而这些分组并没有丢失。所以超时时间应该高于平均RTT。<br>RTO：超时时间<br>RTT：发送后到接收到ACK的时间<br>没有发生超时时，RTO是根据RTT计算得来。发生超时后，为了防止重传二义性的问题，RTO=RTOx2，直到不发生超时，恢复之前的算法。<br>滑动窗口<br>滑动窗口协议解决了问题5。发送窗口中记录着哪些分组已经被确认接收、哪些分组发送了还未被确认接收以及哪些分组已经就绪但还未发送。接收窗口中记录着哪些分组已经被接收和确认，哪些分组将会被接收进而等待确认以及哪些分组无法被接收进而丢弃。<br>不过滑动窗口也带来了下面的问题</li><li>发送和接收窗口应该设置为多大<br>流量控制<br>使用窗口进行流量控制，窗口分为滑动窗口和拥塞窗口。<br>● 滑动窗口的大小（rwnd）表示接收方的缓存大小<br>● 拥塞窗口的大小（cwnd）表示发送后但未被确认的数据包大小<br>发送方发送窗口大小（橙色部分）为接受方接收窗口大小<br>发送方发送后未被确认的数据量（黑框中部分）<br>最终发送的数据量由发送窗口和拥塞窗口中较小的一方限制。</li></ol><p>基于窗口的流量控制<br>为了处理接收方处理效率相对发送方低的问题，使用基于窗口的流量控制。接收方需要告知发送方其接收窗口的大小。这样发送方就可以根据接收方的窗口大小来调整发送窗口的大小。</p><p>基于拥塞控制的流量控制<br>为了处理网络通道之间所有中转设备和线路限制导致的问题，使用拥塞控制来解决。</p><p>TCP高延迟原因<br>TCP协议中规定了，发生超时时，RTO=RTOx2。超时时间的增长，导致数据包在真正丢失时，无法被及时的重传，超时时间越长，无法被及时重传的情况越严重。</p><p>TCP使用ARQ模型中此编号K前所有包已收到。当K+1发生了丢失时，虽然K+2可能已经收到，但发送端无法得知K+2和之后数据包的情况，只能全部重传，进而出现不必要的重发。TCP中的SACK？</p><p>SACK<br><a href="https://www.rfc-editor.org/rfc/rfc2018" target="_blank" rel="noopener">https://www.rfc-editor.org/rfc/rfc2018</a><br>MTU为1500<br>MSS最大为1460<br>TCP额外包头最大为60字节。SACK需要消耗8*n+2字节的额外包头长度，所以理论最多描述4段block，不过由于时间戳消耗10字节的额外包头长度，所以实际为3段block。</p><p>UDP为什么不可靠<br>UDP如何可靠<br>涉及到功能的选择和切换<br>KCP协议<br><a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener">https://github.com/skywind3000/kcp</a></p><p>相关工具<br>丢包模拟</p><h3 id="与平台无关的可靠UDP"><a href="#与平台无关的可靠UDP" class="headerlink" title="与平台无关的可靠UDP"></a>与平台无关的可靠UDP</h3><h2 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h2><h3 id="帧同步的后台设计"><a href="#帧同步的后台设计" class="headerlink" title="帧同步的后台设计"></a>帧同步的后台设计</h3><h3 id="帧同步的前台设置（UE4）"><a href="#帧同步的前台设置（UE4）" class="headerlink" title="帧同步的前台设置（UE4）"></a>帧同步的前台设置（UE4）</h3>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="创造型模式"><a href="#创造型模式" class="headerlink" title="创造型模式"></a>创造型模式</h1><p>单元生抽工厂</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>提供克隆接口, 能够对指定的物体进行克隆生成新物体.</p><h2 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h2><p>相对于工厂模式一次性获取产品, 生成器模式则是可以一步一步对产品进行组装, 组装完成后获取最终的产品.</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>系工厂, 有多个产品, 每个产品提供一个接口.</p><p>一个工厂可以获得本工厂生产的各种产品. 如日系工厂可以提供各种日式家具, 中系工厂可以提供各种中式家具.</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>苹果工厂, 提供统一的苹果生产接口.</p><p>通过向工厂获取接口传入不同的苹果种类, 获取对应的工厂.</p><p>要求红富士返回红富士工厂, 要求糖心苹果返回糖心苹果工厂, 由于都是工厂 所以外部不用关注具体是哪个工厂.</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>元代适外(室外)装桥组</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>将class中重复很多的字段抽取出来, 在多个类中共享这些重复的字段, 减少内存占用</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>经理设置秘书代理自己, 外部人员需要通过秘书向经理递交材料, 秘书还可能会对材料进行归纳总结.</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>给不兼容的物体设置包装类, 包装类能够和原本不兼容的对象协作.</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>复杂的系统提供简单的接口.</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>将一个对象放入封装对象中, 为对象添加新的功能.</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>通过固定的接口, 将一个整体分离成前台和后台, 前后互不关注具体实现, 只关注接口.</p><p>UI界面和操作系统通过一些固定的接口进行交互, UI界面不在乎是什么系统 只要能相应这些接口就行. 操作系统不在乎是什么UI, 只要通过固定的接口向自己发送请求即可.</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>将对象组合成树状结构, 对外一个接口就可能访问到所有叶子.</p><h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><p>模访状任命中备迭观策(模仿状任命中被爹观测)</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>父类中定义算法框架, 子类可以根据需求重写算法特定的步骤.</p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式 ?"></a>访问者模式 ?</h2><p>将算法和所需对象分离开来</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>不暴露底层数据结构的情况下, 遍历所有元素</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>将对象需要状态的操作都抽象出来放到状态父类中, 状态子类中根据自身的状态实现这些操作. 对象不需要关心当前的状态, 只需要根据操作调用对应函数即可, 状态的更新由状态子类负责.</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>将请求沿着处理链进行发送, 每个人都可以处理请求, 或者传递给下个人员.</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>将请求和相关参数包装成独立对象. 对立对象可以将方法参数化 延迟 或者压入队列, 还能实现撤销</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>禁止众多的对象随意互相耦合, 将请求发送给中介者由中介者进行转发. 例如一个塔台和多个飞机交流, 飞机只需要和一个塔台交流就能得知其他飞机的信息.</p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>对象需要实现保存状态和恢复状态的函数. 保存状态的函数将当前状态需要保存的数据生成快照. 管理器调用函数生成快照并保存起来, 当恢复状态的时候读取快照, 应用到对象上.</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>从众多的事件中订阅某个事件, 忽略其他事件.</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>将众多算法放到不同的类中, 是的可以通过简单的操作更换算法.</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间触发器</title>
      <link href="/2023/10/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1-%E6%97%B6%E9%97%B4%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2023/10/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1-%E6%97%B6%E9%97%B4%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>游戏中有许多内容是每天凌晨0点更新, 有些玩法是每天0点都会更新, 有的则需要累积到一定天数才会更新, 累计的天数则是需要进行配置.</p><p>设计一个通用的配置Proto用来统一配置格式, 触发器模型就可以读取这些统一的配置 统一进行天数判断.</p><p>对于每天0点都会更新的, 每天触发一次. 对于累计天数的, 累计天数达到后进行触发.</p><p>触发的时候不主动调用业务代码, 而是采用发布指定事件的方式进行通知.</p><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><pre><code class="protobuf">enum TimeTriggerGamePlay{    TIME_TRIGGER_GAME_PLAY_NONE = 0;    TIME_TRIGGER_GAME_PLAY_NORMAL = 1;    TIME_TRIGGER_GAME_PLAY_REDOUBT = 2;}enum TimeTriggerType{    TIME_TRIGGER_DEFAULT = 0;    // 每小时触发    // TIME_TRIGGER_EVERY_HOUR = 1;    // 每天触发    // TIME_TRIGGER_EVERY_DAY = 2;    // 累计天数触发 从阶段1开始, 阶段2, 阶段3..    TIME_TRIGGER_DAY_ACCUMULATE = 3;}message TimeTriggerConfigItem{    // 所属玩法    TimeTriggerGamePlay trigger_game_play = 1;    // 触发器类型    TimeTriggerType trigger_type = 2;    // 进入新阶段开服天数    repeated int32 trigger_accumulate_day = 3;    // 是否启用    bool is_enable = 4;}message TimeTriggerConfig{    repeated TimeTriggerConfigItem trigger_config_item = 1;}message TimeTriggerMsg{    // 所属玩法    TimeTriggerGamePlay trigger_game_play = 1;    // 触发器类型    TimeTriggerType trigger_type = 2;    int32 now_hour = 3;    int32 now_stage = 4;}</code></pre><p>触发器</p><pre><code class="c++">enum CoreEventMainType{    CEVENT_MT_TIME_TRIGGER}enum CoreEventSubType{    CEVENT_ST_TIME_TRIGGER}// TimeTriggerMsg</code></pre><h1 id="循环定时器"><a href="#循环定时器" class="headerlink" title="循环定时器"></a>循环定时器</h1><p>对于每小时执行函数, 起初的写法是计算出当前小时剩余时间, 之后直接定时一个小时. 但这种方法一旦有时间偏差就会一直存在, 还会将偏差积累下来</p><p>后面改成了每轮循环都要计算下当前小时剩余时间, 这样后面几轮即使有误差 也会被修正过来.</p>]]></content>
      
      
      <categories>
          
          <category> 模块设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间触发器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人UP</title>
      <link href="/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP/"/>
      <url>/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP/</url>
      
        <content type="html"><![CDATA[<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>代码整洁之道中内容很多, 不过这里单单只有命名一节. 被提醒过几次命名不合适, 这部分就着重整理出来, 每次命名的时候都思考思考. 能立刻改善自然最好, 不能立刻也要逐步前进.</p><p><strong>名副其实、避免误导、使用读的出来的名称、避免可爱（要实用）</strong><br>看到名字就知道这个变量是个什么东西，theList就不知道是个什么东西，studentList就好一些。<br>不能变量描述的是A，实际是B。比如给Map类型起名List</p><p><strong>做有意义的区分</strong><br>a1，a2，a3这些就没啥意义，x，y，z就有了<br>book和theBook也没区别</p><p><strong>使用可以搜索的名称</strong><br>找7就非常难找，但是找DAY_PEER_WEEK就好找了</p><p><strong>避免思维映射</strong><br>不要起只有自己能理解的取巧的名称，其他人可能是理解不了的</p><p><strong>方法名使用动词或者动词短语</strong><br>get、set、is</p><p><strong>每个概念对应一个词</strong><br>tower是地图中编码里塔的名称，瞭望塔最好起名watchTower不要和其他冲突了。</p><p><strong>添加有意义的语境</strong><br>name是名字的意思，petName？playerName？无法区分<br>firstName，lastName，street，city，state，这些放一起能看出来是地址，但是单单一个state就看不出来了，不如addrState，或者使用Address类</p><p><strong>命名统一</strong><br>命名要统一，多个人合作的时候要提前商量好，复制粘贴代码后也要注意代码的命名。</p><p><strong>可以直接用机制来命名</strong><br>比如模数余数这些名词</p><p><strong>避免无意义修饰</strong><br>阶段是阶段 等级是等级，不要用阶段等级这种东西</p><p><strong>GPT</strong><br>多用用GPT，这个起名字真的好用, 很有参考价值</p><p><strong>break和nullptr</strong><br>switch-case丢失break, 指针没有判空, 写全新模块的时候基本遇不到, 重灾区是在原有位置加代码.</p><p><strong>注释</strong><br>命名的章节混进来一点点注释, 我感觉问题不大.</p><ol><li>复杂的功能描述下, 不然只有天才能<strong>立刻</strong>知道这一坨代码是干啥的</li><li>其他人或者连自己看起来都很怪的实现, 要说明下原因.</li></ol><h2 id="函数-写故事-反复打磨"><a href="#函数-写故事-反复打磨" class="headerlink" title="函数-写故事-反复打磨"></a>函数-写故事-反复打磨</h2><h3 id="book"><a href="#book" class="headerlink" title="book"></a>book</h3><p><strong>短小</strong><br>避免嵌套太多层</p><p><strong>只做一件事情，做好一件事情</strong><br>编写函数是为了将大一些的概念（函数名称），拆分成另一个抽象层上的一系列步骤。</p><ul><li>函数名下都是同一个抽象层的步骤，实际还是做了一件事。</li></ul><p>检查函数是否只做了一件事，可以看看函数是否可以再拆出一个函数</p><ul><li>函数不仅仅是单纯的重新全是代码，必须<strong>要改变抽象层级</strong></li></ul><p><strong>使用描述性的名称</strong><br>长的具有描述性的名称，比短的令人费解的名称要好。<br>IDE中改名很容易，可以多次修改找到一个最具描述性的名称</p><p><strong>函数参数</strong><br>限制传入bool参数，bool参数表明了，可能存在两个分支，为true一个为false一个，可以考虑拆成函数。<br>给函数取个名字，用来解释函数的意图、<strong>参数和顺序和意图</strong><br>assertEqual改成assertExpectedEqualsActual(Expected，actual)，能够<strong>减少记忆参数顺序的负担</strong>。</p><p><strong>无副作用</strong><br>函数承诺只做一件事情（函数名描述），但是<strong>还会做其他被藏起来的事情（函数名没有描述的）</strong>，这个就是函数会有的副作用。有人轻信了函数的名称，就会有这些藏起来的事情导致的风险。</p><p><strong>减少重复</strong></p><p><strong>结构化编程</strong><br>尽量保证函数只有一个出口，break，continue等语句限制使用。这些在短小函数中影响不是很大，但是在<strong>长函数</strong>中影响很大。</p><p><strong>反复打磨</strong><br>一步到位写出完美的代码是很难的，开始应该注重功能的实现，后面可以进行打磨（拆解函数、消除重复、修改名称）</p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><ol><li>向其他函数增加代码时，如果时独立代码，抽出函数</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="book-1"><a href="#book-1" class="headerlink" title="book"></a>book</h3><p>最好是使用代码本身当作注释，当一行或者一块代码需要注释的时候，可以考虑简化这些代码。<br>注释不能美化代码<br>通过增加变量来进行注释</p><p>错误的注释</p><ul><li>注释可能会误导使用者，错误的注释比起没有注释更麻烦。</li><li>随着代码更新，只改代码不改注释，注释可能无法再与代码对应上</li><li>真正起作用的是代码，不是注释。所以可能出现注释和功能对应不上的问题</li></ul><p>需要注释的地方</p><ul><li>反直觉的代码，这些代码由于某些特殊原因，以反直觉的方式出现</li><li>TODO</li><li>警示作用，某些代码可能具有破坏力</li><li>针对复杂的返回值进行说明（更好的方式是简化返回值）</li></ul><h3 id="经验-1"><a href="#经验-1" class="headerlink" title="经验"></a>经验</h3><ol><li>部分特殊的机制要加说明，不然就只有天才能<strong>立刻知道</strong>这里是什么意思了</li></ol><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ol><li>const能加的就加上吧</li><li>代码还是统一一些<ol><li>判断是不是0 用==0或者if统一一点</li></ol></li><li><strong>空指针这种错误都犯了</strong><ol><li>改一个位置的时候，尤其要注意使用的所有参数，这些参数可能在外面并没有校验</li><li>改代码比新写代码更容易出现</li></ol></li><li><strong>switch语句中丢失break</strong></li><li>注意可能发生死循环代码的兜底<ol><li>服务器更新脚本中就遇到了，重复的更新服务器。</li></ol></li></ol><h1 id="记录总结"><a href="#记录总结" class="headerlink" title="记录总结"></a>记录总结</h1><h2 id="屎山"><a href="#屎山" class="headerlink" title="屎山"></a>屎山</h2><h3 id="指针判空"><a href="#指针判空" class="headerlink" title="指针判空"></a>指针判空</h3><p>使用指针时，一定要注意进行判空</p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>switch中增加case的时候, 注意补齐break</p><h2 id="全新屎山-设计"><a href="#全新屎山-设计" class="headerlink" title="全新屎山-设计"></a>全新屎山-设计</h2><h3 id="需求设计"><a href="#需求设计" class="headerlink" title="需求设计"></a>需求设计</h3><ol><li>看需求文档的时候 根据文档先定协议</li><li>需求理解一定要正确, 仔仔细细逐句逐句的看需求点. 需求点找出来之后，判断好是哪个服务器来做。防止开发重复的事项。</li><li>一些需要多个服务器共同实现的功能，要协商好处理方式。</li><li>查看策划的文档的时候，还是有想当然的内容<ol><li>次数每天1天，上限5次。第1天想当然为5次，结果跟策划确认了是1次，而不是5次。</li></ol></li><li>写代码之前先在vscode进行下预期设计, 比直接撸起袖子写代码好很多.</li><li>看看需求的特殊要求, 比如退盟之后是否重置, 这个影响到了数据记录到哪里.</li><li>考虑下客户端或者其他模块是否能如自己预期提供支持<ol><li>可能预期的内容, 客户端根本没法做, 还是得服务器来做.</li></ol></li><li>考虑下实现的复杂程度, 可能预期很简单, 但是因为牵扯过多或者不支持导致变得复杂.</li><li>A场景下不用处理, 不代表B场景下不用处理</li><li>方案设计应该把框架性的描述到位<ol><li>这次的跨天代码，文档中描述了，但是没有完整描述放到哪里。结果放到了Ext中，后面又改成了Role中。</li></ol></li><li>反复想了很多次 感觉没有问题，然后就没有测试<ol><li>结果还是出了问题，跟预期的一样，把leader和member的标记清掉了</li></ol></li></ol><p><strong>加了新的子类型后没有适配</strong></p><ul><li>看到报错后 也没有去看原因</li><li>加了子类型也没看原有城郊BOSS的特殊处理</li><li>加了子类型也没通知客户端，<strong>应该是更改协议之后都要通知</strong></li></ul><p><strong>方案可能可以用，但是对于目前还能用的代码，这种改动就需要考量下了。</strong><br>现有的敌我判断，只需要在IsEnemy中加几行代码就可以了，大刀阔斧的去改成方案中的设计，可能会遇到很多的问题。<br>改动的时候应该考虑下改动小的方式？而不是去整一套新的方案。<br>复杂的方案为了通用性，后面维护起来也是很麻烦的。</p><h3 id="时间评估"><a href="#时间评估" class="headerlink" title="时间评估"></a>时间评估</h3><p>涉及增加Module + 协议 代码量200~300行 略微修改其他地方 1.5D</p><ol><li>需求拆解和方案评估<ol><li>不能是单单的将需求点列出来，需要对应到具体的改动是啥，这样评估时间才准确。</li><li>注意某些重要的异常情况处理和兜底处理</li></ol></li></ol><h2 id="全新屎山-制作"><a href="#全新屎山-制作" class="headerlink" title="全新屎山-制作"></a>全新屎山-制作</h2><h3 id="通用的机制应该尽可能能够复用"><a href="#通用的机制应该尽可能能够复用" class="headerlink" title="通用的机制应该尽可能能够复用"></a>通用的机制应该尽可能能够复用</h3><ol><li>在ext中新加了一个跨天的功能，但是这个功能其他ext可能也要用，应该放到上一级方便所有ext使用</li><li>终于把之前想过的时间触发器抽了个Module出来, 后面就可以复用了</li></ol><h3 id="一些临时的内容应该加足注释"><a href="#一些临时的内容应该加足注释" class="headerlink" title="一些临时的内容应该加足注释"></a>一些临时的内容应该加足注释</h3><p>比如明明可能有很多配置，按理来说应该是用参数索引，但是写死了，应该说明原因。</p><pre><code class="cpp">// 目前只有1条配置，先写死id为1const auto *config = GetResFactory().FindResStrongpointRewardCfg(1);</code></pre><h3 id="一定要处理好不兼容变更的兜底，如果影响到太多人，容易出问题还是要加上兜底"><a href="#一定要处理好不兼容变更的兜底，如果影响到太多人，容易出问题还是要加上兜底" class="headerlink" title="一定要处理好不兼容变更的兜底，如果影响到太多人，容易出问题还是要加上兜底"></a>一定要处理好不兼容变更的兜底，如果影响到太多人，容易出问题还是要加上兜底</h3><h3 id="预估时间后无法完成-没有及时通知"><a href="#预估时间后无法完成-没有及时通知" class="headerlink" title="预估时间后无法完成 没有及时通知"></a>预估时间后无法完成 没有及时通知</h3><p>应该及时通知，否则认为完成了，后面会出现各种问题。这次就是配置全换掉了 导致半成品的怪物组被启用了</p><h3 id="日志加的不够"><a href="#日志加的不够" class="headerlink" title="日志加的不够"></a>日志加的不够</h3><ol><li>查问题的时候比预期难太多了，后面补了两个主要位置的日志<ol><li>选举队长的位置 增加了旧队长和新队长的状态</li><li>创建怪物组的时候会打印 玩家ID 怪物组ID 怪物组的配置 这样发现问题的时候能够快速定位到创建位置，之后就能看到问题野怪的ID</li></ol></li></ol><h3 id="统一的工具仓库"><a href="#统一的工具仓库" class="headerlink" title="统一的工具仓库"></a>统一的工具仓库</h3><p>以后写工具应该注意，一个工具放两个代码库维护是容易出问题的，能统一尽量统一，统一不了应该只在一个里面修改.</p><h3 id="需求中途变更"><a href="#需求中途变更" class="headerlink" title="需求中途变更"></a>需求中途变更</h3><p>代码设计初期一般会留有一些考虑能够应对需求变化，但是需求变化后可能会导致实现可以简化，这个时候继续服用复杂的代码还是简化代码就需要考虑了</p><h3 id="尽量一步成型代码，后续修改容易顾此失彼，修改了这里忘了其他敌方"><a href="#尽量一步成型代码，后续修改容易顾此失彼，修改了这里忘了其他敌方" class="headerlink" title="尽量一步成型代码，后续修改容易顾此失彼，修改了这里忘了其他敌方"></a>尽量一步成型代码，后续修改容易顾此失彼，修改了这里忘了其他敌方</h3><h3 id="避免设计无用的东西"><a href="#避免设计无用的东西" class="headerlink" title="避免设计无用的东西"></a>避免设计无用的东西</h3><p>给堡垒加了adaptor，然而是一个函数能搞定的判断，多余了</p><h3 id="数值类配置化or计算化"><a href="#数值类配置化or计算化" class="headerlink" title="数值类配置化or计算化"></a>数值类配置化or计算化</h3><ol><li>数值类的最好不要写死<ol><li>如果是配置中的值，配置变了，写死的数值就会导致问题</li><li>还可能导致本来热更就能搞定的，需要重新编译服务器</li></ol></li><li>尽量不要写死参数, 配置或者计算得来, 否则后面还需要同步修改.</li></ol><h3 id="减少通用错误码的使用"><a href="#减少通用错误码的使用" class="headerlink" title="减少通用错误码的使用"></a>减少通用错误码的使用</h3><p>如果错误码一对一能够及时发现问题, 如果是多个地方使用的, 只能靠日志+看代码路径了.</p><h3 id="客户端参数校验"><a href="#客户端参数校验" class="headerlink" title="客户端参数校验"></a>客户端参数校验</h3><p>没想到出现了非联盟成员拆联盟建筑的问题。</p><h3 id="状态校验放错了位置-写的时候还是没考虑好运行路径"><a href="#状态校验放错了位置-写的时候还是没考虑好运行路径" class="headerlink" title="状态校验放错了位置. 写的时候还是没考虑好运行路径"></a>状态校验放错了位置. 写的时候还是没考虑好运行路径</h3><h2 id="全新屎山-装饰"><a href="#全新屎山-装饰" class="headerlink" title="全新屎山-装饰"></a>全新屎山-装饰</h2><h3 id="GM工具"><a href="#GM工具" class="headerlink" title="GM工具"></a>GM工具</h3><ol><li>开发的时候可以考虑好后续可能用到的GM工具，虽然会略微增加开发时间，但是后续用到的时候是真的方便</li><li>GM工具好多都是有使用场景的，非使用场景使用会出现问题，所以还是要标注清楚</li></ol><h2 id="旧屎山-修改"><a href="#旧屎山-修改" class="headerlink" title="旧屎山-修改"></a>旧屎山-修改</h2><h3 id="确定修改后果-注意一个函数都有哪些作用"><a href="#确定修改后果-注意一个函数都有哪些作用" class="headerlink" title="确定修改后果, 注意一个函数都有哪些作用"></a>确定修改后果, 注意一个函数都有哪些作用</h3><p>最大等级的BUG去掉InitModuleDependency中的广播后，确实去掉了开启时候的广播，但导致ClientConfig中的内容也没有被填写上。<br>且由于满阶段nextCheckInterval为0时添加的定时器 又掩盖了这个问题的及时发现 导致后面发现后改的挺急的</p><p>没有调用OnIdle出现的问题，结果加上OnIdle调用后影响到了回城</p><h3 id="把表现正确的当BUG修了"><a href="#把表现正确的当BUG修了" class="headerlink" title="把表现正确的当BUG修了"></a>把表现正确的当BUG修了</h3><p>这种还是要确认好，不然浪费双倍的时间</p><h3 id="删除代码时应该注意-删除原位置无用的内容"><a href="#删除代码时应该注意-删除原位置无用的内容" class="headerlink" title="删除代码时应该注意 删除原位置无用的内容"></a>删除代码时应该注意 删除原位置无用的内容</h3><p>新位置因为需要保证运行，所以一般不会出现问题，但是原位置的多余内容，一般不影响运行，不便于发现。</p><h3 id="查问题的时候-用物体的事件经过查问题挺方便的"><a href="#查问题的时候-用物体的事件经过查问题挺方便的" class="headerlink" title="查问题的时候 用物体的事件经过查问题挺方便的"></a>查问题的时候 用物体的事件经过查问题挺方便的</h3><h3 id="遇到BUG还是感觉留下现场，比重启解决问题更加重要"><a href="#遇到BUG还是感觉留下现场，比重启解决问题更加重要" class="headerlink" title="遇到BUG还是感觉留下现场，比重启解决问题更加重要"></a>遇到BUG还是感觉留下现场，比重启解决问题更加重要</h3><p>问题可以后面解决，复现问题可能再也没有机会了</p><h3 id="BUG修复关联BUG单"><a href="#BUG修复关联BUG单" class="headerlink" title="BUG修复关联BUG单"></a>BUG修复关联BUG单</h3><p>之前删掉了一段代码，导致城郊出现问题，忘记为啥删除的了，后面修BUG还是带上BUG单的链接把</p><h3 id="抽取函数注意不要影响到原区域功能"><a href="#抽取函数注意不要影响到原区域功能" class="headerlink" title="抽取函数注意不要影响到原区域功能"></a>抽取函数注意不要影响到原区域功能</h3><p>抽函数后加东西, 导致相对于原有增加了一些功能, 这种是很危险的抽函数.</p><h3 id="简单方式解决问题"><a href="#简单方式解决问题" class="headerlink" title="简单方式解决问题"></a>简单方式解决问题</h3><p>如果解决一个小bug, 完美的方式改动很多的话, 感觉不如简单的处理下</p><p>长久来说, 还是要考虑下解决这个问题, 算是一个优化点?</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试好了再转单，可能确实把当前问题修了，但导致其他问题出现"><a href="#测试好了再转单，可能确实把当前问题修了，但导致其他问题出现" class="headerlink" title="测试好了再转单，可能确实把当前问题修了，但导致其他问题出现"></a>测试好了再转单，可能确实把当前问题修了，但导致其他问题出现</h3><p>改了BUG不好好验证, 而是急着去查下一个BUG.</p><h3 id="全面测试-不留空缺"><a href="#全面测试-不留空缺" class="headerlink" title="全面测试, 不留空缺"></a>全面测试, 不留空缺</h3><p>战斗无法打起来</p><p>因为战斗无法打起来，好多地方开发的时候都没有测试到，结果反而这里才是问题所在</p><h3 id="A通过B通过不等于A-B通过"><a href="#A通过B通过不等于A-B通过" class="headerlink" title="A通过B通过不等于A+B通过"></a>A通过B通过不等于A+B通过</h3><p>一个功能还是完整的测试吧，A功能虽然等于B+C功能，但B和C功能分别正确 不一定B+C就是正确的</p><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><p>pyclient这个还是很方便的</p><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><h3 id="问题的优先级安排"><a href="#问题的优先级安排" class="headerlink" title="问题的优先级安排"></a>问题的优先级安排</h3><p>下午差城郊防守建筑的BUG查上头了，虽然查出来了但导致了开战距离BUG的延迟了，进而导致了赏金联调的滞后。下午的时候防守建筑的BUG实际可以延后的</p><h3 id="充分关注自己的工作"><a href="#充分关注自己的工作" class="headerlink" title="充分关注自己的工作"></a>充分关注自己的工作</h3><p>赏金都开始联调了，我的功能还没发上去</p><h3 id="不懂就问"><a href="#不懂就问" class="headerlink" title="不懂就问"></a>不懂就问</h3><ol><li>之前一直不知道转测时候填的内容有什么用，导致填的比较随意，导致后面还有同学来提醒，最开始填的时候也确实没有问过。</li><li>还是多问问那个sql语句是啥，原来是描述用的。。。</li></ol><h3 id="重视不起眼的小问题，可能背后的原因是非常离谱的"><a href="#重视不起眼的小问题，可能背后的原因是非常离谱的" class="headerlink" title="重视不起眼的小问题，可能背后的原因是非常离谱的"></a>重视不起眼的小问题，可能背后的原因是非常离谱的</h3><ol><li>dev环境选州Logic崩溃，竟然是由于Logic代码写错的原因（为啥外网没有遇到呢？）</li><li>测试反馈添加的主城全部报错30000，结果是因为roleId循环的，已经添加主城的roleId再次添加主城，由于兜底机制+指定roleId主城存在就会将roleId顺延，顺延之后的就是空roleid，后面就拿不到离线时间的数据</li><li>转表提交报错, 原因是空白行没有被标记占用, 导致新加字段写到了注释行上.</li></ol><h3 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h3><ol><li>野怪最大等级改了获取位置，写代码的将等级为0认为是错误，直接返回了<ol><li>然而赏金这里有特殊处理，等级是0则按1级</li></ol></li></ol><h3 id="预期下当前所做是不是可以解决最终问题-而不是当前某一步"><a href="#预期下当前所做是不是可以解决最终问题-而不是当前某一步" class="headerlink" title="预期下当前所做是不是可以解决最终问题, 而不是当前某一步"></a>预期下当前所做是不是可以解决最终问题, 而不是当前某一步</h3><ol><li>压缩了个超大包, 确实解决了压缩的问题, 但是传输麻烦死了</li></ol><h3 id="去看看别人负责的模块-不要只顾自己的模块"><a href="#去看看别人负责的模块-不要只顾自己的模块" class="headerlink" title="去看看别人负责的模块, 不要只顾自己的模块"></a>去看看别人负责的模块, 不要只顾自己的模块</h3><ol><li>接触了下战斗服和逻辑服的代码, 把相关环境也搭建好了, 后续也确实看过几次对应的代码.</li></ol><h3 id="遇到问题即使下意识感觉问题就是那里-也一定要确认下-可能并不是那样"><a href="#遇到问题即使下意识感觉问题就是那里-也一定要确认下-可能并不是那样" class="headerlink" title="遇到问题即使下意识感觉问题就是那里, 也一定要确认下. 可能并不是那样"></a>遇到问题即使下意识感觉问题就是那里, 也一定要确认下. 可能并不是那样</h3><h2 id="沟通和协作"><a href="#沟通和协作" class="headerlink" title="沟通和协作"></a>沟通和协作</h2><h3 id="他人回复的内容一定要仔细理解，不要含主观臆断"><a href="#他人回复的内容一定要仔细理解，不要含主观臆断" class="headerlink" title="他人回复的内容一定要仔细理解，不要含主观臆断"></a>他人回复的内容一定要仔细理解，不要含主观臆断</h3><ol><li>X场景下，……………………………（省略），这个功能就不需要了。（非X场景是需要的，不能直接删掉这个功能）</li><li>今天晚上就合入版本了（几点？能不能在全量发布服务器前完成，而不是晚上这种模糊时间）</li></ol><h3 id="后台开发代表全部后台-前台开发代表全部前台"><a href="#后台开发代表全部后台-前台开发代表全部前台" class="headerlink" title="后台开发代表全部后台, 前台开发代表全部前台"></a>后台开发代表全部后台, 前台开发代表全部前台</h3><ol><li>后台有多个服务器，每个服务器不同的人负责，前台可能认为后台是一个整体，所以找你沟通的时候最好不要只考虑本服务器的事情。<ol><li>我这里完成了 前台认为所有服务器完成了</li></ol></li><li>对方代码还没合入的时候，你说对面完成了，结果实际没完成</li></ol><h3 id="不兼容变更时做好兜底"><a href="#不兼容变更时做好兜底" class="headerlink" title="不兼容变更时做好兜底"></a>不兼容变更时做好兜底</h3><ol><li>当时在众多人说自己无法进入游戏的时候，都没有去考虑补上兜底方案<ol><li>因为当时考虑到这些都是异常情况，正常情况玩家地图上是不会有自己的主城，只要是正常环境就没有问题</li><li>然而遇到了Logic崩溃了，Logic没有记录选州成功，此时大地图已经选州了，玩家游戏直接卡死，之后才把兜底补上。这次就不是异常情况了，是正常情况下可能会出现的问题了。</li></ol></li><li>重新编译的问题，没想到还学到了不少。<ol><li>tars文件重新生成的问题<ol><li>先用md5比对写了一版</li><li>结果还是直接用CMake写最好，几行的事情</li></ol></li><li>CMake和Make的基本原理</li><li>依赖分析，编译加速？</li></ol></li></ol><h3 id="帮忙"><a href="#帮忙" class="headerlink" title="帮忙"></a>帮忙</h3><p>帮忙处理东西的时候，一定要搞清楚，问清楚。自己也要看清楚，不能只是不带脑子的执行</p><h3 id="不要将问题带到线上，这样处理起来非常的麻烦，而且会增加不靠谱"><a href="#不要将问题带到线上，这样处理起来非常的麻烦，而且会增加不靠谱" class="headerlink" title="不要将问题带到线上，这样处理起来非常的麻烦，而且会增加不靠谱"></a>不要将问题带到线上，这样处理起来非常的麻烦，而且会增加不靠谱</h3><ol><li>异常情况处理</li><li>兜底</li></ol><h3 id="该找运维的找运维-对应的时间给对应的人去做"><a href="#该找运维的找运维-对应的时间给对应的人去做" class="headerlink" title="该找运维的找运维(对应的时间给对应的人去做)"></a>该找运维的找运维(对应的时间给对应的人去做)</h3><ol><li>最后日志传输工作给了运维来搞</li></ol><h3 id="有的功能大地图并不知道有没有-还是说下不知道之类的吧-最后接下来了发现是别人的工作"><a href="#有的功能大地图并不知道有没有-还是说下不知道之类的吧-最后接下来了发现是别人的工作" class="headerlink" title="有的功能大地图并不知道有没有, 还是说下不知道之类的吧, 最后接下来了发现是别人的工作"></a>有的功能大地图并不知道有没有, 还是说下不知道之类的吧, 最后接下来了发现是别人的工作</h3><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="CR发起前可以自己整一个临时CR看看代码"><a href="#CR发起前可以自己整一个临时CR看看代码" class="headerlink" title="CR发起前可以自己整一个临时CR看看代码"></a>CR发起前可以自己整一个临时CR看看代码</h3><h3 id="测试代码在最终CR的时候要及时去掉-使用TODO-名字方便检索"><a href="#测试代码在最终CR的时候要及时去掉-使用TODO-名字方便检索" class="headerlink" title="测试代码在最终CR的时候要及时去掉 使用TODO 名字方便检索"></a>测试代码在最终CR的时候要及时去掉 使用TODO 名字方便检索</h3><h3 id="不建议手动操作自动化代码"><a href="#不建议手动操作自动化代码" class="headerlink" title="不建议手动操作自动化代码"></a>不建议手动操作自动化代码</h3><ol><li>流水线异常的时候手动操作了报错部分，然而报错导致后续操作也被中断了，但是忘记了操作后续部分，只操作了报错部分<ol><li>流水线都现成的了 直接用吧 别手动操作了</li></ol></li></ol><h3 id="自动化操作没有监管人"><a href="#自动化操作没有监管人" class="headerlink" title="自动化操作没有监管人"></a>自动化操作没有监管人</h3><p>新版服务器未更新到目标服务器 出了N个乌龙BUG单</p><h3 id="压测和扩容"><a href="#压测和扩容" class="headerlink" title="压测和扩容"></a>压测和扩容</h3><ol><li>压测<ol><li>压测场景和实际场景不匹配<ol><li>出现问题之后，都能发现问题，关键是出现问题前发现限制点</li></ol></li></ol></li><li>扩容<ol><li>寻路服爆炸了，然而没有办法扩容，没有机器。</li></ol></li></ol><h3 id="发现问题比解决问题更重要"><a href="#发现问题比解决问题更重要" class="headerlink" title="发现问题比解决问题更重要"></a>发现问题比解决问题更重要</h3><ol><li>性能优化感觉难点是发现性能问题, 包括编译加速. (20%的问题造成了80%的负面影响, 如果去处理另外80%的问题收益就很低)</li></ol><h3 id="指定时间点触发的循环定时器-每轮都计算下时间相比固定时间的更加稳定"><a href="#指定时间点触发的循环定时器-每轮都计算下时间相比固定时间的更加稳定" class="headerlink" title="指定时间点触发的循环定时器, 每轮都计算下时间相比固定时间的更加稳定"></a>指定时间点触发的循环定时器, 每轮都计算下时间相比固定时间的更加稳定</h3><h3 id="主城周围搜索物体-采用涡旋状搜索-类似蚊香"><a href="#主城周围搜索物体-采用涡旋状搜索-类似蚊香" class="headerlink" title="主城周围搜索物体, 采用涡旋状搜索, 类似蚊香"></a>主城周围搜索物体, 采用涡旋状搜索, 类似蚊香</h3><h3 id="尽量统一函数对统一内容进行清除-比如标志位-这样方便发现错误清理的地方"><a href="#尽量统一函数对统一内容进行清除-比如标志位-这样方便发现错误清理的地方" class="headerlink" title="尽量统一函数对统一内容进行清除, 比如标志位, 这样方便发现错误清理的地方"></a>尽量统一函数对统一内容进行清除, 比如标志位, 这样方便发现错误清理的地方</h3><h3 id="测试东西或者搞新东西的时候-注意不要影响到旧的东西-该开测试空间的开测试空间"><a href="#测试东西或者搞新东西的时候-注意不要影响到旧的东西-该开测试空间的开测试空间" class="headerlink" title="测试东西或者搞新东西的时候, 注意不要影响到旧的东西, 该开测试空间的开测试空间"></a>测试东西或者搞新东西的时候, 注意不要影响到旧的东西, 该开测试空间的开测试空间</h3><p>这次自动提单提了2K+, 如果不是提到了临时空间 估计直接爆炸了.</p><h2 id="充电"><a href="#充电" class="headerlink" title="充电"></a>充电</h2><ol><li>输入<ol><li>代码</li><li>CR</li><li>方案拆解和评估</li><li>KM文章</li><li>开源项目</li></ol></li></ol><p><strong>123</strong></p><ol><li>有输入相比自己死磕能够成长的更快<ol><li>看看其他人的方案拆解<ol><li>不能同一帧将所有点位检查这种情况，才想到要延时进行刷新。</li><li>不能是单单的将需求点列出来，需要对应到具体的改动是啥，这样评估时间才准确。</li><li>注意下时间评估这里，目前我评估的时间还是非常的不准确的</li></ol></li><li>看看其他人的cr，不然自己没有负责过的模块 是一点都不清楚<ol><li>同时看了之后还有和其他人PK的机会</li><li>看看其他人的设计，学一学自己将来才可能遇到，不然都是在自己思维下兜圈子</li><li>看看别人的CR和方案，这里为什么这么设计，自己想的话如何设计，一下对比就出来了。进行后续沟通还能了解到更多。</li></ol></li></ol></li><li>之前看到帝国觉醒只是想到了战斗服需要在压力场景下减少发包<ol><li>但是大地图是不是需要呢？完全没有考虑过，大地图是否需要<ol><li>大地图实际是不需要的，至少目前的同步机制是够用的</li><li>战斗服可能是需要的，不过后面就没跟进了解了</li></ol></li></ol></li><li>千人测试的时候，重启城郊会导致战斗服也需要重启的问题</li><li>千人测试的时候，Logic崩溃导致事件完成了任务没有完成</li></ol>]]></content>
      
      
      <categories>
          
          <category> 个人记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用命令</title>
      <link href="/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="Clion-将Windows换行转换为Linux模式"><a href="#Clion-将Windows换行转换为Linux模式" class="headerlink" title="Clion-将Windows换行转换为Linux模式"></a>Clion-将Windows换行转换为Linux模式</h2><p><a href="https://stackoverflow.com/questions/2517190/how-do-i-force-git-to-use-lf-instead-of-crlf-under-windows" target="_blank" rel="noopener">how-do-i-force-git-to-use-lf-instead-of-crlf-under-windows</a></p><pre><code class="shell">git config --global core.eol lfgit config --global core.autocrlf inputgit rm -rf --cached .git reset --hard HEAD</code></pre><h2 id="VIM-amp-zsh设置"><a href="#VIM-amp-zsh设置" class="headerlink" title="VIM&amp;zsh设置"></a>VIM&amp;zsh设置</h2><p>VIM</p><pre><code class="vim">set expandtabset ts=4set shiftwidth=4set sts=4set tw=100set numberset cinoptions=:0,g0,(0,w1set backspace=indent,eol,start&quot; set smartindentset autoindentset cindentset softtabstop=4set tabstop=4set enc=utf-8set nocompatiblesyntax onset fileencodings=ucs-bom,utf-8,gb18030,latin1set nobackupset undofileset undodir=~/.vim/undodirif !isdirectory(&amp;undodir)    call mkdir(&amp;undodir, &#39;p&#39;, 0700)endifif has(&quot;autocmd&quot;)  au BufReadPost * if line(&quot;&#39;\&quot;&quot;) &gt; 0 &amp;&amp; line(&quot;&#39;\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g`\&quot;&quot; | endifendifset pastetoggle=&lt;F2&gt;</code></pre><p>ZSH</p><pre><code class="zsh">plugins=(git zsh-autosuggestions zsh-syntax-highlighting autojump)</code></pre><h2 id="Make设置install指定文件"><a href="#Make设置install指定文件" class="headerlink" title="Make设置install指定文件"></a>Make设置install指定文件</h2><p><code>make install &lt;name&gt;</code></p><p><a href="https://stackoverflow.com/questions/9190098/for-cmakes-install-command-what-can-the-component-argument-do" target="_blank" rel="noopener">for-cmakes-install-command-what-can-the-component-argument-do</a></p><pre><code class="Makefile">install(TARGETS main RUNTIME DESTINATION ./install_dir/ COMPONENT main)add_custom_target(install_main COMMAND ${CMAKE_COMMAND} -DCOMPONENT=main -P ${CMAKE_BINARY_DIR}/cmake_install.cmake)</code></pre><h2 id="lsof-iftop"><a href="#lsof-iftop" class="headerlink" title="lsof iftop"></a>lsof iftop</h2><pre><code class="shell"># lsoflsof -i tcp:10002 -P-P 不解析端口号，直接显示# iftop-P 显示端口号-N 不解析端口号l 输入fileter，可以直接输入ip</code></pre><h2 id="安卓adb抓包"><a href="#安卓adb抓包" class="headerlink" title="安卓adb抓包"></a>安卓adb抓包</h2><pre><code class="shell">adb connect 127.0.0.1:port # （连接指定机器）adb devices # (列出所有设备)adb shell # （进入机器中 打开shell）adb push tcpdump /sdcard/... # (推送文件)adb pull /sdcard/1.pcap . # （拉取文件到本地）# wireshark左下角的灯是可以点的，可以列出来可疑项目</code></pre><p>抓取https(没有成功, 也还是记录一下)</p><pre><code class="shell"># https://github.com/frida/frida/releases 下载frida-server 注意要到非sdcard目录 否则不会给运行权限# adb后运行./frida-server# pip3 install frida-tools# 这条会自动启动目标app 所以tcpdump要提前准备好# 将产出的秘钥保存起来, Wireshark-Protocol-TLS 最下方加载frida -U -f jp.ne.paypay.android.app -l .\1.js</code></pre><pre><code class="text">// 1.jsfunction startTLSKeyLogger(SSL_CTX_new, SSL_CTX_set_keylog_callback) {    console.log(&quot;start----&quot;)    function keyLogger(ssl, line) {        console.log(new NativePointer(line).readCString());    }    const keyLogCallback = new NativeCallback(keyLogger, &#39;void&#39;, [&#39;pointer&#39;, &#39;pointer&#39;]);    Interceptor.attach(SSL_CTX_new, {        onLeave: function(retval) {            const ssl = new NativePointer(retval);            const SSL_CTX_set_keylog_callbackFn = new NativeFunction(SSL_CTX_set_keylog_callback, &#39;void&#39;, [&#39;pointer&#39;, &#39;pointer&#39;]);            SSL_CTX_set_keylog_callbackFn(ssl, keyLogCallback);        }    });}startTLSKeyLogger(    Module.findExportByName(&#39;libssl.so&#39;, &#39;SSL_CTX_new&#39;),    Module.findExportByName(&#39;libssl.so&#39;, &#39;SSL_CTX_set_keylog_callback&#39;))</code></pre><h2 id="安装Prometheus"><a href="#安装Prometheus" class="headerlink" title="安装Prometheus"></a>安装Prometheus</h2><pre><code class="sh">docker run -d -p 9090:9090 -v /data/prometheus/prometheus.yml:/data/prometheus/prometheus.yml -v /data/prometheus:/data/prometheus --user root --name prometheus prom/prometheus --config.file=/data/prometheus/prometheus.yml --storage.tsdb.path=/data/prometheus</code></pre><h2 id="火焰图生成"><a href="#火焰图生成" class="headerlink" title="火焰图生成"></a>火焰图生成</h2><pre><code class="sh"># -g enables call-graph recording -p pidperf record -F 99 -g -p 28470perf script &gt; perf.unfoldgit clone https://github.com/brendangregg/FlameGraph.git./stackcollapse-perf.pl perf.unfold &gt; perf.fold./flamegraph.pl perf.fold &gt; perf.svg</code></pre><h2 id="文件大小分析"><a href="#文件大小分析" class="headerlink" title="文件大小分析"></a>文件大小分析</h2><pre><code class="sh">objdump -dwarf=info XXXServer &gt; XXXServer.inforeadelf -e XXXServer# cmake选项-femit-struct-debug-baseonly</code></pre><h1 id="APK"><a href="#APK" class="headerlink" title="APK"></a>APK</h1><pre><code class="sh">keytool -genkey -v -keystore example-release-key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias example-key-aliasapksigner sign --ks example-release-key.jks --ks-key-alias example-key-alias --out example-signed.apk example.apkapksigner verify example-signed.apk</code></pre>]]></content>
      
      
      <categories>
          
          <category> 个人记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bpf</title>
      <link href="/2023/10/Linux-ebpf/"/>
      <url>/2023/10/Linux-ebpf/</url>
      
        <content type="html"><![CDATA[<pre><code class="shell"># 查看内核版本# 一定要和最后install的版本一致$ uname -r4.18.0-348.7.1.el8_5.x86_64# 搜索包并显示版本$ yum search kernel-devel --showduplicates# 这个版本最匹配kernel-devel-4.18.0-348.7.1.el8_5.x86_64# 使用包含版本的完整包名安装$ yum install kernel-devel-4.18.0-348.7.1.el8_5.x86_64# header和devel版本一致$ yum install kernel-headers-4.18.0-348.7.1.el8_5.x86_64$ yum install -y bcc-tools# 加入环境目录,在~/.bashrc加入：$ export PATH=$PATH:/usr/share/bcc/tools/# 安装好后尝试执行下$ execsnoop</code></pre><p>BPF  实际起作用的一些代码，内核提供的接口。</p><p>BCC bpftrace  BPF前端</p><h2 id="BCC工具60秒快速检查"><a href="#BCC工具60秒快速检查" class="headerlink" title="BCC工具60秒快速检查"></a>BCC工具60秒快速检查</h2><h4 id="快速查看负载情况-1min-5min-15min"><a href="#快速查看负载情况-1min-5min-15min" class="headerlink" title="快速查看负载情况 1min 5min 15min"></a>快速查看负载情况 1min 5min 15min</h4><pre><code class="shell">$ uptime 10:45:40 up 205 days, 54 min,  1 user,  load average: 0.18, 0.16, 0.20</code></pre><p>如果1min的负载高于5min或者15min，说明当前正是高负载。</p><p>如果1min的负载低于5min或者15min，说明错过了高负载的现场，后续查看的数据都是非高负载情况的数据。</p><h4 id="查看当前机器的错误信息"><a href="#查看当前机器的错误信息" class="headerlink" title="查看当前机器的错误信息"></a>查看当前机器的错误信息</h4><pre><code class="shell">$ dmesg -T | tail -n 10</code></pre><p>T 打印可读的时间戳</p><h4 id="查看总体内存占用-总体CPU使用占比"><a href="#查看总体内存占用-总体CPU使用占比" class="headerlink" title="查看总体内存占用, 总体CPU使用占比"></a>查看总体内存占用, 总体CPU使用占比</h4><p>查看核心数量</p><pre><code class="shell">$ cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq 获取物理核心数量$ cat /proc/cpuinfo | grep &quot;processor&quot;　获取逻辑核心数量</code></pre><p>vmstat</p><pre><code class="shell">$ vmstat 1procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 1  0      0 253240 141064 1181400    0    0    79   101    0    0  2  2 96  0  0 0  0      0 252216 141064 1181404    0    0     0     0  881 1401  1  2 98  0  0 0  0      0 254328 141064 1181404    0    0     0     0  916 1397  1  1 98  0  0 0  0      0 254436 141064 1181416    0    0     0   152 1480 1894  3  8 88  1  0 0  1      0 254504 141064 1181412    0    0     8   488 1180 1743  2  2 96  1  0 0  0      0 254568 141064 1181412    0    0     0   128 1059 1667  2  1 97  1  0 0  0      0 254692 141064 1181412    0    0     0     0 1056 1723  1  1 98  0  0</code></pre><p>第一行数据由于工具的启动　不准确</p><ul><li>r 等待时间片的进程数量（等待IO时是睡眠状态，不需要等待时间片，所以这里不含阻塞在IO的进程） 大于CPU核心数量说明饱和。</li><li>free 单位KB 数字很大到不容易换算到GB说明内存充足 具体看free -m</li><li>si so 换入换出的数量, 非0时说明内存不足</li><li>us sy id wa st 用户 系统 空闲 等待IO 偷取时间 IO处理需要系统时间, 系统占比高可能指向系统IO效率低</li></ul><h4 id="分核心查看CPU占比-yum-install-sysstat"><a href="#分核心查看CPU占比-yum-install-sysstat" class="headerlink" title="分核心查看CPU占比 (yum install sysstat)"></a>分核心查看CPU占比 (yum install sysstat)</h4><pre><code class="shell">$ mpstat -P ALL 102:04:24 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle02:04:25 PM  all    0.99    0.00    0.50    0.00    0.00    0.50    0.00    0.00    0.00   98.0202:04:25 PM    0    0.98    0.00    0.98    0.00    0.00    0.98    0.00    0.00    0.00   97.0602:04:25 PM    1    1.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   99.00Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idleAverage:     all    4.64    0.00    1.31    0.28    0.53    0.17    0.00    0.00    0.00   93.07Average:       0    3.13    0.00    1.51    0.17    0.56    0.17    0.00    0.00    0.00   94.46Average:       1    6.14    0.00    1.12    0.39    0.50    0.17    0.00    0.00    0.00   91.68</code></pre><p>单个核心占用高, 指向单线程的问题</p><h4 id="分进程查看CPU占比"><a href="#分进程查看CPU占比" class="headerlink" title="分进程查看CPU占比"></a>分进程查看CPU占比</h4><pre><code class="shell">$ pidstat 102:06:42 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command02:06:43 PM     0     50128    1.00    0.00    0.00    0.00    1.00     1  qbittorrent-nox02:06:43 PM     0   1583327    0.00    1.00    0.00    0.00    1.00     1  YDService02:06:43 PM     0   1641467    0.00    1.00    0.00    0.00    1.00     0  barad_agent02:06:43 PM     0   3314936    0.00    1.00    0.00    0.00    1.00     1  pidstatAverage:      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  CommandAverage:        0        42    0.00    0.12    0.00    0.00    0.12     -  kworker/0:1H-kblockdAverage:        0       623    0.00    0.12    0.00    0.00    0.12     -  systemd-journalAverage:        0       948    0.38    0.12    0.00    0.12    0.50     -  tunedAverage:        0     50128    0.62    0.12    0.00    0.00    0.75     -  qbittorrent-noxAverage:        0   1583327    0.38    0.38    0.00    0.00    0.75     -  YDServiceAverage:        0   1641467    0.38    0.38    0.00    0.00    0.75     -  barad_agentAverage:        0   3202896    0.12    0.00    0.00    0.00    0.12     -  nodeAverage:        0   3313606    0.00    0.12    0.00    0.12    0.12     -  kworker/1:0-eventsAverage:        0   3314936    0.12    0.38    0.00    0.00    0.50     -  pidstat</code></pre><p>相比top, pidstat会将解锁保存到shell的缓冲区 方便观察变化趋势</p><h4 id="查看磁盘占用"><a href="#查看磁盘占用" class="headerlink" title="查看磁盘占用"></a>查看磁盘占用</h4><pre><code class="shell">$ iostat -xz 1</code></pre><p>%util 磁盘使用率<br>avgqu-sz 提交的任务数量, 超过1可能代表有问题</p><p>异步IO可能导致性能问题, 因为发起后操作系统不会拒绝, 且一个线程因为不被阻塞可以批量发起.</p><h4 id="查看内存占用"><a href="#查看内存占用" class="headerlink" title="查看内存占用"></a>查看内存占用</h4><pre><code class="shell">$ free -mh              total        used        free      shared  buff/cache   availableMem:          7.3Gi       5.8Gi       332Mi       3.0Mi       1.1Gi       1.2GiSwap:            0B          0B          0B</code></pre><h4 id="网卡占用"><a href="#网卡占用" class="headerlink" title="网卡占用"></a>网卡占用</h4><pre><code class="shell">$ sar -n DEV 102:21:23 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil02:21:24 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.0002:21:24 PM      eth0     56.00     50.00     17.92     12.95      0.00      0.00      0.00      0.0002:21:24 PM cni-podman0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutilAverage:           lo      8.43      8.43      0.75      0.75      0.00      0.00      0.00      0.00Average:         eth0     46.50     43.90      7.77     10.48      0.00      0.00      0.00      0.00Average:    cni-podman0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</code></pre><p>rxkB/s    txkB/s    收发速率</p><h4 id="网络连接建立和重传"><a href="#网络连接建立和重传" class="headerlink" title="网络连接建立和重传"></a>网络连接建立和重传</h4><pre><code class="shell">$ sar -n TCP,ETCP 102:25:04 PM  active/s passive/s    iseg/s    oseg/s02:25:05 PM      0.00      1.00      5.00      5.0002:25:04 PM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s02:25:05 PM      0.00      0.00      0.00      0.00      0.00Average:     active/s passive/s    iseg/s    oseg/sAverage:         0.50      0.75     10.50      9.75Average:     atmptf/s  estres/s retrans/s isegerr/s   orsts/sAverage:         0.00      0.00      0.00      0.00      0.25</code></pre><ul><li>active/s TCP连接connect速度</li><li>passive/s TCP连接accept速度</li><li>retrans/s 重传数量</li></ul><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>提供的数据很多, 但是一直再刷新, 导致很难看到变化相关. </p><p>Ctrl-S pause Ctrl-Q continue</p><h2 id="追踪系统调用"><a href="#追踪系统调用" class="headerlink" title="追踪系统调用"></a>追踪系统调用</h2><pre><code class="shell">#  追踪write系统调用 且筛选打开了文件描述符2的进程 strace -fe write `lsof -t &quot;/proc/$$/fd/2&quot; |sed &#39;s/^/-p/&#39;` -o write2.log# rdi是系统调用第一个参数 其次为rsi rdx r10 r8 r9b write if $rdi == 2# 8个字节 x 16进制 b以bytes为单位打印 x /8xb ptr</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构</title>
      <link href="/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%9E%B6%E6%9E%84/"/>
      <url>/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>skynet 这个还没有看过</p><h2 id="游戏服务器端"><a href="#游戏服务器端" class="headerlink" title="游戏服务器端"></a>游戏服务器端</h2><h3 id="热更"><a href="#热更" class="headerlink" title="热更"></a>热更</h3><ul><li>函数替换</li><li>配置热更</li></ul><p>inject替换函数，配置热更</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul><li>日志压缩</li><li>战斗回放</li></ul><p>尽量详尽的日志</p><h3 id="监控和报警"><a href="#监控和报警" class="headerlink" title="监控和报警"></a>监控和报警</h3><p><strong>服务器是否有卡顿的现象</strong></p><p>客户端请求的平均响应速度</p><p><strong>玩家行为和投放监控</strong></p><p>某些操作是否超过了预期的设定，比如奖励获取等</p><h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h3><p>架构容错（服务器和进程挂掉了），外部服务挂掉（DB），异常情况下的保底逻辑，保证服务的整体可用</p><p>功能开关，关闭异常功能 修复后再打开。</p><p>玩家行为超出预期（所有列表都加个上限，操作频率上限）</p><p>系统行为超出预期（封号频率超过预期后需要预警）</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>不需要实时的系统，可用做成异步。（原神的抽卡记录就是非实时的）</p><p>一些排行榜更新也不一定需求实时，可以收集数据后每隔一段排行一次，（小优化？玩家本人的排行榜可以前台坐下处理进行预排行 让玩家以为看到的数据实时更新了？）</p><h3 id="消除单点和水平扩展"><a href="#消除单点和水平扩展" class="headerlink" title="消除单点和水平扩展"></a>消除单点和水平扩展</h3><p>集群的承载上限是集群中逻辑单点的承载上限，游戏架构设计中要尽可能的消除单点。存在单点是由于一些数据需要统计进行处理。水平拓展的方式能够增强稳定性，一个node挂掉不影响其他node。</p><p>消除单点的方式</p><ul><li>加一层分发逻辑，使用master服务器将请求分发到不同的node上，master服务器处理的逻辑简单、承载能力强，具体的操作交由node服务器处理</li><li>使用无状态，将数据和逻辑分离，逻辑执行时去db读取数据。上面的master服务器虽然依然是单点，但由于数据处理简单可以使用无状态的方式组建多组master-node服务器。</li></ul><p>游戏服务器中不需要消除所有的单点，只需要服务器的性能满足要求即可，避免过度优化。优化是需要开发和运维成本的。</p><h3 id="功能解耦和隔离"><a href="#功能解耦和隔离" class="headerlink" title="功能解耦和隔离"></a>功能解耦和隔离</h3><p>对于互不影响的功能（登录和创建队伍）可以拆分成多个服务。对于互相影响的功能（玩家个人逻辑，强化装备、锻造装备都需要操作玩家背包的多个数据）存在同一服务中，使用服务中模块的方式将这些操作隔离开。</p><p>服务之间进程隔离和线程隔离。</p><ul><li>线程隔离的不同服务之间可以通过函数调用的方式交互，不会存在RPC请求可能出现的失败情况。但是服务之间的隔离不是很强。</li><li>进程隔离的不同服务之间交互复杂，可能存在失败的情况，进程数量过多，增加管理和维护成本。但是隔离程度很高。</li></ul><p>隔离</p><ul><li>将服务分组，同组服务器放在同一进程中，不同组服务放到不同的进程中。</li><li>对于性能消耗高的服务，进行隔离，防止CPU打满影响到本线程的其他服务。</li><li>低于不稳定的服务器进行隔离，减少对稳定服务的影响。</li></ul><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>对于可能卡死服务的调用，应该使用超时机制，否则A服务出现问题B服务卡死，B服务卡死C服务器跟着卡死，就会出现雪崩影响到众多的功能。</p><p>超时的情况</p><ul><li>接受方没有接收到请求</li><li>接受方接收到了但是没有回应</li><li>请求放没有收到接受方的回应</li></ul><p>超时的处理方法</p><ul><li>忽略</li><li>重试</li></ul><p>由于要保证幂等性，重试逻辑很复杂。所以对于重要的服务才需要考虑重试，不重要的服务还是尽量选择忽略。使用超时后应该将游戏系统进行分割，对于核心的功能还是不要使用，非核心功能可以使用超时。</p><h3 id="回档"><a href="#回档" class="headerlink" title="回档"></a>回档</h3><p>使用了Redis的时候回档怎么解决。</p><h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><p>多级灰度环境，范围较大的改动 先在在灰度环境中上线 一段时间后 没有问题就可以正式上线了。</p><p>这里就涉及到了如何让部分玩家不进入正式环境而是进行灰度环境（测试服？直接修改玩家连接的服务器？）</p><p>如第一级灰度环境-公司内测试人员，第二级灰度-在线随机挑选。</p><h3 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h3><ul><li>开服，创建和登录账号 排队系统</li><li>广播，开服的时候人非常多 可以减少范围或者服务降级</li><li>玩家聚集，优化同步策略，逻辑分线</li><li>单点服务，会将部分CPU跑满并且出现一核有难八核围观的情况。</li><li>数据上限，各种列表设置上限，否则可能出现预期外的情况，好友列表爆满</li><li>全服玩家操作，如全服发送邮件等</li></ul><h3 id="动态扩容和缩容"><a href="#动态扩容和缩容" class="headerlink" title="动态扩容和缩容"></a>动态扩容和缩容</h3><p>最好的情况是根据负载情况动态缩扩容，但目前的情况是冗余的服务器也是需要开销的，所以需要考虑的还是有部分的。</p><ul><li>云服务器可用区限制，同一个区域的机器可以使用内网IP访问，跨区域只能使用公网IP，这就涉及到了跨区域支持</li><li>动态缩容，将服务器标记为不可用，同时等到其中的玩家减少到一定程度后踢玩家下线（无感知），最后极少的玩家可以选择强制下线（可能有感知），也是分级的策略</li><li>自动化流程支持</li></ul><h2 id="服务端架构"><a href="#服务端架构" class="headerlink" title="服务端架构"></a>服务端架构</h2><h3 id="全区全服"><a href="#全区全服" class="headerlink" title="全区全服"></a>全区全服</h3><p>战斗服多地区混合部署, 玩家自动选择最优地区的服务器进行连接.</p><ul><li><p>战斗机房多Central共享使用</p></li><li><p>各个Central使用匹配服决定战斗地区(同地区, 同语言文化区域, 同首选战斗, 扩大匹配区域, 同Central)</p><ul><li>战斗机房网络中断: Central间心跳探测</li><li>客户端连接失败: 客户端到pingsvr的探测</li></ul></li><li><p>测不准</p><ul><li>机房到机房的探测数据不能代表用户到机房</li><li>历史数据变动大, 可信度不高</li></ul></li><li><p>合作难</p><ul><li>中小运营商众多</li><li>基建参差不齐</li></ul></li><li><p>变量多</p><ul><li>用户网络问题</li><li>手机杂乱</li><li>网络跨地区</li><li>物理故障</li></ul></li></ul><p>客户端到服务器</p><ul><li>预表现: 位置同步 技能前摇 拉扯. (降低抖动影响)</li><li>帧缓存: 针对网络环境动态调整缓存帧数量. (降低抖动影响)</li><li>协议优化. (减少下行包大小)<ul><li>精简帧: 减少不必要发包</li><li>数据压缩</li></ul></li><li>上行包优化. (降低丢包影响)<ul><li>根据重要程度对重要包使用可靠传输, 对不重要包采用非可靠传输</li><li>预测丢包, 进行快速ARQ</li></ul></li><li>下行包优化<ul><li>根据网络情况, 动态调整冗余端口. (降低抖动影响)</li><li>对网路丢包 拥塞进行也测, 动态调整补帧策略. (降低抖动影响)</li><li>网络不稳定时, 提高发包帧率. (降低抖动影响)</li><li>空帧合并通知. (改善传输效率)</li><li>不需要的重复操作包, 服务器进行合并或过滤. (减少下行包大小)</li><li>采用占用流量更小的冗余算法(FEC, Erasure Coding)(减少下行包大小)</li></ul></li><li>手机系统优化 (提升特定机型流畅度)</li><li>厂家硬件优化 (提升特定机型流畅度)<ul><li>天线, 网卡, 驱动, CPU调度等</li></ul></li><li>Linux系统调优 (降低抖动概率)<ul><li>绑定核心, 避免跨NUMA, 利用cpu cache, 网络多队列, 进程</li></ul></li><li>多机房部署 (降低延迟和丢包)<ul><li>多机房部署, 就近连接</li></ul></li></ul><p>从TCP/IP四层来看</p><ul><li>应用层<ul><li>表现层<ul><li>预表现</li><li>帧率优化</li></ul></li><li>逻辑层<ul><li>帧缓存</li></ul></li><li>帧同步网络层<ul><li>协议优化</li><li>上行包优化</li><li>下行包优化</li></ul></li></ul></li><li>系统调度层<ul><li>手机系统调优</li><li>Linux系统调优</li></ul></li><li>网络层<ul><li>MTU探测</li></ul></li><li>传输层<ul><li>网路诊断</li><li>TCP/UDP双发</li></ul></li><li>硬件层<ul><li>厂家硬件优化</li><li>多机房部署</li><li>云硬件优化</li></ul></li></ul><h3 id="预表现"><a href="#预表现" class="headerlink" title="预表现"></a>预表现</h3><ol><li>安全</li><li>流畅</li><li>多客户端一致</li></ol><p><strong>位置</strong></p><p>服务器每帧发送物体的速度和位置. AB帧之间, 客户端使用A帧的速度进行平滑移动. 收到B帧的时候, 使用B帧的位置以及时间偏差x速度计算物体真实位置. 时间偏差是服务器B帧结束到客户端收到B帧的时间差<code>当前时间 - (游戏开始时间 + 帧号 * 每帧时间)</code>.</p><p><strong>子弹</strong></p><p>只需要子弹的出生位置和速度就可以同步计算. 客户端负责计算特效, 服务器负责计算受伤信息.</p><p><strong>优化</strong></p><p>减少移动包: 从每个操作都发送 -&gt; 状态改变的时候发送</p><p><strong>弱网处理</strong></p><ol><li><p>延迟过大的时候进行提示</p></li><li><p>游戏开始时间受游戏开始包控制, 然而这个包的延迟是不确定的. 可以反推游戏开始时间, <code>当前时间 - 帧号 * 每帧时间</code>, 多次计算求平均值.</p></li></ol><p><strong>表现统一</strong></p><p>A输出, 做预表现后, 会导致A的表现时长比B多一段(RTT+帧时间), 预表现要考虑这段的平滑处理.</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ul><li>服务器只做转发, 客户端读取操作进行计算.<ul><li>网络卡顿, 容易出现不一致 ?</li><li>相信客户端输入, 导致容易出现作弊.</li></ul></li><li>服务器计算后将结果发送给客户端<ul><li>unity放到服务器</li><li>重新开发碰撞计算, 位置计算</li></ul></li></ul><p>服务器发送战斗开始, 开始计算服务器帧. 客户端收到开始后计算客户端帧. 客户端将输出和所属帧发送给服务器, 服务器判断是否是当前帧, 如果是则计算输入, 如果过期则丢弃.</p><ul><li>延时过大容易导致客户端的输入被大量丢弃</li></ul><p>服务器接收客户端输入, 收到输入后保存. 如果帧没有结束则继续等待, 结束后则运算此帧, 并将结果发送给客户端.</p><ul><li>服务器接收客户端输入, 将输入保存到队列A中, 服务器在帧中执行队列B结束后, 切换AB队列. 服务器没帧结束后, 将变更推送给客户端.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark插件开发</title>
      <link href="/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-Wireshark%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-Wireshark%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Wireshark可以显示客户端和服务器之间的数据包交互。对于游戏服务器来说，一般使用的都是自定义的协议，协议中包含protobuf格式的真实数据。这时想让Wireshark显示这些自定义协议就需要单独开发插件。</p><p>这里使用相对简单的lua插件的方式进行开发。开发完成后属于有用，但没那么有用，不过胜在开发成本低，还能学习到项目框架协议的编解码.</p><p>可以解决的问题</p><ol><li>客户端到底有没有收到数据包。虽然游戏中打印了日志，但消息一般会经过多个流程，最终客户端有没有收到确实有待检查。</li><li>后台想要得知前台使用了什么协议。比如登录会发送登陆包，如果能够通过Wireshark看到登陆包，就能直接得知本次发送的协议名称和协议内容，方便查看对应的代码。</li><li>客户端or服务器发送的数据包有没有问题，省去加日志的步骤。</li></ol><h1 id="Wireshark相关支持介绍"><a href="#Wireshark相关支持介绍" class="headerlink" title="Wireshark相关支持介绍"></a>Wireshark相关支持介绍</h1><ol><li>wireshark本身支持protobuf数据的解析，给定proto、message名称和message序列化后的数据就能以树状的形式展示在wireshark中。同时天然支持按字段进行索引。</li><li>wireshark的lua插件目前没有找到合适的解密库的使用方法，所以需要关闭客户端和服务器的加密后使用。</li><li>wireshark会以tcp包为单位提供数据包，所以只需要从数据包中编码后的自定义协议中拿到message的数据和message的名称就能完成解析</li></ol><h1 id="lua插件"><a href="#lua插件" class="headerlink" title="lua插件"></a>lua插件</h1><p>lua插件基本格式</p><pre><code class="lua">-- 自定义的协议名称local proto_name = &quot;tsf4g&quot;-- 服务器端口 wireshark通过端口选择协议来解析local server_ports = {10000}local proto = Proto(proto_name, proto_name)-- 源端口的获取方式-- 由于C-&gt;S和S-&gt;C之间的协议格式不一定是一致的 所以需要进行区分srcport = Field.new(&quot;tcp.srcport&quot;)-- 个性化字段定义 - 位的显示--   最后的0xf0代表取字节的高4位crypto_type_field_enum = {    [1] = &quot;unencrypted&quot;, -- 高4位是0001时 将会显示unencrypted    [2] = &quot;encrypted&quot; -- 高4位是0002时 将会显示encrypted}crypto_type_field = ProtoField.uint8(&quot;crypto_type&quot;, &quot;crypto_type&quot;, base.DEC, crypto_type_field_enum, 0xf0)-- 个性化字段定义 - 指定格式的显示--    这里是uint32格式和string两种格式flag_field = ProtoField.uint32(&quot;flag&quot;, &quot;flag&quot;, base.DEC, flag_field_enum)debug1 = ProtoField.string(&quot;debug1&quot;, &quot;debug1&quot;)-- 注册字段proto.fields = {    crypto_type_field,    flag_field,    debug1}-- 算是个工具函数 从数据中以protobuf序列化后的格式读取一个数字function read_number(tvb, begin_sub)    local sub = begin_sub    local number = 0    local bit_lshift = 0    repeat        local num = tvb(sub, 1):uint()        local t_num = bit32.band(num, 0x7f)        number = bit32.bor(bit32.lshift(t_num, bit_lshift), number)        bit_lshift = bit_lshift + 7        sub = sub + 1        if sub &gt;= tvb:len() then            break;        end    until (bit32.band(num, 0x80) == 0)    return numberend-- 这里的tvb可以理解为一个数组，tree则是wireshark左下角的树状展示所需要的数据function proto.dissector(tvb, pinfo, tree)    if tvb:len() &gt; max_pack_size then        return false    end    pinfo.cols.protocol = proto_name    -- 判断是客户端发送到服务器 还是 服务器发送到客户端    -- local srcport = srcport();    -- svr_to_client = false    -- for i, port in ipairs(server_ports) do    --     if tostring(srcport) == tostring(port) then    --         svr_to_client = true    --     end    -- end    local sub = 0    -- 从数据的开始位置读取4个字节，并作与运算 得到包长    local pkg_size = bit32.band(tvb(sub, 4):uint(), 0x00ffffff)    -- 在树中创建一个子树，这里的长度会影响选中后的高亮    local subtree = tree:add(proto, tvb(0, pkg_size), &quot;tsf4g&quot;)    -- 在子树中继续创建子树    local header = subtree:add(proto, tvb(), &quot;header&quot;)    -- 添加字段用于展示    -- 由于在定义crypto_type_field设置了0xf0，所以这里实际展示内容为 第一个字节的高4位    header:add(crypto_type_field, tvb(sub, 1))    -- 字段判断，这里判断的是有无开启加密    local crypto_type = bit32.rshift(bit32.band(tvb(sub, 4):uint(), 0xf0000000), 28)    sub = sub + 1    if not(crypto_type == 1) then        return true    end    -- 添加字段的同时 添加注释    local cmd = tvb(sub, 2):uint()    header:add(cmd_field, tvb(sub, 2)):append_text(&quot; [0 (Game Proto), other (tsf4g proto)]&quot;)    sub = sub + 2    -- 这里已经将头部数据解析完毕 sub开始到data_size就是protobuf数据了。    if msg_type == 2 then        -- 获取protobuf解释器        local protobuf_dissector = Dissector.get(&quot;protobuf&quot;)        -- 设置协议名称        pinfo.private[&quot;pb_msg_type&quot;] = &quot;message,main.CSMsg&quot;        -- 给定protobuf序列化后的数据 进行解析        pcall(Dissector.call, protobuf_dissector, tvb(sub, data_size), pinfo, tree)        Dissector.call(protobuf_dissector, tvb(sub, data_size):tvb(), pinfo, subtree)    end    -- 由于一个包中可能有多条message 这里嵌套进行解析    sub = sub + data_size    if sub &lt; tvb:len() then        proto.dissector(tvb(sub):tvb(), pinfo, tree)    endendlocal udp_port_table = DissectorTable.get(&quot;tcp.port&quot;)for i, port in ipairs(server_ports) do    udp_port_table:add(port,proto)end</code></pre><h1 id="wireshark安装插件和相关设置"><a href="#wireshark安装插件和相关设置" class="headerlink" title="wireshark安装插件和相关设置"></a>wireshark安装插件和相关设置</h1><p>Wireshark安装后的根目录中存在init.lua文件</p><pre><code class="lua">if not running_superuser or run_user_scripts_when_superuser then    dofile(DATA_DIR..&quot;console.lua&quot;)    -- 添加自定义的lua插件    dofile(&quot;D:\\tools\\wireshark1.0\\dict.lua&quot;)end</code></pre><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><ol><li>暂不清楚wireshark如何处理的书中经常提到的tcp数据流本身没有分界线的问题。编写插件时，wireshark提供的数据包似乎不用考虑截断的问题，最多考虑下很少出现的粘包情况。</li><li>没有找到合适的加解密库的使用方式，一般协议使用aes加密，即使知道加密流程也没有库来调用进行解密。</li><li>当一个序列化后的数据包超过1460后会导致分包，这时候上述的方式无法解析，这个由于基本遇不到也就没有处理。</li><li>看过其他的插件是用的是将数据放到buff中对buff进行解析，这是更为合适的方式，不过目前直接解析也够用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通识</title>
      <link href="/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E9%80%9A%E8%AF%86/"/>
      <url>/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E9%80%9A%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><p>已经有很长一段时间没有记录过本周和每天做过什么、遇到什么事情了，一个月过去如果不知道本月做了什么还是会感觉到虚度了。</p><h2 id="写好代码的捷径"><a href="#写好代码的捷径" class="headerlink" title="写好代码的捷径"></a>写好代码的捷径</h2><p>编程和写作还是十分相似，写作时如果能引用其他名作中的一句或者一段话，相对完全自己写来说文章的质量就会提升一大截。</p><p>编程入门初期，看了很多的书，目前来说我看的绝大部分书籍都是初学的时候看的。<strong>在这之后就还没有看过相关的书籍，也没有阅读过开源项目的代码了。</strong></p><p>没有输入只有输出，只能是消耗之前已有的知识，只能依靠试错来提高效率和质量。</p><p><strong>所以还是要坚持阅读相关书籍，就编程通用的来说，代码整洁之道、重构 代码大全 人月神话，没有一本我完整的看完过。所以这些内容还是要补上。</strong></p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>目前每天还是在学习日语，早睡早起也是为了这一点，早上7.30能够起床，收拾完之后7.40到8.20出门能背40分钟的单词，语言学习这点还是贵在坚持了。间歇性突击学习，并不适合语言学习这里，还容易把耐心耗光。</p><p>要制定每周的计划，每月的计划，乃至每年的计划。至于每天的计划就是上面计划的拆解了。不然每天想到那里就学哪里，只学每天习惯性学习的内容，其他方面几乎就停止增长了。</p><p>目前来说<strong>更早睡和更早起</strong>，更利于我目前的计划。早上的时间可以用来学习日语，至于晚上的时候，脑子已经迟钝，用来记忆还是很难的。</p><h2 id="记录工作中遇到的障碍"><a href="#记录工作中遇到的障碍" class="headerlink" title="记录工作中遇到的障碍"></a>记录工作中遇到的障碍</h2><p>为了做A事情，其中会用到其他的工具等，如果这些工具有问题如何去处理呢？感觉去处理处理能够学习到其他方面的知识，而不是不去处理。做一点分外的工作还是能加分的。<strong>以后可以把所有遇到的问题都记录下来</strong>。</p><h2 id="打造高效的试错环境"><a href="#打造高效的试错环境" class="headerlink" title="打造高效的试错环境"></a>打造高效的试错环境</h2><p>理想的编程环境就跟刷Leetcode一样，只用细细解读描述的非常清楚的需求，开发时只用关注这一个功能，功能阶段性开发完之后能够立刻进行自动化测试。</p><ol><li><p>目前遇到的情况中，将一个函数的几部分可以好好考虑考虑是不是要拆开，这几天做了一个将A结构体转换为B结构体的工作，其中某些字段需要做映射，如果把这些映射全部写到一个转换函数中，后续想到单独处理一个字段的映射还要拆出来。</p></li><li><p>协议的制定还是要考虑好，最好不要有临时协议这个概念，协议message中可以将部分相同含义的内容（如账号信息）放到一个单独的message中。后续进行协议改动还是挺麻烦的。</p></li><li><p>单元测试在Tsssvr中进行了第一次应用，效果还是非常不错的，能够加快问题的暴露。</p></li><li><p>最好能够摆脱客户端进行测试，最理想的情况就是只用处理收发协议。</p></li><li><p><strong>即使项目很复杂，也应该积极采取操作去改善自己的开发环境。</strong></p></li><li><p>模块化设计或者微服务架构 降低模块之间的影响</p></li><li><p>自动化测试</p></li><li><p>尽量缩短从改完代码到获得反馈的等待时间</p></li></ol><h2 id="关注学习性价比"><a href="#关注学习性价比" class="headerlink" title="关注学习性价比"></a>关注学习性价比</h2><p>学习初期，投入100份精力能够获得1000份结果。学习后期，投入100份可能只能获得10份结果。</p><p>学习新事物的时候，要想好自己要学到什么程度，知识要学的非常多。既要能做到有自己专精的部分，也要有略懂一二的部分，这样才能面对的海量的学习不完的知识。自己认为不该学习过深的就不要学习过深，腾出时间来学习其他内容，做到准确的分配自己有限的精力。</p><p>学习的时候也要选择合适的学习资料，优秀的资料不一定适合自己，浅显易懂的资料没准才是合适的，尤其是跨行学习的时候。</p><h2 id="避开完美注意陷阱"><a href="#避开完美注意陷阱" class="headerlink" title="避开完美注意陷阱"></a>避开完美注意陷阱</h2><p>性能够用，避免过度设计，避免过早优化，</p><p>代码质量上精益求精时好事，不过并没有完美的代码，能够满足当前的需求，为未来预留一些扩展空间就够了。</p><h2 id="有目标感-amp-刷新简历"><a href="#有目标感-amp-刷新简历" class="headerlink" title="有目标感&amp;刷新简历"></a>有目标感&amp;刷新简历</h2><p>如果你的目标就是学本事，那最应该考虑的是半年、一年、两年、三年或者离开这家公司的时候我能带走什么。</p><p>刷新简历不一定是为了跳槽，能写到简历上的才是真正敢拿出来的，可以通过内部的活水或者外部的面试的反馈来检验自己。</p><p>现在没有课程表，所以就要学到没有课程表的情况下怎么办，没有课程表的话就需要自己指定，不用每天N次课这种 也没有时间，每周每月每季度每年等。</p><h2 id="横向比较"><a href="#横向比较" class="headerlink" title="横向比较"></a>横向比较</h2><p>与前辈比较起来还是很难的，毕竟时间花费就不一样。但是可以和同等级（如年龄）的人比较，看看自己到了哪个阶段，能不能到同等级的前列。</p><p>到不了的话就要找找原因了，不排除有先天性的优点或者缺点，但不至于你前面的人都是这些有先天性优点的人。</p><h2 id="靠谱-独立-为自己的行为和决定负责"><a href="#靠谱-独立-为自己的行为和决定负责" class="headerlink" title="靠谱 独立 为自己的行为和决定负责"></a>靠谱 独立 为自己的行为和决定负责</h2><p>靠谱 这个比较笼统，总的来说就是让别人放心的把需求给你做，从小到大。简单的问题不靠谱经常搞出问题，又何谈复杂的问题呢</p><p>独立 刚入职的时候一般都会有人带，此时导师能够或多或少的帮你挡下一部分问题，这些问题你不用考虑都可以很好的完成需求。等后续这些问题终究还是要自己考虑。当然也不是所有问题都要自己解决，解决不了的要及时询问，不要想着独立不懂装懂，出了问题会影响你的<strong>靠谱</strong></p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>五大态</title>
      <link href="/2023/03/%E6%97%A5%E8%AF%AD-%E4%BA%94%E5%A4%A7%E6%80%81/"/>
      <url>/2023/03/%E6%97%A5%E8%AF%AD-%E4%BA%94%E5%A4%A7%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>日语动词 可能态，被动态，使役态，被役态</p><h1 id="表示可能的方法及可能态"><a href="#表示可能的方法及可能态" class="headerlink" title="表示可能的方法及可能态"></a>表示可能的方法及可能态</h1><p>日语在表示主语有某种能力，有条件进行某种行为时，有以下几种方式： </p><p>1，直接用「できる」。 </p><p>「私は日本语ができます。」“我会日语。”<br>「李さんは料理ができます。」“小李会做菜。”<br>这里主语用「は」表示，会的内容用「が」表示。 </p><p>2，用「ことができる」。 </p><p>「私は日本语を话すことができます。」<br>「李さんは料理を作ることができます。」<br>这里「日本语を话す」和「料理を作る」是能做的具体内容，用简体，是「こと」的定语，「话す」和「作る」是连体形。与上面不同的是具体内容的宾语用「を」，而不用「が」。<br>用这个方式可以把事情说得更具体一些，如：<br>「日本语を话すことができます。」“能讲日语。”<br>「日本语を书くことができません。」“不能写日语”<br>把这两句合在一起，用对比的形式表示，则为：<br>「日本语は话すことはできますが、书くことはできません。」<br>“日语能说但不能写。”<br>这里因为采用了对比方式，所以「日本语」作为主题提出，以「は」表示；「こと」后面的「が」以「は」表示。</p><p>3，可能态 </p><p>形式为: 五段动词未然形+れる  其他动词未然形+られる </p><p>句型为：—-は—-が可能态动词。<br>「私は刺し身が食べられます。」“我能吃生鱼片。”<br>「明日は8时に来られます。」 “明天8点钟能来。” </p><p>五段动词的情况下,动词发生音变：<br>1.「読む」的未然形「よま」＋「れる」变成「読まれる」。<br>2. 其中「ま」和「れ」约音变成「め」。<br>3. 于是「読まれる」变成「読める」<br>4. 因此，在五段动词中动词变成可能态，不必要通过复杂的变化，可以直接把词尾的う段假名变成该行的え段假名，再加「る」就可以了。</p><p>如：<br>「书く」的可能动词是「书ける」；<br>「游ぶ」的可能动词是「游べる」；<br>「走る」的可能动词是「走れる」等等。<br>「私は日本语の新闻が読めます。」“我能读日语报纸。”<br>「日曜日は休みだから、町へ行けます。」“星期日休息，所以能上街。” </p><p>这里说明一下什么是约音：用第一个假名的辅音和第二个假名的元音结合成新的假名。如：「ま」的发音是“ma”，其辅音是“m”，「れ」的发音是“re”，其元音是“e”，把“m”和“e”结合在一起，就成为“me”即「め」。关于约音的概念，不只限于可能动词，其他内容上提到的约音，都可以用此办法处理。 </p><p>サ变动词的可能态本来应该是「する」的未然形「し」加「られる」而构成。这时「し」和「ら」约音变成「さ」。因此，サ变动词的可能态应该是词干加「される」。但实际上基本不用这个形式，而用词干加「できる」的形式。</p><p>如：「勉强できる」、「说明できる」等。<br>「図书馆は静かだから良く勉强できます。」<br>“图书馆很安静，能好好学习。”<br>「私はまだ日本语で论文が発表できません。」<br>“我还不能用日语发表论文。” </p><h1 id="被动态"><a href="#被动态" class="headerlink" title="被动态"></a>被动态</h1><p>当一个主体受到另外一个事物的动作时，就要用被动态。 </p><p>形式为: 五段动词未然形+れる<br>其他动词未然形+られる<br>这个形式和可能态的基本形式相同，但五段动词没有约音变化。<br>サ变动词的被动态是「する」的未然形「し」加「られる」而构成。这时「し」和「ら」约音变成「さ」。因此，サ变动词的被动态是词干加「される」。<br>一段动词和カ变动词的形式，和可能态完全一样，因此必须从句子结构进行区别。 </p><p>被动态有4种类型： </p><p>1，在主动句中宾语是人或动物时： </p><p>主动句: 「先生が学生を褒めた。」“老师表扬了学生。”<br>被动句：「学生は先生に褒められた。」“学生被老师表扬了。”<br>在这一类被动句中，主动句的主语变成了补语，用「に」表示；主动句的宾语变成了主语，用「は」表示；动词变成了被动式（＝未然形＋られる）。<br>又如：主动句: 「猫が鱼を食べてしまった。」“猫把鱼吃掉了。”<br>被动句：「鱼は猫に食べられてしまった。」“鱼被猫吃掉了。” </p><p>2，在主动句中的宾语是带有以人做定语的事物时： </p><p>主动句: 「弟が私の时计を壊した。」“弟弟弄坏了我的表。”<br>被动句：「私は弟に时计を壊された。」“我被弟弟弄坏了表。”<br>在这一类被动句中，主动句的主语变成了补语，用「に」表示；主动句宾语的定语部分变成了主语，用「は」表示；宾语保留；动词变成了被动式（＝未然形＋れる）。<br>又如：主动句: 「バスの中で、隣の人が私の足を踏んだ。」<br>“在公共汽车里，旁边的人踩了我的脚。”<br>被动句：「バスの中で、私は隣の人に足を踏まれた。」<br>“在公共汽车里，我被旁边的人踩了脚。” </p><p>3，主动句的主语可以忽略，宾语是非人物时（多用于活动）： </p><p>主动句：「学校は8时から会议を开きました。」<br>“学校从8时起开会。”<br>被动句：「会议は8时から（学校によって）开かれました。」<br>“会议（由学校主持）从8时开始。”<br>在这一类被动句中，主动句的主语一般消失，如果一定需要，可用「によって」表示；主动句的宾语变成了主语，用「は」表示；动词变成了被动式（＝未然形＋れる）。<br>又如：主动句: 「いつ、何処で、谁が谚を作ったか、分かりません。」<br>“弄不清楚，在何时何地，谁创造了谚语。”<br>被动句：「谚は、いつ、何処で、谁によって作られたか、分かりません。」<br>“弄不清楚谚语是在何时何地，被谁创造的。” </p><p>4，自动词的被动式： </p><p>有部分自动词，可以用被动式表示，这种情况只用在主语受到损失的情况下，多用来说明后面动作或状态的原因。<br>主动句：「雨が降って、风邪を引いた。」“因为下雨了，所以感冒了。”<br>被动句：「雨に降られて、风邪を引いた。」“因为被雨淋了，所以感冒了。” </p><p>如果主语没有受到损失，就不能用自动词的被动式。如：<br>主动句：「雨が降って、木が青くなった。」“下雨了，树变绿了。” </p><p>又如：主动句：「友达が来て、楽しく游んだ。」<br>“朋友来了，我们玩得很开心。”<br>被动句：「友达に来られて、宿题ができなかった。」<br>“朋友来了，害得我没有完成作业。” </p><p>自动词的被动式的使用范围很受局限，不是任何自动词都可以变成被动式的。下面再举几个例子：<br>「父に死なれて、进学をあきらめ、就职した。」<br>“父亲去世了，我只好放弃升学，而参加工作。”<br>「子供に泣かれて一晩中良く眠れなかった。」<br>“孩子哭了一晚上，害得我没有睡好觉。”<br>日语中较多地使用被动式，但在中文中则多主动形式，所以在翻译中不一定全译成被动句，可以根据情况译成主动句。但是特别要注意被动和主动的关系，千万不要译错了 </p><h1 id="使役态"><a href="#使役态" class="headerlink" title="使役态"></a>使役态</h1><p>当一个人受到另外一个人的命令或使役时，动作就要变成使役态。<br>日语的使役态形式为：<br>五段动词未然形＋せる<br>其他动词未然形＋させる<br>其中，サ变动词的未然形是「し」，＋させる变成「しさせる」，在这里「し」和「さ」发生音变成为「さ」。所以サ变动词的使役态是：「词干＋させる」。 </p><p>动词的使役态有2种： </p><p>1，当主动句的动词是自动词时。<br>主动句：「妹は买い物に行った。」“妹妹去买东西。”<br>使役句：「母は妹を买い物に行かせた。」“母亲让妹妹去买东西。”<br>在这里，首先动词「行く」是自动词，其使役态是「行かせる」。在使役句中，动作的执行者“妹妹”由原来的主语变成了宾语；主语是下命令的人，因此，在使役句中主语不是动作的执行者。再则，原来为自动词的句子变成了带宾语的他动词句子。因此，如果当一个自动词根本没有对应的他动词而又需要他动词时，用其使役态是个办法。<br>又如：「学生が病気になったので、先生は彼を帰らせた。」<br>“学生生了病，所以老师让他回去了。”<br>「急な仕事なので、会社は山田さんを出张先に飞ばせた。」<br>“因为是突然的工作，所以公司让山田先生飞到出差的地方。”<br>在这里还应该注意的是：有些自动词已经有对应的他动词，这样时就不用使役态而用对应的他动词。如：“母亲让孩子起床。”这时一般想到用使役态，有可能译成：「母亲は子供を起きさせる。」但是实际上要译成：「母亲は子供を起こす。」因为「起きる」的对应他动词是「起こす」。 </p><p>2，当主动句的动词是他动词时。<br>主动句：「学生は本を読みます。」“学生读书。”<br>使役句：「先生は学生に本を読ませます。」“老师让学生读书。”<br>在这里，主动句的动词是他动词，原来句子中就有宾语。在这种情况下变成使役句时，下命令的「先生」作主语，「学生」变成补语，用「に」表示，动词「読む」变成使役态「読ませる」，宾语保留。在他动词的使役句中，主语仍然不是动作的执行者。<br>又如：「母亲は子供に薬を饮ませた。」<br>“母亲给孩子吃了药。”<br>「あの会社は社员に一日10时间も働かせる。」<br>“那个公司让员工一天工作10个小时。”<br>「この学校は休みの日にも学生に外出させない。」<br>“这个学校连假日都不让学生外出。”<br>由于使役句带有强迫和命令的口气，所以除了「亲に心配させる」等少数句子以外，一般不用于长辈作补语的句子。如果必须让长辈作某件事情，则要用补助动词「てもらう」或者「ていただく」。如：“让老师再讲解一次。”一般不译成：「先生にもう一度说明させる。」而译成：「先生にもう一度说明していただく（てもらう）。」关于这一点，不论是自动词的句子还是他动词的句子都是一样的。 </p><h1 id="被役态"><a href="#被役态" class="headerlink" title="被役态"></a>被役态</h1><p>当一个人被迫或不由自主地做某件事情时使用被役态。被役态是一个动词先变成使役态后再变成被动态。 </p><p>日语的被役态的形式为：<br>（五段动词未然形＋ せる）＋られる<br>（其他动词未然形＋させる）＋られる<br>由于变成使役态后动词已经成为下一段动词，所以后面的被动态只用られる。<br>（五段动词未然形＋せる）＋られる在实际操作时，先变成：<br>五段动词未然形＋せられる；<br>然后せら两个假名发生音变，变成さ，因此整个动词变成：<br>五段动词未然形＋される。<br>但是，五段动词的さ行词尾「す」是特殊的：由于「す」的未然形是「さ」，与「される」的首字さ重复，所以只有以为「す」词尾的五段动词不约音。如：「话す（はなす）」的被役态是「话させられる」，而不是「话さされる」。 </p><p>主动句：「仆は买い物に行きます。」“我去买东西。”<br>被役句：「仆は姉に买い物に行かされます。」“我被姐姐逼着去买东西。”<br>可以看出：被役句的主语是动作的执行者，所以和主动句的结构基本一致，多一个强迫的来源，用「に」表示。<br>又如：「彼の言ったことについては本当に考えさせられる。」<br>关于他说的事情，不得不使我认真思考一下。<br>「私は饮みたくないです、でも饮まされたのです。」<br>“不是我愿意喝（酒），而是被别人灌的。”<br>与前一讲被动态里讲到的内容联系起来看，在这里值得注意的是：当动词后面出现「される」时一定要看前面的动词，前面的动词是五段动词时就是被役态，译成“被迫”；当前面的动词是サ变动词时就是被动态，译成“被……”。如：<br>「私は母に病院へ行かされた。」<br>「病院で私は医者に検査された。」<br>这2句话里都有「された」，是「される」的过去时。上面一句中「される」的前面是五段动词的未然形，所以是被役态，整个句子译成：“我被母亲逼着去了医院。”而下面一句的「される」前面是サ变动词的词干，所以是被动态，整个句子译成：“在医院里，我被医生作了检查。” </p><h1 id="自发态"><a href="#自发态" class="headerlink" title="自发态"></a>自发态</h1><p>五段动词： 把词尾「う」段上的假名变成其所在行「あ」段上的假名加「れる」。（这个形式和被动态的基本形式相同，没有“约音便”。）如：<br>思う→思われる 偲ぶ→偲ばれる（しのばれる）<br>待つ→待たれる 思い出す→思い出される</p><p>一段动词：去掉词尾「る」加「られる」。如：<br>感じる→感じられる 案じる→案じられる</p><p>サ变动词：「する」的未然形「さ」加「れる」。如：<br>勉强する→勉强される 邪魔する→邪魔される</p><p>カ变动词：只有一个词。如：来る→来られる<br>用法：动词前面的「を」，变成自发动词以后要变成「が」。<br>例：◇この写真を见ると、学生时代のことが思い出される。<br>◇昨日の失败が悔やまれてならない。<br>◇なんだか変だと思われる。<br>◇外国の息子のことが案じられる。<br>◇それを见ると、故郷が偲ばれる。</p>]]></content>
      
      
      <categories>
          
          <category> 日语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GPT答疑记录</title>
      <link href="/2023/03/%E6%97%A5%E8%AF%AD-GPT%E7%AD%94%E7%96%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/03/%E6%97%A5%E8%AF%AD-GPT%E7%AD%94%E7%96%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>N4か</p><h2 id="その時は証明なんてどうとでもするから"><a href="#その時は証明なんてどうとでもするから" class="headerlink" title="その時は証明なんてどうとでもするから"></a>その時は証明なんてどうとでもするから</h2><ol><li>その時：指“那个时候”或“那时”。</li><li>は：是一个主题助词，表示“关于……，至于……”等。</li><li>証明：指“证明”。</li><li>なんて：是一个类似于“什么……”的片语，常用于强调、贬低或表示不在意的语气。</li><li>どうとでもする：是一个动词短语，意思是“不择手段地做、为所欲为”。</li><li>から：是一个表示“因为、由于”等的连词。</li></ol><p>因此，“その時は証明なんてどうとでもするから”的意思是“那时候为了证明什么东西可以不择手段地去做”。</p><h2 id="だって君そうしないと一日中引きこもってそうだし"><a href="#だって君そうしないと一日中引きこもってそうだし" class="headerlink" title="だって君そうしないと一日中引きこもってそうだし"></a>だって君そうしないと一日中引きこもってそうだし</h2><ol><li>だって：是一个类似于“可是”、“因为”、“但是”等的连词，在这里的意思大致为“因为”、“由于”。</li><li>君：指“你”。</li><li>そうしないと：是一个类似于“要不然”、“否则”的连词，在这里意思为“如果不这样做的话”。</li><li>一日中：指“整天”、“一整天”。</li><li>引きこもって：是一个动词短语，意思是“宅着”、“呆在家里不去外面”。</li><li>そうだし：是一个类似于“而且”、“此外”的连词，在这里的意思为“而且”、“此外”。</li></ol><p>综上所述，“だって君そうしないと一日中引きこもってそうだし”的意思为“因为如果不这样做的话，你很可能会整天呆在家里不去外面，而且还有这种可能性”。</p><h2 id="ごめんで済んだら警察いらないよね"><a href="#ごめんで済んだら警察いらないよね" class="headerlink" title="ごめんで済んだら警察いらないよね"></a>ごめんで済んだら警察いらないよね</h2><ol><li>ごめんで済んだら：由「ごめんで済む」和「たら」两个部分组成。其中「ごめんで済む」是一个日语常用表达，意思是“得到道歉就算了（原谅了）”。而「たら」则表示假设或条件，“如果…的话”。因此这个部分的意思是 “如果得到道歉就当做了”。</li><li>警察：表示“警察”。</li><li>いらない：是动词「いらっしゃる（いらっしゃいます）」的否定形式，意思是“不需要，不用”。</li><li>よね：是一个末尾词语，用来表明说话人的语气或意愿，通常被翻译为“是吧”、“好吧”或者“并不是吗”。</li></ol><p>综上所述，整个句子的意思大概是“如果得到道歉就当做了，那么就不需要警察了吧”</p><h2 id="ごめんつってんだろ"><a href="#ごめんつってんだろ" class="headerlink" title="ごめんつってんだろ"></a>ごめんつってんだろ</h2><ol><li>ごめん：是「ごめんなさい」的缩略形式，是日语中“对不起”的常用表达。可以用来表示自己的道歉或者让对方停止某一行为。</li><li>つってんだろ：以前にも同じことを言ったのに、なぜわからないのだ？</li></ol><p>综上所述，整个句子的意思是“我说了对不起吧”</p><h2 id="こんな女の子によってたかってひょっとしてロリコンか？"><a href="#こんな女の子によってたかってひょっとしてロリコンか？" class="headerlink" title="こんな女の子によってたかってひょっとしてロリコンか？"></a>こんな女の子によってたかってひょっとしてロリコンか？</h2><ol><li>こんな女の子に：「こんな」表示这样的、这种的，而「女の子」则是女孩子的意思，两个合起来就是“这样的女孩子”的意思。</li><li>よってたかって：寄る　よる　靠近　集る たかる 围着</li><li>ひょっとして：是一个用来表示推测或者猜测的表达，通常被翻译成“难道是”、“莫非是”等。</li><li>ロリコン：是“Lolicon”的罗马字，原指对幼女（Lolita）的痴迷等不正常者。在日语中成为了代表这种心理或者行为倾向的词汇。</li></ol><p>综上所述，整个句子的意思是“因为欺负了这样的女孩子，莫非你是Lolicon吗？”</p><h2 id="大人として君たち子供には分別というのを知ってもらいたかっただけさ"><a href="#大人として君たち子供には分別というのを知ってもらいたかっただけさ" class="headerlink" title="大人として君たち子供には分別というのを知ってもらいたかっただけさ"></a>大人として君たち子供には分別というのを知ってもらいたかっただけさ</h2><ol><li>大人として：「大人として」中的「大人」就是成年人的意思。在这里「大人として」表示以成年人的身份或者说是观点，以成年人的标准来衡量行为。</li><li>君たち子供に：「君たち子供に」翻译为“你们孩子”或者“你们小孩”，“君たち”表示复数的“你们”，是对一群人的称呼。 “子供”就是“孩子”的意思，用来指代还没有成年或还在成长阶段的儿童。</li><li>分別：「分別」是“辨别是非的能力”，也可以理解为“判断力”，或者“明辨是非的能力”。</li><li>というのを：「というのを」是连接用语。其中「という」表示“是……”，「のを」表示“……的事物”。所以「というのを」放在一起理解就可以等同于“是……的事物”。</li><li>知ってもらいたかっただけ：「知ってもらいたかっただけ」的意思是“只是想让你们知道”。其中「知ってもらいたかった」是“想要让对方知道”的意思。在这里说话者用了「だけ」表示“(只)仅仅是……”。</li></ol><p>综上所述，这句话的意思是“我只是想让你们作为成年人的孩子们知道分辨是非的能力”。<br>たかっただけ　たい　＋　だけ</p><h2 id="膀胱がご当地キャラ並みに緩くなったこととか"><a href="#膀胱がご当地キャラ並みに緩くなったこととか" class="headerlink" title="膀胱がご当地キャラ並みに緩くなったこととか"></a>膀胱がご当地キャラ並みに緩くなったこととか</h2><p>其中，“膀胱”指的是人体内排尿的器官，而“ご当地キャラ”则是日本各地特色的地方形象吉祥物。<br>在这句话中，“膀胱がご当地キャラ並みに緩くなったこととか”暗示了一个人因为某个原因而无法控制便意或者从容地完成排泄的情况，类似于膀胱宽度变得像是各个地方的吉祥物那样宽松。</p><h2 id="きつすぎず"><a href="#きつすぎず" class="headerlink" title="きつすぎず"></a>きつすぎず</h2><p>きつ（きつい去い）＋　過ぎない（すぎず）</p><p>「過ぎる」本身表示“超过、过量、过于”，当作为后缀时，其定义仍是“～过量，过于～”<br>1.动词ます连用＋すぎる<br>2.一类形容词（い形容词）去掉「い」＋すぎる<br>3.二类形容词去掉词尾「だ」（な形容词、形容动词）＋すぎる</p><h2 id="対立ずにいれば"><a href="#対立ずにいれば" class="headerlink" title="対立ずにいれば"></a>対立ずにいれば</h2><p>文言说法，相当于ないで，表示同一主体行为的伴随状态<br>和する连接时变成せずに相当于しないで<br>いれば 如果存在 如果是这样 いる的假定性</p><h2 id="まだ"><a href="#まだ" class="headerlink" title="まだ"></a>まだ</h2><p>「まだ」在日语中是一个非常常用的副词，主要有以下几种用法：</p><ol><li>表示某个动作或<strong>状态</strong>仍在<strong>进行中</strong>，相当于中文的”还”。例如：”まだ食べていますか？”（你还在吃吗？）</li><li>与<strong>否定词</strong>一起使用，表示某个动作或状态<strong>尚未开始或完成</strong>，相当于中文的”还没”。例如：”まだ来ていません”（他还没来）。</li><li>表示对未来的期待或可能性，相当于中文的”还会”。例如：”まだ会更好”（还会更好）。</li><li>用在比较级前，表示”更加”的意思。例如：”まだ早い”（更早）。</li></ol><p>注意，「まだ」的使用通常需要根据上下文和语境来判断.</p><h2 id="若者には同世代の若者がよく目についたのは、自分の経験からもまかります"><a href="#若者には同世代の若者がよく目についたのは、自分の経験からもまかります" class="headerlink" title="若者には同世代の若者がよく目についたのは、自分の経験からもまかります"></a>若者には同世代の若者がよく目についたのは、自分の経験からもまかります</h2><p>对于年轻人来说，经常注意到的是同龄的年轻人，这也是从我自己的经验中得出的结论。</p><p>“若者には同世代の若者がよく目についた”：这是一个句子，”若者”是”年轻人”的意思，”同世代”是”同龄”的意思，”目につく”是”引人注意”的意思，整个句子的意思是”对于年轻人来说，经常注意到的是同龄的年轻人”。<br>“自分の経験からもまかります”：这也是一个句子，”自分の経験から”是”从我自己的经验中”的意思，”まかります”是”得出结论”的意思，整个句子的意思是”这也是从我自己的经验中得出的结论”。</p><h2 id="責任をもって活動できるなら、きっかけは何でもいいのです（感觉还是不太准确？）"><a href="#責任をもって活動できるなら、きっかけは何でもいいのです（感觉还是不太准确？）" class="headerlink" title="責任をもって活動できるなら、きっかけは何でもいいのです（感觉还是不太准确？）"></a>責任をもって活動できるなら、きっかけは何でもいいのです（感觉还是不太准确？）</h2><p>这句日语的意思是”如果能够负责任地行动，那么任何事情都可以成为契机</p><p>“責任をもって活動できるなら”：这是一个条件短语，”責任をもつ”是”负责任”的意思，”活動できる”是”能够行动”的意思，”なら”是条件助词，整个短语的意思是”如果能够负责任地行动”。<br>“きっかけは何でもいいのです”：这是一个句子，”きっかけ”是”契机”的意思，<strong>“何でもいい”是”任何事情都可以”的意思</strong>，”のです”是强调句尾的语气词，整个句子的意思是”那么任何事情都可以成为契机”</p><p>机会，何でもいい 什么都行。机会这东西什么都行？</p><h2 id="ようと思う-ようとする"><a href="#ようと思う-ようとする" class="headerlink" title="ようと思う　ようとする"></a>ようと思う　ようとする</h2><p>ようと思う　描述<strong>自己</strong>当前的瞬间想法, 打算做什么动作.</p><p>と思っている　<strong>任意人</strong>强烈的主张或长期留存的想法</p><p>ようとする 正要做, 动作正要发生之前的状态</p>]]></content>
      
      
      <categories>
          
          <category> 日语 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>性能之巅</title>
      <link href="/2023/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95180-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85/"/>
      <url>/2023/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95180-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>现代C++教程</title>
      <link href="/2022/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95161-%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/"/>
      <url>/2022/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95161-%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="函数后置返回"><a href="#函数后置返回" class="headerlink" title="函数后置返回"></a>函数后置返回</h4><pre><code class="c++">// C++11template&lt;class T1, class T2&gt;auto Add11(T1 t1, T2 t2) -&gt; decltype(t1 + t2){    return t1 + t2;}// C++14template&lt;class T1, class T2&gt;auto Add14(T1 t1, T2 t2){    return t1 + t2;}</code></pre><h4 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h4><pre><code class="c++">template &lt;class F, class ...Args&gt;auto string_format(F f, Args ...args){    auto size =            std::vsnprintf(nullptr, 0, f,                    std::forward(args)...) + 1;    std::string rst;    rst.resize(size);    std::vsnprintf(&amp;rst[0], size, f, std::forward(args)...);    return rst;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我是一只IT小小鸟</title>
      <link href="/2022/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95170-%E6%88%91%E6%98%AF%E4%B8%80%E5%8F%AAIT%E5%B0%8F%E5%B0%8F%E9%B8%9F/"/>
      <url>/2022/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95170-%E6%88%91%E6%98%AF%E4%B8%80%E5%8F%AAIT%E5%B0%8F%E5%B0%8F%E9%B8%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是基础扎实"><a href="#什么是基础扎实" class="headerlink" title="什么是基础扎实"></a>什么是基础扎实</h2><p>用我LinuxC++方向举例吧，同时会附上基础的作用。</p><p><strong>计算机网络–什么是TCP，什么是UDP。</strong></p><p>教科书上会这样写“TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议”“UDP是无连接、不可靠的、基于数据报的传输层通信协议”。</p><p>TCP还会介绍下超时重传、拥塞避免、流量控制这三个保证可靠的相关机制。再者还有一个滑动窗口。</p><p>上面的这些内容你大可以在教科书和几乎任何一篇八股文中找到，并将其背诵，然后去参加面试。这基本算是及格线了，如果你连这些内容都不知道，面试官的印象分就会打折扣。</p><p>如何落地呢？就拿王者这种moba游戏举例吧。</p><p>TCP通过上述机制保证了传输可靠。但是，古尔丹，代价是什么呢？客户端向服务器发送了向上移动、向下移动、发送集合信号、使用了技能、给队友点了赞和给队友发了条消息以示问候等等，这些可以看成一个个独立的消息。</p><p>你按以上顺序将这些消息通过TCP发送到服务器端，有序的机制会保证这些内容按顺序交付上层，如果其中某些字节丢失了，TCP会帮你重发这些字节。假设恰巧向下移动这个消息的相关字节丢失了，但给队友点赞这个消息的相关字节服务器已经收到了，然而由于前面的相关字节存在丢失，点赞这个消息的相关字节即使服务器已经收到了，服务器也没法拿到其相关数据，必须等到丢失的字节重传完成，才会交付上层。TCP重传向下移动这个消息丢失的字节，会导致后续所有消息都被延迟交付给服务器上层。导致延迟的出现。</p><p>即使重传一个字节，在30ms的延迟下，至少需要35ms左右的时间，甚至是100ms的更长的时间。相当于你比对面多了35ms到100ms的瞬间延迟。如果重传的这个字节又丢失了，时间将会翻倍。谁也不想在你越塔强杀对面的时候出现卡顿吧。</p><p>如何解决上面的问题？</p><p>使用UDP替换TCP，额外通过一部分代码来使得UDP的可靠性达到项目的要求。UDP是基于数据报的协议，意味着每次发送消息，服务器都可以独立的收到，不受在其之前发送内容的影响。试想下如果你将向下移动这个消息发送了两次，只有一次丢失了，另一次到达了，刚才提到的额外延迟就消失了。在moba游戏中延迟比流量消耗更加重要。当然实际可能要更加复杂。</p><p>从问题的提出到问题的解决，需要对TCP和UDP的相关机制有足够的的了解。如果你能够实现一个可靠的UDP协议，不敢说会超越多少人，至少能秒杀只背诵八股文的人，你的排名就会上升。</p><h2 id="什么是一个项目？"><a href="#什么是一个项目？" class="headerlink" title="什么是一个项目？"></a>什么是一个项目？</h2><p>考虑到学C++的人要少一些，这里就用Java举例。Java最常见的项目是xx后台管理项目，一般会使用Springboot框架进行开发。数据库管理可以使用Mybatis或者SpringJpa。然后在其上堆砌业务代码就能实现一个基础的后台管理项目。这属于入门水平。</p><p>之后你可以通过引入更多的组件来让你的项目更加完善，使用redis、RabbitMq等等。最终你的项目集成了四五个组件，功能上来看是一个完善的后台管理项目，这属于及格水平。</p><p>那么差距在哪里？如果仅仅是能跑，大家都可以跑起来。当出现问题的时候，你能不能快速又准确的定位到问题在哪里，知道如何进行修复？项目性能瓶颈后，如何通过优化这些组件或替换组件，来使得项目的性能更上一层？换言之我感觉差距是在对这些框架和组件的熟悉程度上，你对其越熟悉，出现问题的时候解决就更快。体现在面试中就是你为何以及如何使用这些组件，有没有遇到什么问题，怎么解决的。</p><p>最后复述一下我是一只IT小小鸟中的一段话。倘若没有这些基础，仅仅会用这个工具、那个框架，充其量也不过是个IT民工，今后的发展必定受到制约，选择只有三条：a.做一辈子IT民工；b.将大学欠下来的债补上；C.改行。</p><p>这些基础在本文指的就是计网知识和对组件的熟悉程度。如果你不了解这些而是仅仅会用，那么你将来在解决问题的时候，欠下的熟悉程度终究是要补回来的。如果不去解决，那就是把晋升机会给了同事，把毕业机会给了自己。</p><p>遇到一个问题，询问其他人解决，属于入门水平。</p><p>遇到一个问题，自己搜寻资料解决，属于及格水平。</p><p>遇到一个问题，知晓其发生的原因并做记录，二次发生后解决更加快速，属于优秀水平。</p><p>遇到一个问题，知晓其背后发生的根本原因，从源头解决，自然是更加优秀。</p><h2 id="卷王？学校不教？"><a href="#卷王？学校不教？" class="headerlink" title="卷王？学校不教？"></a>卷王？学校不教？</h2><p>感觉大家看完上述描述，可能会感觉了解上面的人是个卷王吧。是他们让面试的难度越来越高。如果你有这样的感觉，会怎么做呢？两手一摆，太卷了，你们卷吧，我打游戏去了？学校不教这些，所以我不了解这些，然后面试被这些卷王卷没了？</p><p>这里我再说一下高效能人士的七个习惯中的一段话。我们面对的问题可以分为三类：可直接控制的、可间接控制的和无法控制的。就面试要不要卷这个问题上。如果你是某公司的老板，大可以直接给自己发一个offer。或是你认识一些人，这些人可以让你避开卷就能拿到offer。如果这两个都没有，那就属于无法解决的问题，也就是说卷是必须的。对于无法解决的问题最好是坦然接受，抱怨和逃避是没有办法解决的，反而会让你的心态变差，最后拿到与不卷相对应的结果。</p><p><a href="http://foryoung365.github.io/development/2016/09/08/tcpvsudp" target="_blank" rel="noopener">http://foryoung365.github.io/development/2016/09/08/tcpvsudp</a></p><h2 id="自学"><a href="#自学" class="headerlink" title="自学"></a>自学</h2><p>身边了解到的人全部（样本不多，所以敢说全部）都是通过自学拿到offer的，暂且还没发现只上学校课程就能拿到的。就我自己理解来说，自学是在课余时间有目的自主学习某些内容。<br>不过这里首先不给出自己总结的一些自学方法，而是先说一下可能出现的问题，同样以我来举例。</p><p>既然是自学，总归会从某些地方获取到一些学习路线，然后准备按照这个路线走下去。就我来说，开始找的学习路线都是最贴近我当时水平的，而不是那种从小白到最强王者的学习路线。一是后者的路线给的点太多了，根本不知道从哪里入手，要不直接劝退，要不这里学学、那里学学，都没学透。二是想着从简单的入手，一步一步的来，先学着，也就没过于追求后者。这样每次得到的路线都相对平缓，由于相对平缓基本能自己摸索出一些问题的答案，不会遇到很多天大的障碍。等到了本段路线的后期，就有了我行了的感觉，满足于当前所学，再之后就不知道继续学习什么。我能做的事局限在了我的眼界之内，就我当前所学，已经不知道往什么方向努力了。在盲目的自信或者满足于当前所学的几天乃至几周的时间里，几乎不怎么去继续学习，在外界刺激或者自觉后才想起来再去看看还有啥适合当前的路线。这时候才会发现“我凑，我怎么这么菜，我要学的还这么多，赶紧学”。这个自信和满足的时间随着我学的越来越多，时间就越来越长。说来也很奇怪，我也无法解释，但确实存在于我身上。</p><p>我查找问题解决方法的演变路线如下。问学长-》学会通过百度查找问题的答案-》学会屏蔽csdn查找问题的答案（提高效率）-》学会使用谷歌中文查找问题的答案-》学会使用谷歌英文查找问题的答案（大三上）。大三上到现在，我查找问题解决方法的能力几乎没有变化，我已经停在英文搜索问题答案这一步了。虽然渐渐的有部分问题我已经找不到合适的答案，但我也很少使用StackOverflow提问，搜不到就算了。下一阶段是啥，我也不知道，我也没去继续了解过。</p><p>自学也导致了我变的相对封闭，万事靠自己，几乎没有和他人交流过相关技术经验。当然也被动的和他人交流过，大多数时候都能收获颇丰。虽然有过收获，但也没怎么主动的和他人去交流过。</p><h2 id="自学能力的体现"><a href="#自学能力的体现" class="headerlink" title="自学能力的体现"></a>自学能力的体现</h2><p>不知道各位玩不玩游戏，我是很喜欢的，也喜欢加一些游戏的讨论群。在群里能看到有人会问一些问题，有的问题相对基础，有的问题相对复杂。对于这些基础问题能不能自己解决，或者是有没有尝试过自己解决，我感觉也是自学能力的体现。就我来说，喜欢去游戏的wiki中找问题的答案，因为我玩的都是相对热门的一些游戏，wiki的建设都是非常完善的，如碧蓝航线、原神、FF14等等。除了wiki还有Nga、贴吧等等地方，或许你的问题已经有人问过N次了。</p><p>再讲一个小例子，我在某厂实习的时候，厂内的论坛由于某些原因加上了禁止复制。之后有人就发帖<strong>调侃</strong>，大概意思是：“我们好歹是技术公司，你整这个是看不起我们吗？也就能拦拦PM之类的吧。不会真的有开发人员不会解决吧，面试遇到了直接给他挂了。”</p><p>禁止复制这个问题我感觉90%的人都遇到过，那么这些人在遇到这个问题后，有没有尝试过去解决这个问题呢？我也没做过调研，或许这90%的人都会解决吧。这件事我感觉就体现了一个人在遇到问题的时候（这个问题很重要，直接影响到了你能不能复制！），有没有尝试过去解决。解决方法自然是百度一搜就一堆，学一次终身受用。</p><h2 id="习惯的养成"><a href="#习惯的养成" class="headerlink" title="习惯的养成"></a>习惯的养成</h2><p>这里的内容是在我大四实习后想到的，大四下学期尝试改正了改正，不过比较难改，成效有限。</p><h2 id="善于发现-多学多做"><a href="#善于发现-多学多做" class="headerlink" title="善于发现 多学多做"></a>善于发现 多学多做</h2><p>脚本 也是遇到问题后主动看看有没有解决方法</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>眼界问题–就他所学，他已经不知道自己该继续往什么方向努力了。在封闭的环境里，几乎不能得到来自外界环境关于我方向的信息，久而久之就养成了一种处处都自己摸索的习惯，更要命的是这个过程一直没什么障碍，导致盲目的自信。</p><p>崇尚自学，但由于缺乏必要的引导，走了不少弯路。后悔吗？不，我从不吃后悔药。遗憾吗？那是肯定的。</p><p>自学能力–在大学里能学习到的唯一的东西就是学习，毕业之后在公司看来大家都是一张白纸，不同的是这张白纸的吸墨能力有多强。</p><p>分不清重点，关注了太多无关紧要的东西。</p><hr><p>不懂平衡术，高考付代价–高效能人士的七个习惯 要事第一</p><p>快想 快说 快干</p><p>题目是这么要求的吗？你从题目能看出什么要求？你认为最重要的要求是什么？将一个简单的问题考虑复杂了，貌似我一直没有抓到重点。考虑过了吗？考虑过没有？怎么实现？</p><p>平时没有怎么去想，脑子之前没有转过，现场去转总会犯傻的。</p><p>知其然而不知其所以然。</p><p>加强实践与执行力。不要欠生活，不要欠工作。出来混，总是要还的，你不会的知识，你懒于想通的东西，总是会在一个必要的时候提醒你、惩罚你。将没有搞懂的、希望做到的东西，写在纸上、贴在面前，认真实践，当你做到的越来越多的时候，你就会越来越自信，你的层次会提到的。相信我，人与人之间的差距很大，原因在于自我控制力有差距。</p><hr><p>有人说，大学的本科阶段，是一个人的性格最终成型的阶段，同时也是为将来的工作打好基础、做知识方面积累的最好的时光。可惜我没抓住。</p><p>大学跟中学最大的一个不同之处就是，课堂上的知识只是一个引子，更大的功夫在课堂外面–在图书馆里、在自习室里。因此，原来差不多的我们一时间因为勤奋程度的不同而拉开了差距，</p><p>计算机行业在十年前就已经是热门行业，每年都有一大批学生选择计算机作为大学专业，全国几乎每个综合性大型都有计算机系。到底是什么让某些人出类拔萃？是深度。<br>每个人都会在自己简历上写会C++，但真正分析过STL源代码的人不多；每个人都会声称自己精通各类操作系统，但是真正能说清楚Linux系统启动流程的也不多。<br>如果一个事情比别人多付出5%的努力，就可能拿到别人200%的汇报</p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>帧同步</title>
      <link href="/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%B8%A7%E5%90%8C%E6%AD%A5/"/>
      <url>/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%B8%A7%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>参考内容 <a href="http://www.skywind.me/blog/archives/131" target="_blank" rel="noopener">帧锁定同步算法</a></p><h1 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h1><p>向服务器发送操作时可以选择使用位图的方式发送。如使用int32_t类型 来表示最多32个按键的状态。</p><h2 id="帧锁定同步"><a href="#帧锁定同步" class="headerlink" title="帧锁定同步"></a>帧锁定同步</h2><p>帧锁定同步会使用逻辑帧的概念来收集玩家操作，然后向服务发送。等待所有玩家的帧到达后, 才进行同步, 所以称为Lock.</p><h2 id="乐观帧锁定"><a href="#乐观帧锁定" class="headerlink" title="乐观帧锁定"></a>乐观帧锁定</h2><p>乐观帧锁定在玩家按下操作键后就会立即向服务器发送本次操作。</p><p>服务器本身含有游戏循环，每个逻辑帧会将本逻辑帧内收集到的操作发送给客户端。发送的时候会带上逻辑帧的标号。</p><p>客户端收到服务器发送的操作后，目前看到了两种执行方式。</p><ol><li>使用回调等方式，直接将数据包中的操作作用到玩家上。<strong>此时不能追帧？， 而且回放也做不了</strong></li><li>将所有操作收集起来，根据逻辑帧信息进行作用。此时如果逻辑帧落后则进行追帧操作。</li></ol><h3 id="回放-采用操作2"><a href="#回放-采用操作2" class="headerlink" title="回放-采用操作2"></a>回放-采用操作2</h3><p>服务器每次下发时是以逻辑帧为单位，客户端取数据包时同样以逻辑帧为单位。</p><p>回放时，服务器一次性下发所有保存的 带服务器逻辑帧编号 的数据包。<br>客户端取数据包执行时，只会取服务器逻辑帧编号小于等于当前本地逻辑帧编号的数据包。</p><h3 id="逻辑帧同步"><a href="#逻辑帧同步" class="headerlink" title="逻辑帧同步"></a>逻辑帧同步</h3><p>所有客户端和服务器同步逻辑帧的编号，使用PING包计算本地和服务器之间的延迟T。</p><p>当服务器下发逻辑帧开始命令后，使用本地的时间减去 0.5T 即为真正的开始时间。</p><h1 id="可靠UDP"><a href="#可靠UDP" class="headerlink" title="可靠UDP"></a>可靠UDP</h1><h2 id="对抗丢包"><a href="#对抗丢包" class="headerlink" title="对抗丢包"></a>对抗丢包</h2><p>冗余N帧</p><h1 id="小断线重连"><a href="#小断线重连" class="headerlink" title="小断线重连"></a>小断线重连</h1><p>只有当收到下一帧的数据包时才消耗本帧的数据包</p><p>如果直接消耗本帧的数据包，发生断网时如果本帧含有多个数据包。恢复时还需要额外的带上其他标记，不利于请求以后的数据包。如果收到下一帧时才消耗，恢复时只需要请求接下来的数据包即可。</p><h1 id="大断线重连"><a href="#大断线重连" class="headerlink" title="大断线重连"></a>大断线重连</h1><h1 id="New"><a href="#New" class="headerlink" title="New"></a>New</h1><p>0延时和瞬间处理的情况下, 服务器每秒30轮循环(30帧). 客户端产生输入后立刻(帧结束?)发送同步包, 服务器每次收到后将包放入队列, 服务器每轮循环开始时从队列中取出上一帧的所有输入, (进行计算, 服务器保存一份本帧结束时的状态), 将上一帧的输入发送到客户端(同一帧内的输入是否要严格区分相差多少ms?). 客户端收到输入后立刻(帧结束?)应用数据包.</p><p>断线重连, 请求增量输入还是服务器当前状态? 请求增量输入需要知晓从哪一帧开始断线, 请求丢失部分. 请求服务器缓存的一份状态则不需要, 直接进行全量替换.</p><p>客户端是否需要帧循环? 需要的话是否需要帧编号和服务器进行同步? 服务器肯定是有帧循环和帧编号.</p><p>存在延时: 客户端的输入不能立刻到达服务器, 服务器的输出不能立刻到达客户端. 服务器是否需要等待客户端一帧的输入?<br>需要就会导致本帧被卡主, 高延迟玩家的体验要好一点, 客户端的输入是否需要等到上一帧结果出现后再发送? 需要的话同步性会加强, 不需要时低延迟的会抢跑一些输入.<br>不需要时, 各跑各的岂不是很方便? 客户端的输入可以随时到来, 来了之后放入下一帧队列即可. 不过这样会导致高延迟的体验较差, 因为低延迟的会更先看到画面, 更早的做出操作.</p><p>服务器当前状态: 状态同步的缺点就是由于状态计算导致延时变高一点, 这里状态计算肯定是异步的, 不会和服务器帧循环绑定, 这样会导致帧同步变成状态同步.</p><p>更换UDP还需要考虑可靠性的问题, 使用KCP? 还是定制下通过冗余帧之类的减少同步?</p><p>一文深入浅出网络游戏的状态同步,一文深入浅出网络游戏的帧同步.</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SDL学习</title>
      <link href="/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-SDL2/"/>
      <url>/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-SDL2/</url>
      
        <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="CMake配置SDL2"><a href="#CMake配置SDL2" class="headerlink" title="CMake配置SDL2"></a>CMake配置SDL2</h2><pre><code class="c">cmake_minimum_required(VERSION 3.0)project(SDL2Game)set(CMAKE_CXX_STANDARD 17)# SDL2 SDL_IMAGE都放在了一起set(SDL2_INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/SDL2/include)set(SDL2_LIBRARY_DIR ${CMAKE_CURRENT_SOURCE_DIR}/SDL2/lib)add_executable(SDL2Game main.cpp)target_include_directories(SDL2Game PUBLIC ${SDL2_INCLUDE_DIR})target_link_directories(SDL2Game PUBLIC ${SDL2_LIBRARY_DIR})target_link_libraries(SDL2Game PUBLIC mingw32 SDL2main SDL2 SDL2_image)</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="基础使用-窗口-表面-事件"><a href="#基础使用-窗口-表面-事件" class="headerlink" title="基础使用 窗口 表面 事件"></a>基础使用 窗口 表面 事件</h2><pre><code class="c++">#include &lt;SDL2/SDL.h&gt;#include &lt;iostream&gt;// main 函数被声明为了宏，所以argc和argv必须要有// 这个函数会被SDL中内置的main函数调用int main(int argc, char** argv){    // SDL中的窗口    SDL_Window* window = nullptr;    // SDL中的表面    SDL_Surface* window_surface = nullptr;    SDL_Surface* img_surface = nullptr;    SDL_Init(SDL_INIT_VIDEO);    // 创建一个窗口    window = SDL_CreateWindow(&quot;Test Name&quot;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,            640, 480, SDL_WINDOW_SHOWN);    // 获取窗口的表面    window_surface = SDL_GetWindowSurface(window);    // 加载图片    img_surface = SDL_LoadBMP(&quot;../test.bmp&quot;);    if (img_surface == nullptr)    {        std::cout &lt;&lt; &quot;load img error: &quot; &lt;&lt; SDL_GetError() &lt;&lt; std::endl;    }    else    {        // 将图片绘制到窗口的表面上        SDL_BlitSurface(img_surface, nullptr, window_surface, nullptr);        SDL_UpdateWindowSurface(window);    }    // 基于事件的管理机制    bool is_running = true;    SDL_Event ev;    while (is_running)    {        while (SDL_PollEvent(&amp;ev) != 0)        {            if (ev.type == SDL_QUIT)            {                is_running = false;            }        }        SDL_UpdateWindowSurface(window);    }    SDL_FreeSurface(img_surface);    SDL_DestroyWindow(window);    SDL_Quit();    return 0;}</code></pre><h2 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h2><pre><code class="c++">// 退出if (ev.type == SDL_QUIT){    is_running = false;}// 按键按下和弹起else if (ev.type == SDL_KEYUP || ev.type == SDL_KEYDOWN){    std::cout &lt;&lt; &quot;key down: &quot; &lt;&lt; ev.key.keysym.sym &lt;&lt; &quot;, &quot; &lt;&lt; ev.key.timestamp &lt;&lt; std::endl;}// 鼠标左键 鼠标右键 按下else if (ev.type == SDL_MOUSEBUTTONUP || ev.type == SDL_MOUSEBUTTONDOWN){    if (ev.button.button == SDL_BUTTON_LEFT || ev.button.button == SDL_BUTTON_RIGHT)    {        std::cout &lt;&lt; &quot;mouse button down: &quot; &lt;&lt;                    ev.button.button &lt;&lt; &quot;, &quot; &lt;&lt; ev.key.timestamp &lt;&lt; std::endl;    }}// 鼠标移动else if (ev.type == SDL_MOUSEMOTION){    std::cout &lt;&lt; ev.motion.x &lt;&lt; &quot;, &quot; &lt;&lt; ev.motion.y &lt;&lt; std::endl;}</code></pre><h2 id="文字输入"><a href="#文字输入" class="headerlink" title="文字输入"></a>文字输入</h2><pre><code class="c++">SDL_StartTextInput();std::string text;while (is_running){    while (SDL_PollEvent(&amp;ev) != 0)    {        if (ev.type == SDL_QUIT)        {            is_running = false;        }        else if (ev.type == SDL_TEXTINPUT || ev.type == SDL_KEYDOWN)        {            // clear            system(&quot;cls&quot;);            if (ev.type == SDL_KEYDOWN &amp;&amp; ev.key.keysym.sym == SDLK_BACKSPACE &amp;&amp;                text.length() &gt; 0)            {                text = text.substr(0, text.length() - 1);            }            else if (ev.type == SDL_TEXTINPUT)            {                text += ev.text.text;            }            std::cout &lt;&lt; text &lt;&lt; std::endl;        }    }    SDL_UpdateWindowSurface(window);}SDL_StopTextInput();</code></pre><h2 id="图片优化-amp-amp-图片缩放"><a href="#图片优化-amp-amp-图片缩放" class="headerlink" title="图片优化 &amp;&amp; 图片缩放"></a>图片优化 &amp;&amp; 图片缩放</h2><pre><code class="c++">SDL_Surface* OptimizedSurface(const std::string&amp; filepath, SDL_Surface* windows_surface){    SDL_Surface* image_surface = SDL_LoadBMP(filepath.c_str());    if (!image_surface)    {        std::cout &lt;&lt; &quot;error: &quot; &lt;&lt; SDL_GetError() &lt;&lt; std::endl;        return nullptr;    }    auto converted_surface =            SDL_ConvertSurface(image_surface, windows_surface-&gt;format, 0);    SDL_FreeSurface(image_surface);    return converted_surface;}// 图片缩放window = SDL_CreateWindow(&quot;Test Name&quot;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,            640, 480, SDL_WINDOW_SHOWN);SDL_Surface* windows_surface = SDL_GetWindowSurface(window);SDL_Surface* image = OptimizedSurface(&quot;../test.bmp&quot;, windows_surface);SDL_Rect rect{0, 0, 640, 480};SDL_BlitScaled(image, nullptr, windows_surface, &amp;rect);</code></pre><h2 id="Texture-amp-amp-Render"><a href="#Texture-amp-amp-Render" class="headerlink" title="Texture &amp;&amp; Render"></a>Texture &amp;&amp; Render</h2><p>这么多Destroy, 感觉可以上RAII了。</p><pre><code class="c++">#include &lt;SDL2/SDL.h&gt;#include &lt;iostream&gt;SDL_Texture* LoadTexture(const std::string&amp; filepath, SDL_Renderer* target_render){    SDL_Surface* image_surface = SDL_LoadBMP(filepath.c_str());    if (!image_surface)    {        std::cout &lt;&lt; &quot;error: &quot; &lt;&lt; SDL_GetError() &lt;&lt; std::endl;        return nullptr;    }    return SDL_CreateTextureFromSurface(target_render, image_surface);}// main 函数被声明为了宏，所以argc和argv必须要有// 这个函数会被SDL中内置的main函数调用int main(int argc, char** argv){    // SDL中的窗口    SDL_Window* window = nullptr;    SDL_Init(SDL_INIT_VIDEO);    // 创建一个窗口    window = SDL_CreateWindow(&quot;Test Name&quot;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,            640, 480, SDL_WINDOW_SHOWN);    // SDL_RENDERER_ACCELERATED 硬件加速    SDL_Renderer* render_target = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);    SDL_Texture* texture = LoadTexture(&quot;../test.bmp&quot;, render_target);    bool is_running = true;    SDL_Event ev;    while (is_running)    {        while (SDL_PollEvent(&amp;ev) != 0)        {            if (ev.type == SDL_QUIT)            {                is_running = false;            }            // 清除            SDL_RenderClear(render_target);            // 将texture绘制到render上            SDL_RenderCopy(render_target, texture, nullptr, nullptr);            // 绘制            SDL_RenderPresent(render_target);        }        SDL_UpdateWindowSurface(window);    }    SDL_DestroyWindow(window);    SDL_DestroyRenderer(render_target);    SDL_DestroyTexture(texture);    SDL_Quit();    return 0;}</code></pre><h2 id="加载-PNG-IMG等"><a href="#加载-PNG-IMG等" class="headerlink" title="加载 PNG IMG等"></a>加载 PNG IMG等</h2><p>需要使用SDLImage <a href="https://www.libsdl.org/projects/SDL_image/" target="_blank" rel="noopener">https://www.libsdl.org/projects/SDL_image/</a></p><p>这样即可使用<code>IMG_Load</code>加载图片</p><p>使用前需要进行初始化</p><pre><code class="c++">auto init_flag = IMG_INIT_PNG | IMG_INIT_JPG;if (IMG_Init(init_flag) != init_flag){    std::cout &lt;&lt; &quot;init error&quot; &lt;&lt; std::endl;}</code></pre><h2 id="精灵移动"><a href="#精灵移动" class="headerlink" title="精灵移动"></a>精灵移动</h2><p><a href="https://retro-sprite-creator.nihey.org/character/new" target="_blank" rel="noopener">https://retro-sprite-creator.nihey.org/character/new</a></p><p><a href="https://web.archive.org/web/20141219071009/http://www.famitsu.com/freegame/tool/chibi/index1.html" target="_blank" rel="noopener">https://web.archive.org/web/20141219071009/http://www.famitsu.com/freegame/tool/chibi/index1.html</a></p><pre><code class="c++">#include &lt;SDL2/SDL.h&gt;#include &lt;SDL2/SDL_image.h&gt;#include &lt;iostream&gt;#include &lt;array&gt;SDL_Texture* LoadTexture(const std::string&amp; filepath, SDL_Renderer* target_render){    SDL_Surface* image_surface = IMG_Load(filepath.c_str());    if (!image_surface)    {        std::cout &lt;&lt; &quot;error: &quot; &lt;&lt; SDL_GetError() &lt;&lt; std::endl;        return nullptr;    }    return SDL_CreateTextureFromSurface(target_render, image_surface);}// main 函数被声明为了宏，所以argc和argv必须要有// 这个函数会被SDL中内置的main函数调用int main(int argc, char** argv){    const int FPS = 60;    float frame_time = 0;    uint32_t prev_time = 0;    uint32_t current_time = 0;    float delta_time = 0;    float move_speed = 100.0f;    SDL_Init(SDL_INIT_VIDEO);    IMG_Init(IMG_INIT_PNG);    SDL_Window*  window = SDL_CreateWindow(&quot;Test Name&quot;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,            640, 480, SDL_WINDOW_SHOWN);    // SDL_Renderer感觉是一个图层，index代表图层的下标从-1开始    // SDL_RENDERER_ACCELERATED 硬件加速    SDL_Renderer* render_target = SDL_CreateRenderer(window, -1,            SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);    // 图层背景色    SDL_SetRenderDrawColor(render_target, 0xFF, 0, 0, 0);    SDL_Texture* texture = LoadTexture(&quot;../sprite-sheet.png&quot;, render_target);    int texture_width, texture_height, frame_width, frame_height;    SDL_QueryTexture(texture, nullptr, nullptr, &amp;texture_width, &amp;texture_height);    frame_width = texture_width / 3;    frame_height = texture_height / 4;    SDL_Rect player_rect{ 0, 0, frame_width, frame_height};    SDL_Rect player_pos{ 0, 0, 32, 32};    // 下 左 右 上    std::array&lt;int, 4&gt; rect_y = {0, frame_width, frame_width * 2, frame_width * 3};    bool is_running = true;    SDL_Event ev;    while (is_running)    {        prev_time = current_time;        current_time = SDL_GetTicks();        delta_time = (current_time - prev_time) / 1000.0f;        while (SDL_PollEvent(&amp;ev) != 0)        {            if (ev.type == SDL_QUIT)            {                is_running = false;            }        }        const uint8_t* key_state = SDL_GetKeyboardState(nullptr);        // 如果这里不强制转换 而是用float 向右和下移动 会比 向上和左移动 要慢        int move_length = static_cast&lt;int&gt;(move_speed * delta_time);        // float move_length = move_speed * delta_time;        if (key_state[SDL_SCANCODE_RIGHT])        {            player_pos.x += move_length;            player_rect.y = rect_y[2];        }        else if (key_state[SDL_SCANCODE_LEFT])        {            player_pos.x -= move_length;            player_rect.y = rect_y[1];        }        else if (key_state[SDL_SCANCODE_UP])        {            player_pos.y -= move_length;            player_rect.y = rect_y[3];        }        else if (key_state[SDL_SCANCODE_DOWN])        {            player_pos.y += move_length;            player_rect.y = rect_y[0];        }        frame_time += delta_time;        if (frame_time &gt;= 0.25f)        {            frame_time = 0;            player_rect.x += frame_width;            if (player_rect.x &gt;= texture_width)            {                player_rect.x = 0;            }        }        // 清除图层        SDL_RenderClear(render_target);        // 将texture绘制到render上        SDL_RenderCopy(render_target, texture, &amp;player_rect, &amp;player_pos);        // 绘制图层        SDL_RenderPresent(render_target);    }    SDL_DestroyWindow(window);    SDL_DestroyRenderer(render_target);    SDL_DestroyTexture(texture);    SDL_Quit();    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UE5学习</title>
      <link href="/2022/05/UE5-%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/UE5-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="UE5编译时无法找到头文件-amp-amp-UE5使用最新C-amp-amp-使用Release库"><a href="#UE5编译时无法找到头文件-amp-amp-UE5使用最新C-amp-amp-使用Release库" class="headerlink" title="UE5编译时无法找到头文件 &amp;&amp; UE5使用最新C++ &amp;&amp; 使用Release库"></a>UE5编译时无法找到头文件 &amp;&amp; UE5使用最新C++ &amp;&amp; 使用Release库</h2><p>修改Build.cs文件</p><pre><code class="c++">// Copyright Epic Games, Inc. All Rights Reserved.using UnrealBuildTool;public class LibTest : ModuleRules{    public LibTest(ReadOnlyTargetRules Target) : base(Target)    {        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;        PublicDependencyModuleNames.AddRange(new string[] { &quot;Core&quot;, &quot;CoreUObject&quot;, &quot;Engine&quot;, &quot;InputCore&quot; });        PrivateDependencyModuleNames.AddRange(new string[] {  });        // 最新C++标准        CppStandard = CppStandardVersion.Latest;        // 添加头文件和lib目录        PublicIncludePaths.Add(&quot;C:\\Data\\CPP\\GameProject\\Buffer&quot;);        PublicIncludePaths.Add(&quot;C:\\Data\\CPP\\GameProject\\Message&quot;);        PublicAdditionalLibraries.Add(&quot;C:\\Data\\CPP\\GameProject\\x64\\Release\\Buffer.lib&quot;);        PublicAdditionalLibraries.Add(&quot;C:\\Data\\CPP\\GameProject\\x64\\Release\\Message.lib&quot;);    }}</code></pre><h2 id="VS不识别mingw编译出的库"><a href="#VS不识别mingw编译出的库" class="headerlink" title="VS不识别mingw编译出的库"></a>VS不识别mingw编译出的库</h2><p>需要在clion中设置cmake的Generator为VS系列 如 Visual Studio 17 2022</p><h2 id="热编译莫名出错"><a href="#热编译莫名出错" class="headerlink" title="热编译莫名出错"></a>热编译莫名出错</h2><p>关闭UE5，使用VS直接编译，编译成功后再次打开UE5 后续即可进行正常编译。</p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>模板类的前缀为T。<br>继承自UObject的类前缀为U。<br>继承自AActor的类前缀为A。<br>继承自SWidget的类前缀为S。<br>抽象界面类的前缀为I。<br>列举的前缀为E。<br>布尔变量必须以b为前缀（例如 bPendingDestruction 或 bHasFadedIn）。<br>其他多数类均以F为前缀，而部分子系统则以其他字母为前缀。</p><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h2><pre><code class="c++">GEngine-&gt;AddOnScreenDebugMessage(-1, 1.0f, FColor::Red, FString::Printf(TEXT(&quot;DeltaTime: %f&quot;), DeltaTime));GEngine-&gt;AddOnScreenDebugMessage(-1, 1.0f, FColor::Red, FString::Printf(TEXT(&quot;FramePerSec: %d&quot;), FramePerSec));</code></pre><h1 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h1><h2 id="使用C-创建蓝图函数库"><a href="#使用C-创建蓝图函数库" class="headerlink" title="使用C++创建蓝图函数库"></a>使用C++创建蓝图函数库</h2><pre><code class="c++">// .hUFUNCTION(BlueprintCallback, Category=&quot;MyCategory&quot;)static FString HelloUnreal(int a, int b);// .cppstatic FString XXX::HelloUnreal(int a, int b){    return FString::Printf(TEXT(&quot;HelloUnreal %d + %d = %d&quot;), a, b, a + b);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> UE5 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>协程</title>
      <link href="/2022/05/CPP-%E5%8D%8F%E7%A8%8B/"/>
      <url>/2022/05/CPP-%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="2022-05-07-内容"><a href="#2022-05-07-内容" class="headerlink" title="2022-05-07 内容"></a>2022-05-07 内容</h1><p><a href="https://bbs.huaweicloud.com/blogs/266537?utm_source=segmentfault&amp;utm_medium=bbs-ex&amp;utm_campaign=other&amp;utm_content=content" target="_blank" rel="noopener">https://bbs.huaweicloud.com/blogs/266537?utm_source=segmentfault&amp;utm_medium=bbs-ex&amp;utm_campaign=other&amp;utm_content=content</a></p><p>协程被抽象为了<code>std::coroutine_handle&lt;promise_type&gt;</code>对象</p><p>对于单线程来说，协程可以通过co_yield提前返回，resume恢复运行，将一个长操作打散为多个短操作</p><h1 id="2023-3-22-游戏中的协程"><a href="#2023-3-22-游戏中的协程" class="headerlink" title="2023-3-22 游戏中的协程"></a>2023-3-22 游戏中的协程</h1><p>协程在游戏这种帧驱动中存在以下问题。</p><p>在第一帧的时候，Get了一个指针，在本帧的时候是保证能用的。之后yield再恢复可能已经第三帧了，第一帧获取的指针可能到了第三帧就垂悬了</p><p><strong>例子如下</strong></p><p>处理客户端RPC请求时在第一帧，这时通过RoleId获取了指向玩家数据A的指针，之后yield。</p><p>第二帧玩家下线，玩家数据A被删除</p><p>第三帧从yield恢复，这时指向玩家数据A的指针就是垂悬指针。</p><p>所以需要在使用协程后，将上文的所有指针、引用等可能失效的都重新获取。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.s081学习 &amp;&amp; tmux</title>
      <link href="/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-6.s081/"/>
      <url>/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-6.s081/</url>
      
        <content type="html"><![CDATA[<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><pre><code class="sh"># 均在xv6目录下 执行make qemu-gdb# 初次运行 可能会提示 配置gdbinit信任，按照提示操作即可riscv64-unknown-elf-gdbmake grade</code></pre><p>ubuntu20.04安装riscv64-unknown-elf-gdb</p><pre><code class="sh">sudo apt-get install libncurses5-dev python2 python2-dev texinfo libreadline-dev libgmp3-devwget https://mirrors.tuna.tsinghua.edu.cn/gnu/gdb/gdb-12.1.tar.gztar zxf gdb-12.1.tar.gzmkdir buildcd build../configure --prefix=/usr/local --with-python=/usr/bin/python2 --target=riscv64-unknown-elf --enable-tui=yesmake -j4sudo make install</code></pre><p>gdb使用</p><pre><code class="sh">tui enablelayout split # = asm + srclayout asmlayout src</code></pre><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><pre><code class="sh">C-b ? # 查看所有按键C-b c # 创建新窗口C-b &amp; # 关闭窗口C-b 0 # 切换到窗口 0C-b p # 上一个窗口C-b n # 下一个窗口C-b :neww -dnxd # 创建名为xd的新窗口 d参数 创建新窗口 n参数 指定窗口名称C-b d # 分离tmux窗口tmux ls # 查看分离的窗口tmux attach -t xv6 # 重新attach xv6窗口</code></pre><pre><code class="sh">C-b %  # 垂直分割当前paneC-b \&quot; # 水平分割当前paneC-b x # 关闭当前paneC-b Up Down Left Right # 切换当前paneC-b q # 显示pane标号C-b q1 # 切换到标号为1的paneC-b C-Up Down Left Right # 调整当前pane大小 </code></pre><h2 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h2><pre><code class="sh">C-a x # exit qemuC-a c # enter code# codeinfo mem # 查看当前的页表使用情况</code></pre><h1 id="300问"><a href="#300问" class="headerlink" title="300问"></a>300问</h1><h2 id="exec如何实现的进程切换？"><a href="#exec如何实现的进程切换？" class="headerlink" title="exec如何实现的进程切换？"></a>exec如何实现的进程切换？</h2><p>exec执行中将trapframe中代表pc指针的epc设定为了main函数的地址。</p><p>然而直到usertrap中调用完syscall后，调用usertrapret时才通过<code>w_sepc(p-&gt;trapframe-&gt;epc);</code>将epc设定到了寄存器中</p><p>之后执行trampoline中的userret汇编代码，最后sret时才完成切换</p><h2 id="malloc分配虚拟内存如何保证连续？"><a href="#malloc分配虚拟内存如何保证连续？" class="headerlink" title="malloc分配虚拟内存如何保证连续？"></a>malloc分配虚拟内存如何保证连续？</h2><p><strong>虚拟内存的管理如下</strong></p><p>虚拟内存的的分配以8B为单位，块大小*8为实际大小，分配时需要补齐到8的倍数。</p><p>假设存在两块不连续的虚拟内存（500*8+8B，1000*8+8B）。首8个字节存放下一块地址和块大小，所以不会被使用。</p><p>当分配虚拟内存时</p><ul><li>如果需求4000B，则将整块（500*8+8B）虚拟内存拿走，从虚拟内存中将本块（500*8+8B）去除。</li><li>如果需求6000B，则令本块（1000*8+8B）虚拟内存的大小减少为（249*8+8B），然后将高位部分的（750*8+8B）取走，高位部分的首8个字节同样存放了本块大小。</li><li>所有块都不满足时，转去申请最少4096*8B的虚拟内存</li></ul><p>当归还虚拟内存时</p><ul><li>判断1：判断本块是否能与下一块整合成一块。如果可以则令本块指向下下一块，本块大小+=下一块大小）。否则令本块指向下一块。</li><li>判断2：（此时本块的下一块地址已经被判断1修改）判断本块是否能与上一块整合成一块。如果可以则令上一块指向本块的下一块，上一块大小+=本块大小。否则令上一块指向本块。</li></ul><p>归还时可能将三块内存整合为一块，也可能整合前两块或后两块，或直接插入到两块中间。</p><h2 id="xv6为什么没使用-用户的栈-而是用内核栈"><a href="#xv6为什么没使用-用户的栈-而是用内核栈" class="headerlink" title="xv6为什么没使用 用户的栈 而是用内核栈"></a>xv6为什么没使用 用户的栈 而是用内核栈</h2><p>一些用户程序可能不需要栈，或者是特殊的栈，这时内核就不能使用用户的栈。</p><h2 id="tp寄存器-和-hartid是什么"><a href="#tp寄存器-和-hartid是什么" class="headerlink" title="tp寄存器 和 hartid是什么"></a>tp寄存器 和 hartid是什么</h2><p>代表当前进程所在CPU核心的编号，这样就能得知CPU的核心上运行着哪些进程。</p>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>asio官方文档笔记</title>
      <link href="/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-asio%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-asio%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>文档链接 <a href="https://think-async.com/Asio/asio-1.22.1/doc/asio/overview.html" target="_blank" rel="noopener">https://think-async.com/Asio/asio-1.22.1/doc/asio/overview.html</a></p><p><a href="https://think-async.com/Asio/asio-1.22.1/doc/asio/overview/composition/cpp20_coroutines.html#asio.overview.composition.cpp20_coroutines.co_ordinating_parallel_coroutines" target="_blank" rel="noopener">C++20 协程支持</a></p><p><a href="https://think-async.com/Asio/asio-1.22.1/doc/asio/reference.html" target="_blank" rel="noopener">Reference</a></p><h1 id="asio基本分析"><a href="#asio基本分析" class="headerlink" title="asio基本分析"></a>asio基本分析</h1><p><code>io_context</code>是作为调用操作系统接口的中间层</p><p><strong>同步模式</strong><br>当发生错误的时候，如果没有指定<code>error_code</code>，则会抛出异常。 false作为没有异常出现</p><p><strong>异步模式</strong><br>调用的异步请求API，会产生一个task。<br>当task对应的操作结束后，task会被放入队列中，等待<code>io_context::run()</code>读取队列中的task进行分发。</p><h1 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h1><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><p>同步操作的返回值与调用的函数及其参数有关。<br>异步操作handler参数的类型和顺序与初始化函数（请求异步操作的函数 如async_write）及其参数有关。</p><p>同步操作需要临时资源（内存、文件描述符和线程）时，在从函数返回前临时资源会被释放。<br>异步操作需要临时资源时，在调用结束handler前被释放，便于可能产生的重复调用。</p><h2 id="异步代理"><a href="#异步代理" class="headerlink" title="异步代理"></a>异步代理</h2><p>异步代理是异步操作的顺序组成。每个异步操作被认为是一个异步代理的一部分，即使异步代理中只有一个异步操作。<br>一个异步代理可能和其他代理并发执行，异步代理将异步操作看做是线程去同步操作。</p><p>调用初始化函数后，产生异步操作，handler被调用。handler中再次调用初始化函数，产生异步操作，依次循环下去称为异步代理。</p><h2 id="Associated-Characteristics-and-Associators"><a href="#Associated-Characteristics-and-Associators" class="headerlink" title="Associated Characteristics and Associators"></a>Associated Characteristics and Associators</h2><p>异步代理的组成</p><ul><li>allocator：决定代理中的异步操作如何获得内存资源</li><li>cancellation slot：决定代理中的异步操作如何支持取消</li><li>executor：决定代理的handler将如何进入队列，和被运行</li></ul><p>异步操作将通过查询上述的内容，用于满足自己的需要和偏好。查询则是通过associator traits完成。</p><p>associator traits可以通过具体的handler类型定制</p><p>异步操作通过associator traits完成如下计算：（s为S类型的值，c为C类型的值）</p><ul><li>通过<code>associated_R&lt;S, C&gt;::type</code>获取type</li><li>通过<code>associated_R&lt;S, C&gt;::get(s, c)</code>获取value</li></ul><p>为了方便也可以通过如下的方式获取对应内容</p><ul><li><code>associated_R_t&lt;S, C&gt;</code></li><li><code>get_associated_R(s, c)</code></li></ul><h2 id="子代理"><a href="#子代理" class="headerlink" title="子代理"></a>子代理</h2><p>子代理为多个嵌套的异步操作</p><p>异步代理可以由子代理构成，子代理之间切换时要注意上一个子代理的资源是否已经释放。</p><p>同步操作可以在同一个线程上简单的调用子函数，子函数功能不会发生改变。<br>异步代理通过不断的分享父代理的Characteristics，实现功能不会发生改变。</p><p>在分享Characteristics时，异步操作可能有选择性的分享父代理的Characteristics。</p><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>每个异步代理都有一个与之关联的executor，其决定代理的handler将如何进入队列，和被运行</p><p>executor的功能如下</p><ul><li>当handler中会处理共享资源时，协调不同的异步代理，保证每次只有一个代理执行handler。</li><li>保证代理运行在指定的资源上（如CPU）。</li><li>在GUI更新线程上，排列handler，保证他们可以安全的更新用户界面元素。</li><li>可以控制在执行handler前后，去执行指定的代码（如记录机制，用户校验等）。</li><li>指定异步代理和handler的优先级。</li></ul><p>所以executor决定了异步代理何时、何地和如何运行。</p><h2 id="Allocators-未完"><a href="#Allocators-未完" class="headerlink" title="Allocators - 未完"></a>Allocators - 未完</h2><p>每个异步代理都有一个与之关联的allocator。allocator是用于获取per-operation stable memory resources (POSMs).</p><p>内存是以每次操作为单位分配的。</p><p>异步操作将会在如下途径利用POSMS</p><ul><li>操作不需要POSMS。如操作所包装的现有API，具有其自己的内存管理。或是将状态保存到现有的内存中，如现有的buffer。</li><li>操作使用单个固定大小的POSM。如操作会将一些状态存储在链表中。</li><li>操作使用单个动态大小的POSM。如操作存储用户buffer或动态结构体的拷贝。</li><li>操作使用单个POSMS。如在链表中使用固定大小的POSM，在buffer中使用动态大小的POSM。</li></ul><p><a href="https://think-async.com/Asio/asio-1.22.1/doc/asio/overview/model/allocators.html" target="_blank" rel="noopener">https://think-async.com/Asio/asio-1.22.1/doc/asio/overview/model/allocators.html</a></p><p><a href="https://think-async.com/Asio/asio-1.22.1/doc/asio/overview/core/allocation.html" target="_blank" rel="noopener">https://think-async.com/Asio/asio-1.22.1/doc/asio/overview/core/allocation.html</a> 定制allocation</p><h2 id="Cancellation"><a href="#Cancellation" class="headerlink" title="Cancellation"></a>Cancellation</h2><p>可以为异步代理指定cancel handler，当代理收到取消信号时cancel handler会被调用。cancel handler是以代理为单位设置的。</p><p>用途：当一个子代理完成时，可能就不需要另一个子代理，所以可以将另一个子代理取消。</p><p><a href="https://think-async.com/Asio/asio-1.22.1/doc/asio/overview/core/cancellation.html" target="_blank" rel="noopener">https://think-async.com/Asio/asio-1.22.1/doc/asio/overview/core/cancellation.html</a> 定制cancel</p><h2 id="Completion-Tokens"><a href="#Completion-Tokens" class="headerlink" title="Completion Tokens"></a>Completion Tokens</h2><p>下面的例子中async_read_some的最后一个参数即为Completion Token。</p><pre><code class="cpp">// lambda将在操作完成后被调用。同时会将结果传递进来socket.async_read_some(buffer,    [](error_code e, size_t)    {      // ...    }  );// 初始化函数不仅执行read操作，还返回了futurefuture&lt;size_t&gt; f =  socket.async_read_some(      buffer, use_future    );// ...size_t n = f.get();// 这里初始化函数不会立即执行read操作，只是会返回一个awaitable等待co_await时才执行操作。awaitable&lt;void&gt; foo(){  size_t n =    co_await socket.async_read_some(        buffer, use_awaitable      );  // ...}// yield_context会让初始化函数表现为同步操作。初始化函数不仅会立即执行read操作，还会在结束前阻塞有栈协程// 从有栈协程的角度看，操作是同步的。void foo(asio::yield_context yield){  size_t n = socket.async_read_some(buffer, yield);  // ...}</code></pre><h1 id="核心概念和功能"><a href="#核心概念和功能" class="headerlink" title="核心概念和功能"></a>核心概念和功能</h1><h2 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h2><h2 id="线程与ASIO"><a href="#线程与ASIO" class="headerlink" title="线程与ASIO"></a>线程与ASIO</h2><p>一般来说多个线程操作同一个对象是不安全的，但是诸如io_context等提供了线程安全的强力保证。</p><p>可以使用线程池调用<code>io_context::run()</code>。其中的每个线程都是平等的，io_context将任务任意的分配给他们。<br>同时可以使用post向io_context中发送任务。</p><h2 id="使用无锁编程"><a href="#使用无锁编程" class="headerlink" title="使用无锁编程"></a>使用无锁编程</h2><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>ASIO中定义了如下两种缓冲区。分为可变和不可变buffer。实际实现使用的class而非pair。</p><pre><code class="c++">typedef std::pair&lt;void*, std::size_t&gt; mutable_buffer;typedef std::pair&lt;const void*, std::size_t&gt; const_buffer;</code></pre><p><strong>基于流的缓冲区</strong></p><p>通过data访问const输入流，prepare访问mutable输出流。<br>使用commit将指定大小的数据从输出流首部移动到输入流尾部。<br>使用consume从输入流首部移除数据。</p><p><strong>访问缓冲序列</strong></p><pre><code class="c++">asio::streambuf sb;...std::size_t n = asio::read_until(sock, sb, &#39;\n&#39;);asio::streambuf::const_buffers_type bufs = sb.data();std::string line(    asio::buffers_begin(bufs),    asio::buffers_begin(bufs) + n);</code></pre><h2 id="流-简短的读取和写入"><a href="#流-简短的读取和写入" class="headerlink" title="流 简短的读取和写入"></a>流 简短的读取和写入</h2><p>read_some<br>async_read_some<br>write_some<br>async_write_some</p><h2 id="Reactor风格操作"><a href="#Reactor风格操作" class="headerlink" title="Reactor风格操作"></a>Reactor风格操作</h2><pre><code class="c++">ip::tcp::socket socket(my_io_context);socket.non_blocking(true);socket.async_wait(ip::tcp::socket::wait_read, read_handler);// 可读时会调用void read_handler(asio::error_code ec){  if (!ec)  {    std::vector&lt;char&gt; buf(socket.available());    socket.read_some(buffer(buf));  }}</code></pre><h2 id="基于行的操作。"><a href="#基于行的操作。" class="headerlink" title="基于行的操作。"></a>基于行的操作。</h2><pre><code class="c++">class http_connection{  ...  void start()  {    // 读取到\r\n    asio::async_read_until(socket_, data_, &quot;\r\n&quot;,        boost::bind(&amp;http_connection::handle_request_line, this, _1));  }  void handle_request_line(asio::error_code ec)  {    if (!ec)    {      std::string method, uri, version;      char sp1, sp2, cr, lf;      std::istream is(&amp;data_);      is.unsetf(std::ios_base::skipws);      is &gt;&gt; method &gt;&gt; sp1 &gt;&gt; uri &gt;&gt; sp2 &gt;&gt; version &gt;&gt; cr &gt;&gt; lf;      ...    }  }  asio::ip::tcp::socket socket_;  asio::streambuf data_;};</code></pre><h2 id="定制内存分配"><a href="#定制内存分配" class="headerlink" title="定制内存分配"></a>定制内存分配</h2><h2 id="次序操作取消"><a href="#次序操作取消" class="headerlink" title="次序操作取消"></a>次序操作取消</h2><h2 id="handler跟踪"><a href="#handler跟踪" class="headerlink" title="handler跟踪"></a>handler跟踪</h2><p>通过定义ASIO_ENABLE_HANDLER_TRACKING宏 开启。</p><pre><code>@asio|1589424178.741850|0*1|signal_set@0x7ffee977d878.async_wait@asio|1589424178.742593|0*2|socket@0x7ffee977d8a8.async_accept@asio|1589424178.742619|.2|non_blocking_accept,ec=asio.system:11@asio|1589424178.742625|0|resolver@0x7ffee977d760.cancel@asio|1589424195.830382|.2|non_blocking_accept,ec=system:0@asio|1589424195.830413|&gt;2|ec=system:0@asio|1589424195.830473|2*3|socket@0x7fa71d808230.async_receive@asio|1589424195.830496|.3|non_blocking_recv,ec=system:0,bytes_transferred=151@asio|1589424195.830503|2*4|socket@0x7ffee977d8a8.async_accept@asio|1589424195.830507|.4|non_blocking_accept,ec=asio.system:11@asio|1589424195.830510|&lt;2|@asio|1589424195.830529|&gt;3|ec=system:0,bytes_transferred=151@asio|1589424195.831143|3^5|in &#39;async_write&#39; (./../../../include/asio/impl/write.hpp:330)@asio|1589424195.831143|3*5|socket@0x7fa71d808230.async_send@asio|1589424195.831186|.5|non_blocking_send,ec=system:0,bytes_transferred=1090@asio|1589424195.831194|&lt;3|@asio|1589424195.831218|&gt;5|ec=system:0,bytes_transferred=1090@asio|1589424195.831263|5|socket@0x7fa71d808230.close@asio|1589424195.831298|&lt;5|@asio|1589424199.793770|&gt;1|ec=system:0,signal_number=2@asio|1589424199.793781|1|socket@0x7ffee977d8a8.close@asio|1589424199.793809|&lt;1|@asio|1589424199.793840|&gt;4|ec=asio.system:125@asio|1589424199.793854|&lt;4|@asio|1589424199.793883|0|signal_set@0x7ffee977d878.cancel</code></pre><h1 id="Composition-and-Completion-Tokens"><a href="#Composition-and-Completion-Tokens" class="headerlink" title="Composition and Completion Tokens"></a>Composition and Completion Tokens</h1><h2 id="无栈协程"><a href="#无栈协程" class="headerlink" title="无栈协程"></a>无栈协程</h2><p>同步了两个异步操作</p><pre><code class="c++">struct session : asio::coroutine{  boost::shared_ptr&lt;tcp::socket&gt; socket_;  boost::shared_ptr&lt;std::vector&lt;char&gt; &gt; buffer_;  session(boost::shared_ptr&lt;tcp::socket&gt; socket)    : socket_(socket),      buffer_(new std::vector&lt;char&gt;(1024))  {  }  void operator()(asio::error_code ec = asio::error_code(), std::size_t n = 0)  {    if (!ec) reenter (this)    {      for (;;)      {        yield socket_-&gt;async_read_some(asio::buffer(*buffer_), *this);        yield asio::async_write(*socket_, asio::buffer(*buffer_, n), *this);      }    }  }};</code></pre><h2 id="有栈协程"><a href="#有栈协程" class="headerlink" title="有栈协程"></a>有栈协程</h2><pre><code class="c++">// 第一个参数可以为strand、io_context或者completion handlerasio::spawn(my_strand, do_echo);// ...void do_echo(asio::yield_context yield){  try  {    char data[128];    for (;;)    {      std::size_t length =        my_socket.async_read_some(          asio::buffer(data), yield);      asio::async_write(my_socket,          asio::buffer(data, length), yield);    }  }  catch (std::exception&amp; e)  {    // ...  }}</code></pre><h2 id="C-20协程支持"><a href="#C-20协程支持" class="headerlink" title="C++20协程支持"></a>C++20协程支持</h2><pre><code class="c++">// 第一个参数可以为strand、io_context或者completion handlerasio::co_spawn(executor, echo(std::move(socket)), asio::detached);// ...asio::awaitable&lt;void&gt; echo(tcp::socket socket){  try  {    char data[1024];    for (;;)    {      // 指定 asio::use_awaitable 后初始化函数会返回可被co_await调用的awaitable      std::size_t n = co_await socket.async_read_some(asio::buffer(data), asio::use_awaitable);      co_await async_write(socket, asio::buffer(data, n), asio::use_awaitable);    }  }  catch (std::exception&amp; e)  {    std::printf(&quot;echo Exception: %s\n&quot;, e.what());  }}</code></pre><p>增加异常处理</p><pre><code class="c++">asio::awaitable&lt;void&gt; echo(tcp::socket socket){  char data[1024];  for (;;)  {    std::tuple&lt;asio::error_code, std::size_t&gt; result =      co_await socket.async_read_some(asio::buffer(data),        asio::experimental::as_tuple(asio::use_awaitable));    if (!std::get&lt;0&gt;(result))    {      // success    }    // ...  }}asio::awaitable&lt;void&gt; echo(tcp::socket socket){  char data[1024];  for (;;)  {    auto [ec, n] = co_await socket.async_read_some(asio::buffer(data),        asio::experimental::as_tuple(asio::use_awaitable));    if (!ec)    {      // success    }    // ...  }}asio::awaitable&lt;void&gt; echo(tcp::socket socket){  char data[1024];  for (;;)  {    asio::error_code ec;    std::size_t n = co_await socket.async_read_some(asio::buffer(data),        asio::redirect_error(asio::use_awaitable, ec));    if (!ec)    {      // success    }    // ...  }}</code></pre><h2 id="可恢复的C-20协程"><a href="#可恢复的C-20协程" class="headerlink" title="可恢复的C++20协程"></a>可恢复的C++20协程</h2><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="TCP-UDP-ICMP"><a href="#TCP-UDP-ICMP" class="headerlink" title="TCP UDP ICMP"></a>TCP UDP ICMP</h2><p>TCP</p><pre><code class="c++">// 解析域名 产生endpointip::tcp::resolver resolver(my_io_context);ip::tcp::resolver::query query(&quot;www.boost.org&quot;, &quot;http&quot;);ip::tcp::resolver::iterator iter = resolver.resolve(query);ip::tcp::resolver::iterator end; // End marker.while (iter != end){  ip::tcp::endpoint endpoint = *iter++;  std::cout &lt;&lt; endpoint &lt;&lt; std::endl;}// 创建clientip::tcp::socket socket(my_io_context);socket.connect(endpoint);// 创建serverip::tcp::acceptor acceptor(my_io_context, my_endpoint);ip::tcp::socket socket(my_io_context);acceptor.accept(socket);</code></pre><p>UDP</p><pre><code class="c++">// 解析域名 产生endpointip::udp::resolver resolver(my_io_context);ip::udp::resolver::query query(&quot;localhost&quot;, &quot;daytime&quot;);ip::udp::resolver::iterator iter = resolver.resolve(query);ip::udp::resolver::iterator end; // End marker.while (iter != end){  ip::udp::endpoint endpoint = *iter++;  std::cout &lt;&lt; endpoint &lt;&lt; std::endl;}// bind to anyip::udp::endpoint endpoint(ip::udp::v4(), 12345);ip::udp::socket socket(my_io_context, endpoint);</code></pre><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><h2 id="C-20-协程"><a href="#C-20-协程" class="headerlink" title="C++20 协程"></a>C++20 协程</h2><pre><code class="cpp">#define _WIN32_WINNT 0x0601#include &lt;iostream&gt;#include &lt;coroutine&gt;#include &lt;asio.hpp&gt;#include &lt;vector&gt;#include &lt;format&gt;struct ReadAwaitable{    ReadAwaitable(asio::ip::tcp::socket* client_socket,        std::shared_ptr&lt;std::vector&lt;char&gt;&gt; buffer_ptr):        client_socket_(client_socket),        buffer_ptr_(buffer_ptr),        result_(0)    {    }    bool await_ready() const { return false; }    void await_suspend(std::coroutine_handle&lt;&gt; handle)    {        client_socket_-&gt;async_read_some(asio::buffer(*buffer_ptr_),            [this, handle](const asio::error_code&amp; ec, std::size_t n)            {                result_ = n;                handle.resume();            });    }    std::size_t await_resume()    {        return result_;    }    asio::ip::tcp::socket* client_socket_;    std::shared_ptr&lt;std::vector&lt;char&gt;&gt; buffer_ptr_;    std::size_t result_;};struct WriteAwaitable{    WriteAwaitable(asio::ip::tcp::socket* client_socket,        const char* buffer_ptr, std::size_t length) :        client_socket_(client_socket),        buffer_ptr_(buffer_ptr),        length_(length)    {    }    bool await_ready() const { return false; }    void await_suspend(std::coroutine_handle&lt;&gt; handle)    {        // async_send 不保证发送所有的数据        // async_write_some 不保证发送所有的数据    // async_write 保证不出错时 发送所有数据，否则发送n字节数据        asio::async_write(*client_socket_, asio::buffer(buffer_ptr_, length_),            [handle](const asio::error_code&amp; ec, std::size_t n)            {                handle.resume();            });    }    void await_resume()    {    }    asio::ip::tcp::socket* client_socket_;    const char* buffer_ptr_;    std::size_t length_;};struct Task{    struct promise_type    {        auto get_return_object()        {             return Task{};        }        std::suspend_never initial_suspend() { return {}; }        std::suspend_never final_suspend() noexcept { return {}; }        void unhandled_exception() { std::terminate(); }        void return_void() {}    };};Task OnNewClient(asio::ip::tcp::socket client_socket){    auto buffer_ptr = std::make_shared&lt;std::vector&lt;char&gt;&gt;(1024);    while (true)    {        std::size_t n = co_await ReadAwaitable(&amp;client_socket, buffer_ptr);        if (n == 0)        {            break;        }        co_await WriteAwaitable(&amp;client_socket, buffer_ptr-&gt;data(), n);        std::cout &lt;&lt; std::format(&quot;Echo: {}&quot;, n) &lt;&lt; std::endl;    }}int main(){    asio::io_context context;    asio::ip::tcp::endpoint bind_addr(asio::ip::tcp::v4(), 2048);    asio::ip::tcp::acceptor acceptor(context, bind_addr);    acceptor.async_accept(        [](const asio::error_code&amp; error, asio::ip::tcp::socket client_socket)        {            if (error)            {                std::cout &lt;&lt; error;            }            else            {                OnNewClient(std::move(client_socket));            }        });    context.run();    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux多线程服务器端编程</title>
      <link href="/2022/02/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95120-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/02/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95120-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Linux高性能服务器编程基本看玩了, 现在需要进行实战练习, 然而从单纯的只会api到做出项目, 之间的距离<br>不是一般的小, 最终我选择了这本书…..</p><p>相关自己写的代码 大部分放在github 少部分会写在博客中</p><h1 id="第一部分-C-多线程系统编程"><a href="#第一部分-C-多线程系统编程" class="headerlink" title="第一部分 C++多线程系统编程"></a>第一部分 C++多线程系统编程</h1><h2 id="第一章-线程安全的对象生命期管理"><a href="#第一章-线程安全的对象生命期管理" class="headerlink" title="第一章 线程安全的对象生命期管理"></a>第一章 线程安全的对象生命期管理</h2><p>一个线程安全的class需要满足的条件</p><ul><li>多个线程同时访问, 其表现出正确的行为</li><li>无论操作系统如何调度这些线程, 无论这些线程的执行顺序如何交织</li><li>调用端代码无需额外的同步或其他协调操作</li></ul><p>对象构造的安全, 在构造期间不要泄露this指针, 如果不按照以下规定可能会早对象构造完成前就被访问</p><ul><li>不要在构造函数中注册任何回调</li><li>不要在构造函数中把this传给跨线程的对象</li><li>即便在构造函数最后一行也不行, 因为对象可能是一个父类, 会先构造父类部分, 再构造子类部分</li></ul><p>二段式构造有时候可以解决上面的问题</p><p>二段式构造-构造函数+initialize()<br>因为构造函数没有办法告知是否构造成功, 如果使用异常处理将会使代码复杂化.<br>比如在构造函数中使用new操作, 如果new操作失败就会出现不可预料的后果, 然后外部却无法知道<br>再比如将this传给其他跨线程对象, 如果构造结束前传入, 可能就会发生问题</p><p><strong>shared_ptr的引出</strong><br>如果在一个对象中通过指针访问资源(另一个对象), 知道这个资源是否活着是很难的.<br>如果简单的判断指针是否为空, 可能会在线程B已经判断了指针不为空还没有执行后续操作时, 线程A就把<br>这个资源释放掉了</p><p>当然可以通过资源管理对象 管理上面的资源, 但是也存在上面的问题.</p><p>所以要想安全的销毁对象最好在其他线程都看不到的情况下偷偷进行. (垃圾回收原理, 所有人用不到的东西一定是垃圾)</p><p>所以可以再资源管理对象中增加引用计数, 外部对象在释放资源管理对象中资源的时候, 只是将引用计数减一, 当引用计数为0的时候 在进行释放.</p><p>C++可能出现的内存问题</p><ul><li>缓冲区溢出<br>使用<code>std::vector&lt;char&gt;/std::string</code>或者自己编写<code>Buffer Class来管理缓冲区</code>. 记住缓冲区长度, 通过成员函数而不是裸指针修改缓冲区</li><li>空悬指针/野指针<br>使用shared_ptr/weak_ptr</li><li>重复释放<br>使用scoped_ptr, 只在对象析构的时候释放一次</li><li>内存泄漏<br>使用scoped_ptr, 对象析构时自动释放内存</li><li>不配对的new[]/delete<br>把new[] 统统替换成std::vector, scoped_array</li><li>内存碎片</li></ul><p>使用智能指针存在的一些问题</p><pre><code class="c++">class Book{public:    Book(const std::string&amp; name) :name_(name) {}    void DoSomething() {};private:    std::string name_;};class BookShelf{public:    void Register(std::weak_ptr&lt;Book&gt; book)    {        books_.push_back(book);    }    void CheckBook()    {        // 锁争用        // 这里开头上锁 很可能影响其他的函数, 因为这里调用了用户提供的函数, 等待时间可能会非常长        // 比如Register函数就没有办法在这段时间中插入新的book        // mutex lock 开头上锁 保护vector        Iterator iter = books_.begin();        while (iter != books_.end())        {            std::shared_ptr&lt;Book&gt; obj(iter-&gt;lock());            if (obj)            {                obj-&gt;DoSomething();                iter++;            }            else             {                iter = books_.erase(iter);            }        }    }private:    // 这样就强制要求了Book必须以shared_ptr管理    std::vector&lt;std::weak_ptr&lt;Book&gt;&gt; books_;    typedef std::vector&lt;std::weak_ptr&lt;Book&gt;&gt;::iterator Iterator;};</code></pre><p>在对象的成员变量vector中保存shared_ptr 会导致管理的资源无法被释放, 因为引用计数最少为1.<br>如果保存weak_ptr可能会导致vector只增不减, 因为weak_ptr只管自己管理的资源, 不管自己.<br>通过定制shared_ptr的析构函数可以解决这个问题</p><p>如果将某个类的this指针 bind到一个function对象, 可能在函数调用时传进入一个已经被释放的对象地址<br>建议使用shared_ptr解决上面的问题, 如果想要获得this指针对应的shared_ptr, 可以另类继承<br><code>enable_shared_from_this&lt;T&gt;</code>, 通过在bind函数绑定<code>shared_from_this()返回的shared_ptr</code>.</p><pre><code class="c++">class BookShelf:std::enable_shared_from_this&lt;BookShelf&gt;{public:    // Book对象固然可以销毁, 但是出现了轻微的内存泄漏    // book_只增不减!!!!. 虽然Book对象销毁了但是book_中依然保存着weak_ptr    // 所以需要定制析构功能    std::shared_ptr&lt;Book&gt; GetBook(const std::string &amp;bookname)    {        std::shared_ptr&lt;Book&gt; pbook;        // 上锁        std::weak_ptr&lt;Book&gt;&amp; wkbook = books_[bookname];        pbook = wkbook.lock();        if (!pbook)        {            // pbook.reset(new Book(bookname));            // 依然有问题 绑定this指针可能到时候this指向的对象已经不复存在了            // pbook.reset(new Book(bookname),            //   std::bind(&amp;BookShelf::DeleteBook, this, std::placeholders::_1));            // 注意shared_from_this不能在构造函数中调用, 因为构造Bookshelf的时候 他还没有            // 被交给shared_ptr管理            pbook.reset(new Book(bookname),                std::bind(&amp;BookShelf::DeleteBook, shared_from_this(), std::placeholders::_1));            wkbook = pbook;        }        return pbook;    }private:    std::map&lt;std::string, std::weak_ptr&lt;Book&gt;&gt; books_;    void DeleteBook(Book* book)    {        if (book)        {            // 上锁            books_.erase(book-&gt;GetName());        }        delete book;    }};</code></pre><p>然而上面的代码依然有问题<br>依然有个问题. BookShelf的生命期似乎被意外延长了, 他不会短于function对象<br>所以改用weak_pr不就可以了吗</p><pre><code class="c++">class BookShelf:std::enable_shared_from_this&lt;BookShelf&gt;{public:    std::shared_ptr&lt;Book&gt; GetBook(const std::string &amp;bookname)    {        std::shared_ptr&lt;Book&gt; pbook;        std::weak_ptr&lt;Book&gt;&amp; wkbook = books_[bookname];        pbook = wkbook.lock();        if (!pbook)        {            pbook.reset(new Book(bookname),                std::bind(&amp;BookShelf::WkDeleteCallback,                    std::weak_ptr&lt;BookShelf&gt;(shared_from_this()),                    std::placeholders::_1));            wkbook = pbook;        }        return pbook;    }private:    std::map&lt;std::string, std::weak_ptr&lt;Book&gt;&gt; books_;    void WkDeleteCallback(const std::weak_ptr&lt;BookShelf&gt; wk_shelf, Book* book)    {        std::shared_ptr&lt;BookShelf&gt; bookshelf(wk_shelf.lock());        if (bookshelf)        {            DeleteBook(book);        }        delete book;    }    void DeleteBook(Book* book)    {        if (book)        {            // 上锁            books_.erase(book-&gt;GetName());        }    }};</code></pre><p>第一章已经读完了, 笔记只有上面那点. 我在学习Linux高性能服务器编程的大二上半年时间照着书边读边写笔记, 然后后来到了大二下我改成了读完一部分后脑中有什么记什么, 重要的地方如果记不清写不出来就去再看一下. 这样花费在记笔记的时间就少了很多, 写出来的笔记更加方便自己阅读.</p><p>第一章部分内容能看懂 真是谢了之前看的那个项目代码, 那个项目中大量使用了智能指针, 我在读哪个项目的代码的时候查了不少的东西, 现在才能看懂第一章的部分东西.<br>然而大部分?的东西感觉还是似懂非懂, 想写又写不出什么来. 我对于智能指针的使用还是过于晚了把.</p><p>第一章看来后续还要读一遍了</p><h2 id="第二章-线程同步精要"><a href="#第二章-线程同步精要" class="headerlink" title="第二章 线程同步精要"></a>第二章 线程同步精要</h2><p><strong>线程同步的四项原则</strong><br>按重要性排列</p><ol><li>最低限度的共享对象, 减少需要同步的场合, <em>不用就不需要同步了nice!!!</em></li><li>使用高级的并发编程构建, 线程池, 队列, 倒计时</li><li>不得已使用底层同步原语时, 只使用非递归的互斥器和条件变量, 慎用读写锁, 不要用信号量</li><li>除了使用atomic整数外, 不要自己编写lock-free代码, 也不要用内核级的同步原语. 不凭空猜测<br>哪种做法性能更好 比如自旋锁和互斥锁</li></ol><p><strong>互斥器 mutex</strong><br>使用mutex的原则</p><ul><li>使用RAII手法封装mutex的创建销毁加锁解锁这四个操作, 不会因异常而忘记解锁</li><li>只使用非递归的mutex即不可重入的mutex<br>容易排查错误 使用递归mutex问题可能出现也可能不出现(可能由于逻辑问题对一个mutex加锁两次), 而使用非递归即可发现错误并改正</li><li>不手工调用lock()和unlock() 函数, <em>一切交给栈上的Guard对象的构造和析构函数负责</em></li><li>Gruad对象的生命期正好等于临界区</li></ul><p>次要原则</p><ul><li>不使用跨进程的mutex, 进程间通信只用TCP sockets</li><li>加锁解锁在同一个线程 不会出现跨线程的操作 (RAII自动保证)</li><li>不忘记解锁(包括各种提前返回和异常抛出) 不重复解锁 均由RAII自动保证</li><li>必要时考虑用PTHREAD_MUTEX_ERRORCHECK来排错</li></ul><p><strong>封装MutexLock MutexLockGuard Condition</strong><br>在Linux高性能服务器编程中 我也看过了封装mutex, 不过当时并没有使用RAII<br>从这里开始算是对RAII(Resource Acquisition Is Initialization)有了了解</p><p><a href="https://zh.cppreference.com/w/cpp/language/raii" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/raii</a><br>拥有open()/close()、lock()/unlock()，或 init()/copyFrom()/destroy()成员函数的类是非RAII类的典型例子</p><p>RAII将资源封装入一个类 如MutexLock类</p><ul><li>构造函数请求资源, 建立所有类不变式, 或在无法完成时抛出异常</li><li>析构函数释放资源并绝不抛出异常<br>始终经由RALL类的实例使用满足要求的资源如MutexLockGuard类, 资源需满足</li><li>自身拥有自动存储期或临时生存期</li><li>或具有与自动或临时对象的生存期绑定的生存期</li></ul><p>自己的理解就是经由RAII类生存期管理资源, RAII生存期开始即使用资源,<br>当RAII类生存期结束, RAII类中保存着的资源也自动销毁<br>RAII可以有效防止上面那些成对函数调用前一个后 由于异常抛出提前返回等 后一个函数没有被调用 造成资源状态异常</p><p><strong>线程安全的Singleton实现</strong><br>这个类在 flamingo 中也见到了, 这次是升级版<br>借由pthread_once保证线程安全</p><pre><code class="c++">template &lt;typename T&gt;class Singleton : noncopyable{public:    static T&amp; GetInstance()    {        pthread_once(&amp;ponce_, Init);        return *value_;    }private:    Singleton();    ~Singleton();    static void Init()    {        value_ = new T();    }private:    static pthread_once_t ponce_;    static T *value_;};template &lt;typename T&gt;pthread_once_t Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;template &lt;typename T&gt;T* Singleton&lt;T&gt;::value_ = nullptr;</code></pre><p><strong>copy-on-write?? copy-on-other-write!!</strong></p><pre><code class="c++">typedef std::pair&lt;string, int&gt; Entry;typedef std::vector&lt;Entry&gt; EntryList;typedef std::map&lt;string, EntryList&gt; Map;typedef std::shared_ptr&lt;Map&gt; MapPtr;MapPtr data_;</code></pre><p>好的现在数据存储在data_ 中 系统中存在多个读线程和一个写线程 针对data_<br>如果写线程不管不顾 有数据就往data_中写入 出现了读写进程同时访问data_就会出问题.<br>就书中描述来意思来说 不用大刀阔斧的使用读写锁, 能用mutex简单解决为什么要用读写锁.<br>那么如何保证读写安全呢?</p><p>当读进程读的时候 拷贝一次data_ data_的引用计数至少为2.<br>就在这时写进程判断 data_引用计数不为1, 于是拷贝原来指向的map, 然后将data_ reset指向新的map<br>这时data_引用计数变为1 可以正常写了. 而读进程中保存的map拷贝是稍久的 引用计数降为1, 执行完后就自动析构了旧数据</p><p>下面的代码 读部分只在GetData中加锁, 缩小了临界区</p><pre><code class="c++">MapPtr GetData() const{    // binding reference of type ‘MutexLock&amp;’ to ‘const MutexLock’ discards qualifiers    MutexLockGuard lock(mutex_);    return data_;}int CustomerData::Query(const string &amp;custmoner, const string &amp;stock) const{    MapPtr data = GetData();    Map::const_iterator entries = data-&gt;find(custmoner);    if (entries != data-&gt;end())    {        return FindEntry(entries-&gt;second, stock);    }    else    {        return -1;    }}void CustomerData::Update(const string &amp;customer, const CustomerData::EntryList &amp;entries){    MutexLockGuard lock(mutex_);    if (!data_.unique())    {        MapPtr new_data(new Map(*data_));        data_.swap(new_data);        // sawp后 先前某个线程通过GetData拿到MapPtr 他会读到稍旧的数据    }    assert(data_.unique());    (*data_)[customer] = entries;}</code></pre><h2 id="第三章-多线程服务器的适用场合与常用编程模型"><a href="#第三章-多线程服务器的适用场合与常用编程模型" class="headerlink" title="第三章 多线程服务器的适用场合与常用编程模型"></a>第三章 多线程服务器的适用场合与常用编程模型</h2><p>单线程服务器常用的编程模型<br><code>non-blocking IO + IO multiplexing</code> 即为<code>Reactor模式</code><br>程序的基本结构是一个事件循环, 以事件驱动和事件回调的方式实现业务逻辑</p><p>本质的缺点<br>要求事件回调函数必须是非阻塞的, 单线程还阻塞 这还怎么玩…<br>对于涉及网络IO的请求响应式协议, 容易割裂业务逻辑, 使其散布于多个回调函数中</p><p>多线程服务器常用编程模型</p><ol><li>每个请求创建一个线程, 使用阻塞式IO操作</li><li>使用线程池, 同样是阻塞式IO操作</li><li>非阻塞IO + IO多路复用 即Java NIO方法</li><li>领导者追随者等高级模式</li></ol><p>推荐的C++多线程服务器端编程模式为 one (event) loop per thread + thread pool<br>一个线程一个事件循环 + 线程池<br>事件循环用作IO多路复用, 配合非阻塞IO和定时器<br>线程池用作计算, 具体可以是任务队列或生产者消费者队列</p><p>必须使用单线程的场合</p><ul><li>程序可能会fork</li><li>限制程序的CPU占用率 一个线程最多占满一个核心</li></ul><p>适用多线程程序的场景</p><ul><li>有多个CPU可用, 单核机器上多线程没有性能优势</li><li>线程间有共享数据, 否则建议使用 主进程+工作进程 每个进程都是单线程的模型</li><li>共享数据是可以修改的. 如果数据不能修改可以进程间使用共享内存</li><li>事件响应有优先级差异, 防止优先级反转</li><li>程序要有相当的计算量</li><li>利用异步操作</li><li>能享受到增加CPU数目带来的好处</li><li>多线程有有效地划分责任与功能</li></ul><p>后面大部分我都是看看就过去了, 自己没有丝毫经验 也不打算现在细看</p><h2 id="第四章-C-多线程系统编程精要"><a href="#第四章-C-多线程系统编程精要" class="headerlink" title="第四章 C++多线程系统编程精要"></a>第四章 C++多线程系统编程精要</h2><p>学习多线程编程面临的最大思维方式转变</p><ul><li>当前进程随时可能被切出去</li><li>多线程程序中事件的发生顺序不再有全局统一的先后关系</li></ul><p>常用的11个pthreads函数</p><ul><li>pthread_create() pthread_join()</li><li>pthread_mutex_(create/destory/lock/unlock)</li><li>pthread_cond_(create/destory/wait/signal/broadcast)</li></ul><p>多线程系统编程的难点不在于学习线程原语, 而在于理解多线程与现有的C/C++库函数和系统调用的交互关系<br>以进一步学习如何设计并实现线程安全且高效的程序</p><p>pthread_t并不适合作为程序中对线程的标识符</p><ul><li>他可能会同一进程的两个线程相同</li><li>或者是不利于打印</li><li>无法判断其是否非法</li><li>文件系统中没有对应项</li><li>脱离进程便没意义</li></ul><p>推荐使用gettid()作为线程标识符</p><ul><li>任何时刻都是全局唯一的</li><li>类型为pid_t通常为一个小整数利于在日志中打印.</li><li>0就是非法值1, 因为操作系统第一个进程init的pid是1</li><li>在现代Linux中, 他直接表示内核的任务调度id, 容易在/proc文件系统中找到对应项</li><li>在其他系统工具中也容易定位到某一个具体线程, 列如使用top按线程列出任务,<br>便可以找到线程id, 再根据程序日志判断是哪一个具体线程</li></ul><pre><code class="c++">// .hextern __thread int t_cachedTid;void cacheTid();inline int tid(){    if (__builtin_expect(t_cachedTid == 0, 0))    {        cacheTid();    }    return t_cachedTid;}// .cpp__thread int t_cachedTid = 0;void CurrentThread::cacheTid(){    if (t_cachedTid == 0)    {        t_cachedTid = gettid();    }}// .cpppid_t gettid(){    return static_cast&lt;pid_t&gt;(::syscall(SYS_gettid));}</code></pre><p><strong>thread<br>只能修饰POD类型, 不能修饰class类型, 因为无法自动调用构造析构函数. 可以用于修饰全局变量函数内的静态变量.是GCC内置的线程局部存储设施，存取效率可以和全局变量相比。</strong>thread变量每一个线程有一份独立实体，各个线程的值互不干扰.</p><p><strong>builtin_expect<br>这个指令是gcc引入的，作用是允许程序员将最有可能执行的分支告诉编译器。这个指令的写法为：</strong>builtin_expect(EXP, N)。<br>意思是：EXP==N的概率很大. 就图中代码翻译过来就是 <code>t_cachedTid == 0</code>为<code>0(假)</code>, 即为<code>t_cachedTid</code>最可能不是0.</p><ul><li>使用同一个class创建线程, 全局统一. 一般不会为每个网络连接创建线程, 除非并发数与cpu数目相同<br>一个服务程序的线程数目应该与当前负载无关, 而应该有CPU数目有关.</li><li>程序运行期间不要再创建和销毁线程, 最好在初始化的时候创建所有的线程</li></ul><p>线程销毁的方式</p><ul><li>正常死亡, 从线程主函数返回, 线程正常退出</li><li>非正常死亡, 从线程主函数抛出异常或线程触发segfault信号等非法操作</li><li>自杀 调用pthread_exit() 立刻终止线程</li><li>他杀 其他线程调用pthread_cancel() 来强制终止某个线程</li></ul><p>线程只有一种正常死亡方式, 即第一种 其他方法都是错的Java中甚至把相关函数都废弃了</p><p>每个文件描述符只由一个线程操作, 从而解决消息收发的顺序问题, 把一个文件描述符读写分开未必会提高性能. 同时我们不知道epoll_wait阻塞的时候, 其他线程添加新的fd会发生什么. 为了稳妥起见应该把对同一个epollfd的操作放入同一个线程中执行.</p><p><strong>包装文件描述符和连接</strong><br>用Socket对象包装文件描述符<br>所有对此文件描述符的读写操作都通过此对象进行, 对象的析构函数里关闭文件描述符. 这样只要Socket对象还活着 就不会与其他Socket对象有相同的文件描述符, 也就不会发生串话. 包装文件描述符已经见过了, 同样是在flamingo中看到的.</p><p>用Tcpconnection包装连接<br>如果仅仅记住 fd = 8 这样的文件描述符, A线程accept后转身去处理业务B线程把 fd = 8 给关闭了!! 同时accept一个新的fd 同样是8!!. 这时A线程回复就会出现问题. 所以应该持有封装了Socket对象的Tcpconnection, 保证请求处理期间 文件描述符不会被关闭. 或者是持有Tcpconnection的弱引用. 这样就能知道 fd = 8 到底是原来的还是被关闭后新创建的. Tcpconnection对象不能提前销毁, 所以使用了shared_ptr来管理其生存期, 保证不会提前销毁造成串话.</p><h2 id="第五章-高效的多线程日志"><a href="#第五章-高效的多线程日志" class="headerlink" title="第五章 高效的多线程日志"></a>第五章 高效的多线程日志</h2><p>日志库大体分为前端和后端两部分, 两端之间的联系可能简单到只有一个函数<br>大多数感觉都是宏命令</p><p>日志的滚动也很重要 根据文件大小 和 时间 自动创建新的日志文件, 而不是全写入一个文件中</p><p>避免出现正则表达的元字符(列如我最喜欢的<code>&#39;[&#39;和&#39;]&#39;</code>) 便于使用正则表达式查找</p><p>这一章的笔记是在我照着代码实现了简单的相似功能后才写的, 记录一下好的地方<br>大体分为了 LogStream类和Logger类 前者负责通过<code>&lt;&lt;</code>维护LogBuffer缓冲区, 后者做包装提供接口<br>LogBuffer使用了简单的数组作为缓冲区, 使用Append添加内容 维护写指针</p><p>LogStream重载了多种 参数情况, char和char* 很方便写入到缓冲区中<br>数字则需要转化成字符串</p><pre><code class="c++">LogStream&amp; operator&lt;&lt;(short num);LogStream&amp; operator&lt;&lt;(unsigned short num);LogStream&amp; operator&lt;&lt;(int num);LogStream&amp; operator&lt;&lt;(unsigned num);LogStream&amp; operator&lt;&lt;(long num);LogStream&amp; operator&lt;&lt;(unsigned long num);LogStream&amp; operator&lt;&lt;(long long num);LogStream&amp; operator&lt;&lt;(unsigned long long num);LogStream&amp; operator&lt;&lt;(char str);LogStream&amp; operator&lt;&lt;(const char* str);</code></pre><p>转化函数, 不得不说设计的真好. 通过模板解决了多种数字类型</p><pre><code class="c++">const char digits_character[] = &quot;0123456789&quot;;// LEARN https://www.drdobbs.com/flexible-c-1-efficient-integer-to-string/184401596template&lt;typename T&gt;size_t Convert(char buff[], T value){    T i = value;    char* p = buff;    do    {        unsigned lsd = static_cast&lt;unsigned&gt;(i % 10);        i /= 10;        // *p++ = &#39;0&#39; + lsd; 不高效        *p++ = digits_character[lsd];    } while (i != 0);    if (value &lt; 0)    {        *p++ = &#39;-&#39;;    }    *p = &#39;\0&#39;;    // LEARN 原文中是从buff最后一个字节开始写入 但是这里需要从开头写入 所以改为倒置一下    std::reverse(buff, p);    return p - buff;}template&lt;typename T&gt;void LogStream::FormatInteger(T t){    if (buffer_.WriteableBytes() &gt; MAX_NUMBER_SIZE)    {        size_t len = Convert(buffer_.WritePeek(), t);        buffer_.MoveWritePeek(len);    }}</code></pre><p>将格式化也单独出了一个类</p><pre><code class="c++">class Fmt{public:    template&lt;typename T&gt;    Fmt(const char* fmt, T val);    const char* GetData() const    {        return buff_;    }    int GetLength() const    {        return length_;    }private:    char buff_[32];    size_t length_;};template&lt;typename T&gt;Fmt::Fmt(const char* fmt, T val){    static_assert(std::is_arithmetic&lt;T&gt;::value == true, &quot;Must be arithmetic type&quot;);    length_ = snprintf(buff_, sizeof buff_, fmt, val);    assert(length_ &lt; sizeof buff_);}</code></pre><p>Logger类的设计<br>方便了日志的打印, 实现了高效的转换</p><pre><code class="c++">enum LogLevel{    DEBUG,    INFO,    WARN,    ERROR,    FATAL,    NUM_LOG_LEVELS /* 仅用于表示LogLevel元素个数 不做实际使用 */};// LEARN 处处保持长度一致 使用NUM_LOG_LEVELS表示大小const char* LogLevelName[Logger::NUM_LOG_LEVELS] ={    &quot;DEBUG &quot;,    &quot;INFO  &quot;,    &quot;WARN  &quot;,    &quot;ERROR &quot;,    &quot;FATAL &quot;,};</code></pre><p>字符串指针包装类, 减少strlen的调用 或者字符串没有终止</p><pre><code class="c++">// LEARN 临时包装字符串指针和长度class T{public:    T(const char* str, size_t len):    str_(str),    len_(len)    {        assert(strlen(str) == len);    }    const char* str_;    const size_t len_;};</code></pre><p>使用内部类Impl包装了LogStream LogStream负责的是单纯的维护缓冲区 重载各种运算符.<br>Impl的构造函数输出了日志前边的固定部分<br>Logger的构造函数负责根据有无函数名等重载输出额外的固定内容<br>构造和析构之间完成 纯用户自定义部分输出<br>Logger的析构函数负责输出每条日志的结尾部分 文件名和行号</p><pre><code class="c++">class Impl{public:    typedef Logger::LogLevel LogLevel;    Impl(LogLevel level, const SourceFile&amp; file, int line);    void FormatTime();    void Finish();    Timestamp time_;    LogStream stream_;    LogLevel level_;    SourceFile filename_;    int line_;};</code></pre><p>内部类SourceFile负责将<code>__FILE__</code>宏产生的字符数组转换成单纯的文件名. 使用了数组引用</p><pre><code class="c++">class SourceFile{public:    /**        * 数组的引用 使数组在传参时不会降为 指针        */    template&lt;int N&gt;    SourceFile(const char (&amp;arr)[N]):    data_(arr),    size_(N - 1)    {        const char* name = strrchr(data_, &#39;/&#39;); /* /name */        if (name)        {            data_ = name + 1;            size_ -= static_cast&lt;int&gt;(data_ - arr);        }    }    const char* data_;    int size_;};</code></pre><p>其他高效设计</p><pre><code class="c++">// LEARN 缓存上一次输出的秒 同一秒输出时避免多次格式化// 同一秒输出仅仅格式化 微秒部分__thread char t_time[64];__thread time_t t_last_second;</code></pre><h1 id="第二部分-muduo网络库"><a href="#第二部分-muduo网络库" class="headerlink" title="第二部分 muduo网络库"></a>第二部分 muduo网络库</h1><h2 id="第六章-muduo网络库简介"><a href="#第六章-muduo网络库简介" class="headerlink" title="第六章 muduo网络库简介"></a>第六章 muduo网络库简介</h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/ClassDiagram.png" alt=""></p><p>看完前面的一小部分, 我真心觉得这个库跟之前那个flamingo特别像, 估计这种管理方式就是某种主流方式?<br>估计我以后自己写的时候也是会按照这个模式来写了吧</p><p>TCP网络编程最本质的是处理三个半事件</p><ul><li>连接的建立</li><li>连接断开 主动断开close 被动断开 read返回0</li><li>消息到达, 文件描述符可读. 最为重要的一个事件, 对它的处理方式决定了网络编程的风格.(阻塞还是非阻塞, 如何处理分包, 应用层缓冲如何设计)</li><li>消息发送完毕 这算半个</li></ul><p>现在存在的问题</p><ul><li>如果保证发送完应用层缓冲区数据才断开连接<br>自己思考的可以设立标志位, 如果设置了标志位发送完成后检测标志位 关闭连接</li><li>如果要主动发起连接, 但是对方主动拒绝, 如何定期重试<br>按照TCP重试机制 发送SYN 开启定时器 如果定时内没有收到确认ACK则重发SYN</li></ul><p>这里了解到一个词 前向声明,<br>在程序设计中，前向声明（Forward Declaration）是指声明标识符(表示编程的实体，如数据类型、变量、函数)时还没有给出完整的定义。<br>通常为了简化头文件的关系 可以在A的头文件中 声明<code>class B</code>, 这样在你的代码中就可以使用<code>B*</code>而不需要引入B的头文件</p><h2 id="第七章-muduo编程示例"><a href="#第七章-muduo编程示例" class="headerlink" title="第七章 muduo编程示例"></a>第七章 muduo编程示例</h2><p>本章大部分都是实战小例子, 自然要在代码中注释了.<br>博客这里就简单写一写<br><strong>关于<code>input buffer</code>和<code>output buffer</code>已经有所了解过</strong></p><p><code>output buffer</code>在<code>write</code>调用一次没有发送完全的时候起到大用途. 一次没有发送完不应该等待在那里, 应该是接管这些未发送的数据, 阻塞代价是很大的. 应该是注册<code>EPILOUT</code>事件, 直到数据全部发送完毕. 否则就一直注册事件, 当然这是在连接正常的时候.<br>使用<code>output buffer</code>还有一个小问题, 一般情况下一次发送未完成才会使用到<code>output buffer</code>. 当缓冲区中存在数据的时候. 下一次的数据不能进行发送, 而应该是直接追加到尾部.</p><p><code>input buffer</code>某种意义上作用更大, 这涉及到一个重要概念”粘包”的处理. </p><p>这里我了解到了<code>capacity()</code>机制, 可以用来减少内存分配次数. <code>capacity()</code>代表预分配的内存大小,<br>而<code>size()</code>是你写入的数据大小, 当<code>size == capacity</code>的时候<code>再写入内容</code>内存会分配更长的一个数组将旧数据拷贝过去<code>size()</code>依然是你写入的大小, <code>capacity()</code>则会变大</p><pre><code class="c++">std::vector&lt;char&gt; buff(20); // 填充了20个元素 0void Foo(size_t size){    buff.resize(size);    printf(&quot;%ld %ld\n&quot;, buff.size(), buff.capacity());}int main(){    printf(&quot;%ld %ld\n&quot;, buff.size(), buff.capacity()); // 20 20    Foo(512); // 512 512    Foo(1024); // 1024 1024    Foo(1025); // 1025 2048    Foo(2048); // 2048 2048    Foo(2049); // 2049 4096}</code></pre><p>花了小半天时间去了解配置了下 protobuf, 是一把很锋利的剑不错!</p><p>网络编程中使用protobuf的两个先决条件</p><ul><li>长度问题, protobuf打包的数据没有自带长度信息或终结符, 这就需要程序自己在发送和接受的时候做正确的切分</li><li>类型问题, protobuf打包的数据没有自带类型信息, 需要由发送方把类型信息传给接收方, 接收方创建对应的具体protobuf message对象, 再做反序列化</li></ul><p>我第一印象解决上面的方法, 就如书中所言是山寨的做法…. 增加header部分</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%20class.png" alt="Protobuf类图"><span class="img-alt">Protobuf类图</span></p><p>大概意思就是大部分人通过在头部增加代号标识消息类型(具体对应那个message), 而protobuf提供了<br>根据反射 根据typename 选择对应的Message对象的功能, 由于我没有用过protobuf 目前不是很了解 不过大概就这样了, 后续会专门学习 先用即可</p><pre><code class="c++">// eg typename=muduo.Querygoogle::protobuf::Message* ProtobufCodec::createMessage(const std::string&amp; typeName){    google::protobuf::Message* message = nullptr;    const google::protobuf::Descriptor* descriptor =        google::protobuf::DescriptorPool::generated_pool()-&gt;FindMessageTypeByName(typeName);    if (descriptor)    {        const google::protobuf::Message* prototype =            google::protobuf::MessageFactory::generated_factory()-&gt;GetPrototype(descriptor);        if (prototype)        {            message = prototype-&gt;New(); // 返回的是动态创建的指针        }    }    return message;}typedef std::shared_ptr&lt;google::protobuf::Message&gt; MessagePtr;MessagePtr message;message.reset(createMessage(typeName)); // 接管指针</code></pre><p>作者设计的格式如下<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%E4%BC%A0%E8%BE%93%E6%A0%BC%E5%BC%8F.png" alt=""></p><pre><code class="c++">struct Foo{    // int32_t version; 根本不需要版本号    int32_t len; // 没有使用uin32_t 是为了跨语言, Java没有unsigned    int32_t namelen;    char type_name[namelen]; // 以 /0 结尾 方便接收方处理 节省strlen() 空间换时间    char protobuf_data[len-namelen-8]    int32_t checksum; // adler32算法 进行校验}</code></pre><p>终于知道编码器解码器合起来叫什么了… 编解码器(codec)</p><p>后面的一些例子就跳过了, 去准备阅读第八章然后动手写库了 这里才是重点 至于例子当时候自己再写.<br>自己的库不香吗?</p><h2 id="第八章-muduo网路库设计与实现"><a href="#第八章-muduo网路库设计与实现" class="headerlink" title="第八章 muduo网路库设计与实现"></a>第八章 muduo网路库设计与实现</h2><p><del>第八章从第0节开始 一看就是程序员</del></p><p>这段时间我仿照muduo从中抽了部分功能做了自己的mongo库, 然后我将muduo Protobuf作为附属<br>改成了ProtobufServer(包装了TcpServer).</p><p>之后我便重新编写UE4部分的Protobuf收发部分的代码.<br>昨天晚上总算是将UE4打飞机的单机版 成功改造成了联机版. 使用的帧同步<br>服务器稳定性极佳, 而且内存占用很低, 想到了我之前写的Java服务器. 服务器CPU性能占用极少.</p><p>初期设计的时候 单机每秒发送12包, 每包平均0.16kb. 单机每秒就是2kb.  如果有6个客户端<br>服务器算上广播 出站流量 72kb/s</p><p>跑了下iftop看了下基本是这样.<br>12*6 = 72kb/s</p><p>阿里云送的服务器1Mbps, 理论可以支持8个客户端同屏游戏<br>阿里云学生机5Mbps, 理论支持17个客户端同屏游戏</p><p>当然了现在只同步了输入, 不过其他同步内容消耗的流量就很少了.</p><p>服务器程序运行良好, 倒是UE4 偶尔会崩….</p><p>后面慢慢完善打飞机和服务器</p><p>使用框架很简单的就实现了 登录和游玩数据分开 很舒服. 当然了登录目前只是个摆设没有在服务端保存<br>跳过登录依然可以玩, 后面完善db服务器再说</p><h1 id="第三部分-工程实践经验谈"><a href="#第三部分-工程实践经验谈" class="headerlink" title="第三部分 工程实践经验谈"></a>第三部分 工程实践经验谈</h1><h2 id="第九章-分布式-跳过"><a href="#第九章-分布式-跳过" class="headerlink" title="第九章 分布式 跳过"></a>第九章 分布式 跳过</h2><h2 id="第十章-C-编译链接模型精要"><a href="#第十章-C-编译链接模型精要" class="headerlink" title="第十章 C++编译链接模型精要"></a>第十章 C++编译链接模型精要</h2><h2 id="第十二章-C-经验谈"><a href="#第十二章-C-经验谈" class="headerlink" title="第十二章 C++经验谈"></a>第十二章 C++经验谈</h2>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>.*_case</title>
      <link href="/2021/07/CPP-alias/"/>
      <url>/2021/07/CPP-alias/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ModernCpp.md</title>
      <link href="/2021/05/CPP-ModernCpp/"/>
      <url>/2021/05/CPP-ModernCpp/</url>
      
        <content type="html"><![CDATA[<p>本文记录C++相关的内容。</p><p>主要来源各种CPP专栏，公众号等</p><h2 id="POD类型"><a href="#POD类型" class="headerlink" title="POD类型"></a>POD类型</h2><p><a href="https://zh.wikipedia.org/wiki/POD_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)" target="_blank" rel="noopener">POD (程序设计)</a></p><p>包括标量类型和POD类类型</p><p><strong>标量类型</strong></p><ul><li>算数类型<ul><li>整数类型<ul><li>有符号整数类型（signed char, short, int, long）</li><li>无符号整数类型(unsigned char, unsigned short, unsigned int, unsigned long)</li><li>字符类型char（char默认既不是有符号 也不是无符号）和宽字符类型wchar_t</li><li>布尔类型</li></ul></li><li>浮点类型<ul><li>float    double    long double</li></ul></li></ul></li><li>枚举类型</li><li>指针类型<ul><li>void*</li><li>T*</li><li>T(*)(….) T为返回类型</li></ul></li><li>指针到成员类型<ul><li>指针到非静态成员变量</li><li>指针到非静态成员函数</li></ul></li></ul><p><strong>POD类类型</strong></p><p>无用户定义的构造    析构    拷贝    赋值运算符。</p><p>无继承关系（无基类）</p><p>无虚函数（没有虚表）</p><h2 id="左值-右值"><a href="#左值-右值" class="headerlink" title="左值 右值"></a>左值 右值</h2><p><a href="https://en.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">Value categories</a></p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/modernCpp/valueCategory.png" style="zoom:67%;" /><p>C++中值的类别（value category）如上所示。（值类型 value type 是 int这种）</p><ul><li><p>glvalue（generalized lvalue） 广义左值</p></li><li><p>lvalue 左值</p><p>函数调用时，左值可以绑定到左值引用的参数 <code>T&amp;</code>。</p><p>常量只能绑定到常左值引用<code>const T&amp;</code></p><ul><li>变量，函数或者数据成员的名字</li><li>返回左值引用的表达式。<code>++x</code>，<code>cout &lt;&lt; &#39; &#39;</code></li><li>字符串字面量 <code>&quot;hello world&quot;</code></li></ul></li><li><p>rvalue 右值</p></li><li><p>prvalue （pure rvalue）纯右值</p><p>没有标识符，不可以取地址的表达式，一般称为临时对象</p><p>纯右值可以绑定到常左值引用<code>const T&amp;</code></p><p>将一个纯右值绑定到一个引用上，其生命周期会延长到和这个引用变量一样长。<strong>但是对于xvalue无效（<code>result&amp;&amp; r = std::move</code>），这样会出现BUG</strong></p><ul><li>返回非引用类型的表达式 <code>x++</code>, <code>make_shared&lt;int&gt;(42)</code></li><li>字符串字面值以外的字面量 <code>42</code> <code>true</code></li></ul></li><li><p>xvalue （expiring lvalue）将亡值</p><p>代表其资源能够被重新使用的范左值</p><ul><li>返回类型为对象的右值引用的函数调用或重载运算符表达式 std::move(ptr1)  右值引用有标识符 <strong>虽然有标识符但仍然不能取地址</strong></li></ul></li></ul><p>应该将一个移动构造函数实现为<code>noexcept</code> 不然抛出异常后，正在构造的新对象和交出资源的旧对象都可能出现了问题。导致<strong>非异常安全</strong></p><p><strong>临时对象</strong>会在包含其的表达式求职完成后按照生成顺序的逆序销毁（不包括生命周期延长的情况）</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>string类一般不被认为是容易的原因：容器类可以存储任意类型的对象。</p><p>当移动构造函数被标记为noexcept的时候，vector扩容的时候会使用移动。而如果没有标记为noexcept的时候则会使用拷贝构造</p><pre><code class="c++">void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {        // move_if_noexcept [_First, _Last) to raw _Dest, using allocator        _Umove_if_noexcept1(_First, _Last, _Dest,            bool_constant&lt;disjunction_v&lt;is_nothrow_move_constructible&lt;_Ty&gt;, negation&lt;is_copy_constructible&lt;_Ty&gt;&gt;&gt;&gt;{});    }// _Umove_if_noexcept1存在两个版本void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, false_type);_Uninitialized_copy();void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type);_Uninitialized_move();</code></pre><p>关联容器中的键需要满足严格的弱序关系</p><ol><li>如果a&lt;=b 也可以得到 b&lt;=a 两个比较值不能够同时严格弱序于对方</li><li>但是如果 a&lt;b 则没有上面的问题</li></ol><p>相对于传统数组，array在传递参数的时候不会发生退化现象。</p><p>相对于vector，array是在栈上分配空间</p><h3 id="定制map和set"><a href="#定制map和set" class="headerlink" title="定制map和set"></a>定制map和set</h3><p>set和map需要特化hash模板 以及 实现 equal判断</p><p>unordered_set和unordered_map 需要严格弱序的 less</p><pre><code class="C++">class Foo{public:    Foo(int val):        val_(val)    {    }    bool operator&lt;(const Foo&amp; other) const // 有序的容器都是用严格的弱序关系    {        return val_ &lt; other.val_;    }    bool operator==(const Foo&amp; other) const // 使用哈希表的还需要一个额外的equal    {        return val_ == other.val_;    }    int GetVal() const    {        return val_;    }private:    int val_;};template&lt;&gt;struct std::hash&lt;Foo&gt; // 模板特化{public:    size_t operator()(const Foo&amp; foo) const noexcept    {        std::hash&lt;int&gt; hash_f;        return hash_f(foo.GetVal());    }};int main(){    std::set&lt;Foo, std::less&lt;Foo&gt;&gt; foo_set;    std::unordered_set&lt;Foo, std::hash&lt;Foo&gt;, std::equal_to&lt;Foo&gt;&gt; foo_unoreder_set;    foo_set.insert(Foo{1});    std::find(foo_set.begin(), foo_set.end(), Foo{1});    foo_unoreder_set.insert(Foo{1});    std::find(foo_unoreder_set.begin(), foo_unoreder_set.end(), Foo{ 1 });}</code></pre>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sed&amp;awk&amp;grep</title>
      <link href="/2021/05/Linux-sed&amp;awk&amp;grep/"/>
      <url>/2021/05/Linux-sed&amp;awk&amp;grep/</url>
      
        <content type="html"><![CDATA[<h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td>(?=pattern)</td><td>正向肯定预查  常用于匹配到pattern 不包括pattern</td></tr><tr><td>(?&lt;=pattern)</td><td>反向肯定预查 常用于从pattern之后匹配 不包括pattern</td></tr></tbody></table><pre><code class="shell">[root@fish ~]# cpu=&quot;Intel(R) Celeron(R) CPU  J1900  @ 1.99GHz&quot;[root@fish ~]# echo $cpuIntel(R) Celeron(R) CPU J1900 @ 1.99GHz[root@fish ~]# echo $cpu | grep -Po &#39;.*(?&lt;=CPU)&#39;Intel(R) Celeron(R) CPU # 包括CPU[root@fish ~]# echo $cpu | grep -Po &#39;(?&lt;=CPU).*&#39; J1900 @ 1.99GHz # 不包括CPU[root@fish ~]# echo $cpu | grep -Po &#39;.*(?=CPU)&#39;Intel(R) Celeron(R) # 不包括CPU[root@fish ~]# echo $cpu | grep -Po &#39;(?=CPU).*&#39;CPU J1900 @ 1.99GHz  # 包括CPU</code></pre><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>grep我之前只是用来匹配结果中的行，也可以通过正则表达式匹配更加具体的内容</p><h2 id="匹配行常用命令"><a href="#匹配行常用命令" class="headerlink" title="匹配行常用命令"></a>匹配行常用命令</h2><table><thead><tr><th>命令参数</th><th>含义</th></tr></thead><tbody><tr><td>-o, –only-matching</td><td>只打印匹配的非空内容（默认显示带匹配内容的行）</td></tr><tr><td>-v</td><td>不显示匹配的内容</td></tr></tbody></table><h2 id="正则-1"><a href="#正则-1" class="headerlink" title="正则"></a>正则</h2><p>grep支持三种不同版本的正则表达式</p><p><strong>basic(BRE)</strong></p><p><strong>extended(ERE)</strong></p><p><strong>perl(PCRE)</strong></p><p>在GUN实现中前两种相同，而其他版本中basic要轻量一些</p><p>而常用的断言匹配则在perl实现中可以使用</p><h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>awk会针对每一行数据运行脚本命令  脚本格式一般为<code>&#39;{command}&#39;</code></p><p>通过<code>-F</code>命令可以指定分隔符 默认为任意空白字符 制表符或者空格</p><p>之后awk每次读取一行数据，使用分隔符对其进行分割。</p><p>$0整行数据</p><p>$1第一个字段</p><p>$2第二个字段</p><p>$n第n个字段</p><p>awk还可以指定<code>BEGIN</code>和<code>END</code>脚本。 在运行命令开始前执行BEGIN脚本运行结束后执行END脚本</p><p><code>awk &#39;BEGIN{}{}END{}&#39;</code></p><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>流式文本处理</p><p>s替换命令 使用e和分号指定多个替换</p><pre><code>[root@fish ~]# echo &quot;This is a test&quot; | sed &#39;s/test/big test/&#39;This is a big test[root@fish ~]# echo &quot;This is a test&quot; | sed -e &#39;s/test/big test/;s/a/aa/&#39;This is aa big test</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码整洁之道</title>
      <link href="/2021/04/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95131-%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
      <url>/2021/04/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95131-%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-有意义的命名"><a href="#第二章-有意义的命名" class="headerlink" title="第二章 有意义的命名"></a>第二章 有意义的命名</h1><p>若变量或代码可能在代码中多次被使用，应赋予其便于检索的名称</p><ol><li><p>类名应该是名词或者名词短语不应该是动词，Customer、WikiPage、Account。避免使用Manager、Processor、Data或者Info这样的类名。</p></li><li><p>方法名应该是动词或者动词短语</p></li><li><p>不要抖机灵，使用whack（美国俚语，劈砍）代替kill言到意到 意到言到</p></li><li><p>每个概念对应一个词，DeviceManager和ProtocolController之间有什么区别？为什么不全用Manager或Controller</p></li><li><p>不要使用双关语，同一个方法命名即使在不同的类中应有相同的含义。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP详解</title>
      <link href="/2021/04/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95160-TCPIP%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/04/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95160-TCPIP%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-Internet协议"><a href="#第五章-Internet协议" class="headerlink" title="第五章 Internet协议"></a>第五章 Internet协议</h1><p>ip提供了一种尽力而为、无连接的数据包交付服务。每个数据报独立于其他数据报被处理。</p><p>ipv6头部长度固定为40字节，在头部中没有可选的flag，ipv6和ipv4中只有起始4bit是相同含义 版本号。同时ipv6头部没有校验和字段，虽然ipv6头部错误会导致错误的交付，但是目前的环境下，几乎不会发生位错误，所以将校验的任务交给了上层协议。</p><h1 id="第十二章-TCP：传输控制协议（初步）"><a href="#第十二章-TCP：传输控制协议（初步）" class="headerlink" title="第十二章 TCP：传输控制协议（初步）"></a>第十二章 TCP：传输控制协议（初步）</h1><p><strong>ARQ和重传</strong></p><p>直接处理分组丢失或者比特查错的方法：一直重发直到本分组被正常接收</p><ul><li>接收方是否接收到了分组？</li><li>接收方接收到的是不是和发送方发送的一样？</li></ul><p>ACK</p><ul><li>发送方应该等待一个ACK多长时间？</li><li>ACK丢失了怎么办？</li><li>分组被接收到了，但是有错怎么办？</li></ul><p>允许多个分组同时进入网络而不是发送一次确认一次存在的问题</p><ul><li>什么时候注入一个分组？</li><li>注入多少个分组？</li><li>等待ACK的时候如何维持计数器？保存未被确认的分组防止重传</li><li>需要能够区分出哪些分组收到了哪些没有收到，而且能够组装乱序的分组</li><li>如果接收方的接收速度慢怎么办？</li></ul><p><strong>滑动窗口 解决了上面的问题</strong></p><p>发送方</p><ul><li>记录着哪些分组可以被释放</li><li>哪些分组已经发送正在等待ACK</li><li>哪些分组还待发送</li></ul><p>接收方</p><ul><li>哪些分组已经被接收和确认</li><li>哪些分组是下一步期待的</li></ul><p><strong>变量窗口：流量控制和拥塞控制 解决了窗口大小确定和接收方接收不过来的问题</strong></p><p><code>流量控制</code> 接收方跟不上的时候通过此迫使发送方慢下来</p><p><code>窗口通告（窗口更新）</code>：跟ACK在一次 调整窗口大小</p><p><code>拥塞控制</code>：流量控制应对的是接收端和发送端问题，拥塞控制则是之间的网络问题</p><p>TCP不会自动插入记录标志或者消息边界，不会解读字节流中的内容，对于内容的解读交给了端点的应用程序。</p><p>TCP的包头没有包长度字段，而UDP却有</p><p>SYN会消耗一个序列号 尽管没有包体 由于消耗了序列号，丢失会被重传</p><p>ACK则不会消耗序列号</p><p><strong>TCP可以被描述为带累计正向确认的滑动窗口协议</strong></p><p>源端口 目的端口 源IP 目的IP唯一的标识了一条连接。（相对传统使用UID来标识的协议，这里使用了四个字段才进行标识）</p><h1 id="第十三章-TCP连接管理"><a href="#第十三章-TCP连接管理" class="headerlink" title="第十三章 TCP连接管理"></a>第十三章 TCP连接管理</h1><p>三次握手不仅让通信双方了解到了</p><ul><li>一个连接正在建立</li><li>利用数据包的选项传递特殊的信息</li><li>交换初始序列号，端口号</li></ul><p>第三次握手丢失后</p><p>被动连接方在超时后会重发SYN+ACK，如果超过指定次数没有回应 则关闭连接</p><p>主动连接方connect会在第二次握手成功后状态就转变为established，这时如果向被动连接方发送数据会导致RST</p><p>四次挥手连接关闭</p><ul><li>主动关闭方，希望对方看到自己当前的seq，以及FIN包还会包含对对方最近一次数据的ACK</li><li>被动方的上层应用程序会被告知连接另一端提出了关闭连接的请求。</li><li>如果FIN丢失，发送方会重新传输直到收到确认的ACK</li></ul><p>shutdown和close的区别</p><ul><li>close会立刻关闭此文件描述符， 无法再读写文件描述符</li><li>shutdown还能根据传入的参数，一般是关闭写，这样还能继续读取残留的数据。</li><li>多进程共享文件描述符的时候，close只会影响本进程，而shutdown会影响全部进程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核设计精髓</title>
      <link href="/2021/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95150-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93/"/>
      <url>/2021/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95150-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93/</url>
      
        <content type="html"><![CDATA[<p>如果你去直接搜索书名的话，应该是搜不到的。这里是两本书《Linux内核设计与实现》和《操作系统-精髓与设计原理》的总结内容😅</p><h1 id="进程线程概念与管理"><a href="#进程线程概念与管理" class="headerlink" title="进程线程概念与管理"></a>进程线程概念与管理</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>进程</strong>：是正在执行的程序代码的事实结果。是程序和相关资源的总称（不只有text代码段，还有诸如打开的文件、内存映射的内存地址空间和全局变量的数据段等等）</p><p><strong>线程</strong>：线程是进程中活动的对象，每个线程都有独立的计数器、进程栈和一组进程寄存器。而在Linux中线程是一种特殊的进程。</p><p><strong>进程描述符</strong>： 进程的列表被存放在任务队列中（一个双向循环链表，节点是<code>struct task_struct</code>其中包含一个进程的所有信息）。其中包含着诸如<code>打开的文件</code>、<code>进程的地址空间</code>、<code>挂起的信号</code>、<code>进程的状态</code>和其他信息。</p><p>上面的<code>进程描述符结构</code>被包裹在<code>struct thread_info</code>结构体中，这个结构体位于进程内核栈的栈底</p><ul><li><p><strong>pid（进程标识值）</strong>：存放在上面的<code>进程描述符</code>中。由<code>pid</code>最大值限制的进程最大数量是可以调整的，但是这个值越大就代表上面的双向循环链表越长，遍历一圈的时间也就越长 。</p></li><li><p><strong>进程状态</strong></p><ul><li>TASK_RUNNING（运行）</li><li>TASK_INTERRUPTIBLE（可中断）睡眠状态</li><li>TASK_UNINTERRUPTIBLE（不可中断）即使接收到信号也不会被唤醒和准备投入运行</li><li>__TASK_TRACED（被其他进程跟踪，如ptrace gdb）</li><li>__TASK_STOPPED（停止）</li></ul></li><li><p><strong>进程上下文</strong>：当程序调用了系统调用或者触发异常就陷入了内核空间 </p></li><li><p><strong>进程家族树</strong>：所有的进程都是PID为1的init进程后代。每个进程都有<code>parent</code>指针指向父进程的<code>task_struct</code>和一个叫做<code>children</code>的子进程链表<em>所以Linux中可以通过一个进程遍历到所有其他进程</em></p></li></ul><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96.png" style="zoom: 67%;" /><p>用户级线程的优点</p><ul><li>线程切换不需要内核态的权限，避免了两次状态转换。</li><li>可以自己定制线程调度算法</li><li>用户级线程可以运行在任何操作系统上</li></ul><p>用户级线程的缺点</p><ul><li>用户级线程一旦阻塞其他同进程的用户级线程也会阻塞</li><li>无法利用系统多处理器的优点</li></ul><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>通过<code>fork系统调用</code>可以拷贝当前进程创建一个子进程，此时父子进程的区别仅仅是PID和PPID和某些资源和统计量。</p><p><strong>写时拷贝</strong>：Linux通过写时拷贝减少或者免除拷贝，<code>fork</code>之后并不是复制所有的进程地址空间，而是使用原来进程的地址空间。只有当需要写入的时候，才会进行拷贝，在此之前是通过只读方式共享。</p><ul><li>当<code>fork之后立即exec</code>的时候就完全没有必要复制父进程的地址空间。</li><li>fork的实际开销就是复制父进程的<code>页表</code>以及创建唯一的<code>进程描述符</code></li></ul><h3 id="fork创建进程"><a href="#fork创建进程" class="headerlink" title="fork创建进程"></a>fork创建进程</h3><pre><code class="c++">pid_t fork(){    clone();}int clone(参数){    do_fork();}UNKNOW do_fork(){    copy_process();    // 唤醒新创建的子进程开始运行}UNKNOW copy_process(){    dup_task_struct(); // 为新进程创建内核栈，thread_info和task_struct结构体。此时父子进程的进程描述符完全相同。    检查是否有空闲的pid来分配    将自已与父进程区别开，进程描述符中的小部分信息被清除，主要是统计信息    子进程被设置为不可中断状态，防止被投入运行    copy_flags(); // 更新flag成员    alloc_pid(); // 为新进程分配pid    根据传递给clone的参数 这里会拷贝或者共享打开的文件，文件系统信息，信号处理函数，进程地址空间等等         一般同一进程的线程会共享这些内容，而不同的进程之前则是不同的需要拷贝    return 指向子进程的指针}</code></pre><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>在Linux中可以说没有线程这个独立的概念。有的是创建进程时根据传入clone的参数决定哪些资源共享、哪些资源拷贝。</p><pre><code class="c++">pid_t fork(){    clone(SIGCHLD, 0);}int pthread_create(){    clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);}</code></pre><ul><li>CLONE_VM 父子进程共享地址空间</li><li>CLONE_FS 父子进程共享文件系统信息 </li><li>CLONE_FILES 父子进程共享打开的文件.<strong>如果不指定会进行拷贝使得引用计数+1，而共享的话则不会+1</strong></li><li>CLONE_SIGHAND 父子进程共享信号处理函数和被阻断的信号</li></ul><h3 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h3><p>虽然让人伤感😥，但进程终归要终结的。当一个进程终结的时候，内核必须释放其占有的资源，并将这一不幸通知父进程。</p><p>不管是显示或者隐式调用exit，或者收到不能处理也不能忽视的信号时可能被动终结。最终都会调用<code>do_exit</code>函数</p><pre><code class="c++">UNKNOW do_exit(){    将task_struct中的标志成员设置为PF_EXITING();    del_timer_sync(); // 删除定时器    if (开启记账)    {        进行记账();    }    exit_mm(); // 释放进程占用的mm_struct 如果这个地址空间没有被共享 则彻底释放    sem_exit(); // 取消IPC信号的排队等待    exit_files(); // 递减文件描述符和引用计数    exit_fs(); // 递减文件系统的引用计数    设置task_struct的exit_code成员中的任务退出代码(代码是exit传入的值);    exit_notify(); // 向父进程发送信息，为本进程的子进程寻找养父 然后将自己设置成EXIT_ZOMBIE    schedule(); // 本进程已经终结，调用此函数切换到新的线程。因为EXIT_ZOMBIE的进程永远不会再次被调用，do_exit永远不会返回了😇}</code></pre><p>至此此进程没有了地址空间，仅存的是<code>内核栈</code>、<code>thread_info</code>和<code>task_struct</code>结构。为的是向父进程提供信息，可以通过wait系列函数收回仅存的这些内容</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>从处理器的角度来看，它只是从程序计数器指向的地址中取得指令然后执行，并忠实的执行这些指令。而程序计数器在系统运行过程中，可能时不时地从指向一个进程的代码指向另一个进程的代码，从而实现进程的切换。</p><p>进程必须能够被操作系统跟踪，也就是说，一个进程必须包含一些必要的信息（进程控制块、进程的状态和在内存中的地址），使得操作系统能够感知到进程的存在，从而控制它的执行。</p><p>系统必须设计某种队列暂时执行和暂时无法执行的进程。进程要么因为时间片用完而被中断，然后加入等待队列。要么执行完毕离开系统。或者阻塞等这时候操作系统从队列中找到新的进程来运行。</p><p>PSW（程序状态字）中存在当前执行模式的标记（用户级 内核级）。当出现中断的时候，需要从用户级向内核级切换这时候这个标记就从<code>用户级切换为内核级</code>这样就能够执行内核空间的代码。当从内核返回的时候标记从<code>内核级切换为用户级</code>这样返回用户空间。</p><p><strong>何时进行进程切换</strong>？</p><p>当操作系统从当前运行的进程处得到了控制权的时候。</p><ul><li>中断（时间片用尽会发生时间中断）</li><li>异常</li><li>系统调用（Linux中系统调用就是中断的方式）</li></ul><p><strong>模式切换？</strong></p><p>从用户态临时转向内核态，仅仅是保存和恢复进程上下文。并不会导致当前进程被切换</p><p><strong>进程切换步骤</strong></p><ol><li>保存当前进程上下文（程序计数器和其他寄存器）</li><li>改变当前进程的进程控制块内容（进程状态变更）</li><li>将当前进程控制块移动到其他队列（就绪队列，<strong>某个事件</strong>的阻塞队列等）</li><li>选择一个合适的进程</li><li>更新被选择进程的进程控制块（设置为运行态）</li></ol><p>Linux提供了<code>抢占式的任务调度</code>和<code>实时的任务调度</code>策略</p><p>主动让出  <code>VER1.0</code>  <code>EX协程</code></p><ul><li><p>抢占式调度器</p><ul><li>时间片耗尽或者执行完毕让出<code>VER2.0</code></li><li>O（1）对于交互式进程很不友好 <code>VER3.0</code></li><li>完全平衡调度算法，简称CFS <code>VER4.0</code></li></ul></li><li><p>实时任务调度器</p></li></ul><p>进程可以分为<code>I/O消耗型</code>和<code>处理器消耗型</code>。GUI程序的交互一般属于前者。这里就存在了两种矛盾</p><ol><li>处理器消耗型 希望使用更大的时间片，减少进程切换多做计算</li><li>GUI等交互程序 希望快速响应，这就意味着需要更小的时间片，保证快速响应</li></ol><p>调度策略在这两个矛盾间寻找平衡点。</p><p>我们希望能够快速的响应交互程序。所以最终将分配时间片改成了分配CPU使用比。加假如系统中仅存两个优先级相同的进程（交互进程和计算进程），那么调度器会给这两个进程各自分配50%的使用占比。然而对于交互进程这些时间远远足够，每次分配后都无法用尽，对于计算进程却能每次用尽分配的占比。这样CFS将会在交互进程需要运行时，毫不犹豫立刻抢占CPU给交互进程（这是因为 CPU承若给他50%的使用，然而他却没有用完。）这样就能使得交互进程快速响应以及计算进程占用更多的CPU。</p><h3 id="Linux调度器"><a href="#Linux调度器" class="headerlink" title="Linux调度器"></a>Linux调度器</h3><p><strong>Linux调度器</strong></p><p>Linux调度器是以模块的方式提供，不同的继承可以选择不同的调度器。这种模块化的结构称为<code>调度器类</code>。每个调度器都有自己的优先级，基础的调度器会按照优先级遍历这些调度器。而每个调度器都会提供经过他自己的算法决定下一个应该运行的进程。</p><p><strong>Linux 调度器入口</strong></p><p>每个调度器有自己的入口函数</p><p>之后<code>schedule</code>函数调用优先级最高的一个调度器，问这个调度器谁是下一个该运行的进程。</p><h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h3><p>为了防止调度器选出一个本不想运行的进程，调度器会从<code>可执行红黑树</code>中寻找下一个该运行的进程</p><p><strong>睡眠</strong></p><p>进程在将自己标记为休眠时，可以从<code>可执行红黑树</code>中将自己移除，放入等待队列。然后通过<code>schedule</code>选出下一个可执行的进程</p><pre><code class="c++">void 睡眠(){    DEFINE_WAIT(); // 在等待队列创建一个位置    add_wait_queue(); // 将自己加入等待队列中    while(条件不满足)    {        prepare_to_wait(); // 将自己变更为TASK_INTERRUPTIBLE或者TASK_UNINTERRUPTIBLE        if (信号到来); // TASK_INTERRUPTIBLE下会被信号唤醒，而不是条件满足        {            处理信号();        }        if (条件满足)        {            break; // 条件满足时退出循环        }        else        {            schedule(); // 让出CPU 睡眠        }    }    将自己变更为TASK_RUNNING;    finish_wait(); // 将自己移出等待队列}</code></pre><p><strong>唤醒</strong></p><p>将自己标记为可执行状态，然后从等待队列移动回<code>可执行红黑树</code></p><pre><code class="c++">void wake_up(){    唤醒等待队列上所有进程;    将进程设置为TASK_RUNNING;    将自己放入红黑树;}</code></pre><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E4%BC%91%E7%9C%A0%E5%92%8C%E5%94%A4%E9%86%92.png" alt=""></p><h3 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h3><p><strong>上下文切换</strong></p><p>从一个可执行进程切换到另一个可执行进程。通过<code>context_switch</code>负责处理。当进程A被选定要投入运行的时候通过<code>schedule</code>函数就能调用前面的函数，实现上下文切换。</p><pre><code class="c++">void schedule(){    context_switch();}void context_switch(){    switch_mm(); // 将虚拟内存从上一个进程切换到新的进程    switch_to(); // 负责处理器状态的切换。包括保存、恢复进程和栈的信息。}</code></pre><p>内核必须知道什么时候调用<code>schedule</code>。</p><p>当每个进程应该被抢占时，会被设置<code>need_resched</code>标志。这个标志告诉内核有其他进程应该被运行了，要尽快调动调度程序</p><p><strong>用户抢占</strong></p><p>从内核返回用户空间的时候，如果<code>need_resched</code>被设置，将会导致<code>schedule</code>被调用 内核会选取一个更加合适的进程投入运行</p><p>用户抢占的发生时机</p><ul><li>从系统调用返回用户空间</li><li>从中断处理程序返回用户空间</li></ul><p><strong>内核抢占</strong></p><p>当从中断返回的时候如果当前没有持有锁（通过thread_info中的preempt_count计数器，加锁时+1，解锁时-1 为0时说明没有锁），而且<code>need_resched</code>被设置说明存在更加需要执行的进程可以被安全抢占</p><p>如果内核中的进程被阻塞了，或者显示调用了<code>schedule</code>内核抢占就会显示的发生（<em>根本不需要额外的逻辑保证可以安全的抢占，因为如果代码显示的调用了schedule说明他清楚自己是可以安全的被抢占的</em>）</p><h3 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h3><p><strong>SCHED_FIFO</strong></p><p>不使用时间片，处于此状态的进程会比任何<code>SCHED_NORMAL</code>级的进程都先得到调度。他会一直执行下去直到自己受到阻塞或者主动让出，如果存在多个此策略的进程则会轮流执行。</p><p><strong>SCHED_RR</strong></p><p>带时间片的<code>SCHED_FIFO</code></p><h3 id="绑定处理器内核和主动让出"><a href="#绑定处理器内核和主动让出" class="headerlink" title="绑定处理器内核和主动让出"></a>绑定处理器内核和主动让出</h3><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>先来先服务（FCFS）</p><p>最短进程优先（SPN）</p><p>最短剩余时间优先（SRT）</p><p>时间片轮换法(以此为基础的升级版 动态时间片)</p><p>CFS（公平调度）</p><p><strong>sched_setaffinity</strong></p><p><strong>sched_getaffinity</strong></p><p><strong>sched_yield 主动让出</strong></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E4%B8%8E%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt=""></p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>在单一处理器的时候，只有在中断发生的时候，或者内核明确地提出重新调度、执行另外一个任务的时候，才会出现数据的并发访问。</p><p><strong>竞争条件和同步</strong></p><p>如果两个执行线程在同一个临界区中执行，而且会因为执行顺序的不同影响最终结果，这就是程序存在的BUG。将这种情况称为<code>竞争条件</code>。这种条件出现的可能很低，所以非常难于排查。避免并发和防止竞争条件称为<code>同步</code>。</p><p>需要辨认出真正需要共享的资源和相应的临界区，才是难的地方</p><p><strong>进程交互的三种类型</strong></p><ul><li>无交互 存在对系统资源的竞争<ul><li>竞争可能导致饥饿</li><li>竞争可能导致死锁</li></ul></li><li>间接交互 知道其他进程的存在，但是不和其直接交互。存在共享协作要求</li><li>直接交互 知道其他进程的存在，通过PID直接进行交互。同样存在通信协作要求</li></ul><p><strong>造成并发执行的原因</strong></p><ul><li>中断 （几乎能在任意时刻发生，然后就会打断当前执行的代码）</li><li>软中断和tasklet</li><li>内核抢占</li><li>睡眠以及用户空间的同步</li></ul><p><strong>锁</strong></p><p>锁的使用是程序员自愿的，并不是系统强制的，是程序员可以选择的手段。</p><p>锁是采用原子操作实现的</p><p><strong>锁之间的区别</strong></p><p>当锁已经其他线程获取后导致的不可用时的行为表现。</p><ul><li>有的锁在争用时简单的忙等待。（自旋锁）</li><li>有的锁则会睡眠直到锁可用。（读写锁 信号量 互斥体 条件变量 这四个的具体行为各不相同）</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>自死锁 当一个线程尝试去获取已经持有的锁的时候</li><li>ABBA死锁  线程1拿着A锁获取B锁 线程2拿着B锁获取A锁</li><li>除了资源争用还有互相等待消息也会导致死锁（B等待A的消息，但是A的消息丢失或者没有发送）</li></ul><p>死锁解决办法</p><ul><li>按顺序加锁</li><li>防止发生饥饿</li><li>不要重复请求一个锁</li><li>设计应该力求简单</li></ul><p><strong>死锁的解决</strong></p><ul><li><p>使用相同的顺序锁定两个互斥元，可以使用<code>std::lock</code>同时锁定所有需要的互斥元</p></li><li><p>持有锁的时候尽量不要调用其他部分的函数，防止其他函数中也存在锁相关内容</p></li><li><p>使用层次锁</p></li></ul><ul><li>死锁预防<ul><li>一次性申请所有资源（解决占有且等待）<ul><li>未得到资源的可能需要长时间等待，已得到资源的则会长时间不使用</li><li>可能不能明确知道需要分配多少资源</li></ul></li><li>抢占 （解决不可剥夺）<em>内存可以采用此方案， 因为可以将内存数据保存到硬盘中</em><ul><li>进程占有资源后，在后续执行中申请所有需要的资源，资源得不到满足的情况下释放已经占有的资源</li><li>通过进程优先级决定高优先级进程可以抢占低优先级进程资源</li></ul></li><li>资源有序分配  （解决循环等待）<ul><li>有序资源分配，对资源进行编码申请编码R资源后，后续申请只能申请编码大于R的资源</li></ul></li></ul></li><li>死锁避免<ul><li>拒绝创建进程，所有进程需要的资源总量小于可使用的资源总量</li><li>拒绝分配资源（银行家算法）使得系统一直在稳定状态</li></ul></li><li>死锁检测<ul><li>周期性检查（将现有的剩余资源进行分配，如果某个进程拿到了所有需要的资源则结束并返回所有占有的资源，当能够结束的进程都结束后依然存在进程无法得到足够的资源说明剩余进程之间存在死锁）</li></ul></li></ul><p>死锁预防</p><ul><li>优点<ul><li>排除了出现死锁的可能</li></ul></li><li>缺点<ul><li>资源使用率低</li></ul></li></ul><p>死锁避免</p><ul><li>优点<ul><li>相对于死锁检测，不需要抢占资源或者回滚进程</li><li>相对于死锁预防更加灵活</li><li>虽然可能出现死锁，但是尽力不让死锁出现</li></ul></li><li>缺点<ul><li>需要知道进程的最大资源使用</li><li>进程之间是独立的</li><li>可分配资源数是固定的</li><li>进程结束必须释放所有资源</li></ul></li></ul><p>死锁检测</p><p><strong>原子性和顺序性</strong></p><p>前者通过原子操作实现，后者通过屏障实现。</p><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><h3 id="Linux提供的锁"><a href="#Linux提供的锁" class="headerlink" title="Linux提供的锁"></a>Linux提供的锁</h3><p><strong>自旋锁</strong></p><ul><li>短时间锁定的锁</li></ul><p><strong>信号量</strong></p><ul><li>用于长时间被锁定的锁</li><li>锁的时间较短的话，可能会导致因为睡眠锁导致的用户态到内核态的切换和内核态到用户态的切换，以及相关队列的维护是得不偿失的</li></ul><h3 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h3><p><strong>生产者</strong></p><p>在生产的时候不仅需要写缓冲区，还要读缓冲区确认缓冲区状态和将要写的位置。</p><p><strong>消费者</strong></p><p>不仅需要读缓冲区，还需要将已读的从缓冲区移出</p><p>PV操作 通过计数值作为资源的数量</p><p>条件变量 生产后signal消费者</p><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>读者优先</p><p>写者优先</p><p>读写锁</p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><p><strong>中间件</strong>： 在上层应用程序和下层的通信软件及操作系统之间使用标准的编程接口和协议。这种标准化的接口和协议称为中间件</p><p>中间件的基本目的：使得位于客户端的应用程序或用户能够访问服务器上的各种服务，而无需考虑服务器之间的差距。</p><p>现在存在两种不同的数据库，有一个程序想要从两个数据库中读取数据。如果通过中间件，程序不需要考虑两个数据库之间的差异，而是直接根据标准读取即可</p><p>可以通过添加一个中间层解决大多数问题。</p><p><strong>分布式消息传递</strong></p><ul><li>使用消息</li><li>以消息为基础，称为远程过程调用</li></ul><h1 id="内存管理和虚拟内存"><a href="#内存管理和虚拟内存" class="headerlink" title="内存管理和虚拟内存"></a>内存管理和虚拟内存</h1><p>内存保护需要通过硬件方式实现，因为操作系统无法预测程序所有的内存访问。</p><p>分页使用拼接的方式 得到真实物理地址 因为每个页面大小相同</p><p>分段则使用相加的方式 因为每个段的大小不同</p><p>换出一块将要被使用的内存块，内存块马上又要被使用将会导致频繁的换出和换入造成抖动</p><p>页表（分页式和段页式）段表（段式）的表中 每条项目存在P（存在标记）M（修改标记）</p><p>减少页的大小</p><ul><li>页内碎片减少</li><li>进程使用的页的数量增加，页表增大</li><li>页的数量多，每个页面都是最近访问的页面，这样缺页率较低</li></ul><p>增加页的大小</p><ul><li>页的数量小且单个页大，每个页包含的内容将与任何一个最近访问的内容越来越远，局部性原理将会削弱，缺页率会增加</li></ul><p><strong>读取策略</strong></p><p>请求分页：开始执行时会发生大量的缺页中断</p><p>预分页：预先加载一些页</p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>最佳页面置换算法（Opt）</p><p>换出未来不会使用的页面</p><p>最近最少使用（LRU）</p><p>置换出最长时间没有被访问的页面</p><p>先进先出（FIFO）</p><p>时钟策略</p><p>第一次被加载到内存时的使用为是1，当需要置换的时候指针扫描一圈，如果遇到使用位是1的将其变为0，遇到是0的则选中这个页面进行置换</p><p>增加了修改位后的时钟策略</p><p>首先选取未被使用未被修改的作为置换页（扫描过程不修改使用位）</p><p>其次选取未被使用但修改过的作为置换页（扫描过程会将使用位从1改为0）</p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序员的自我修养</title>
      <link href="/2021/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95140-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
      <url>/2021/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95140-%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
      
        <content type="html"><![CDATA[<p>这是大三下读的第一本书了。这本书在我准备面试之余还能零零碎碎读了一些。目前看了几章来总结一下。</p><p>实体书上面做笔记和翻阅还是挺舒服的，这里总结的话就不按照书中章节顺序了，而是按照自己选择阅读的顺序。</p><h1 id="第一部分-你看程序跑起来了"><a href="#第一部分-你看程序跑起来了" class="headerlink" title="第一部分 - 你看程序跑起来了!!!"></a>第一部分 - 你看程序跑起来了!!!</h1><p><strong>命令行一敲, 回车一按, 一个程序就运行起来了,这之间都做了哪些操作?</strong></p><p>程序<code>.o</code>中有什么？</p><p>程序是如何装入内存的？</p><p>装入内存后如何启动程序?</p><p>启动程序是从main开始的吗?</p><h2 id="程序-o中有什么-程序是如何装入内存的？"><a href="#程序-o中有什么-程序是如何装入内存的？" class="headerlink" title="程序 .o中有什么? 程序是如何装入内存的？"></a>程序 <code>.o</code>中有什么? 程序是如何装入内存的？</h2><p>目前不考虑静态和动态链接库相关的内容.</p><pre><code class="c++">static int static_int1 = 1;static int static_int2;int main(){    const char* str = &quot;Hello World!&quot;;    return 0;}</code></pre><p>上面的一小段代码, 包含了<code>static 已初始化变量</code>, <code>static 未初始化变量</code>, 以及字符串常量<code>str</code>, 一段<code>main函数</code></p><p>然后使用objdump命令查看这个文件, 这个命令可以解析出ELF文件的头部分。</p><p>相关ELF文件的内容这里就不展开说了，ELF文件里面存在头和数据部分，头部分有一张类似下面的表，其中有偏移量等信息指向实际数据部分</p><pre><code class="shell">[root@fish ~] objdump -h g-main  # h表示g-main:     file format elf64-x86-64Sections:Idx Name          Size      VMA               LMA               File off  Algn # Size段的大小 FileOff段的实际数据在段内的偏移  9 .init         0000001b  0000000000400450  0000000000400450  00000450  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE 10 .text         00000175  0000000000400470  0000000000400470  00000470  2**4                  CONTENTS, ALLOC, LOAD, READONLY, CODE 11 .fini         0000000d  00000000004005e8  00000000004005e8  000005e8  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE 12 .rodata       0000001d  00000000004005f8  00000000004005f8  000005f8  2**3                  CONTENTS, ALLOC, LOAD, READONLY, DATA 20 .data         00000008  0000000000601018  0000000000601018  00001018  2**2                  CONTENTS, ALLOC, LOAD, DATA 21 .bss          00000008  0000000000601020  0000000000601020  00001020  2**2                  ALLOC # 没有 CONTENTS ?</code></pre><p>我删除了很多的内容， 只留下了目前我所学到的主要6段。<em>后面内容基本根据这几段来说明</em></p><p>当在shell按下回车后，fork出的子进程去读取这个可执行文件的<code>头</code>的<code>头部</code> 这里面包含着这是个什么样的可执行文件, ELF文件就调用ELF装载程序,<br>sh文件就调用相关的bash来执行.</p><p>装载程序执行解析ELF的操作得到上面的表，然后根据表将实际数据装入虚拟内存</p><p><em>当然虚拟内存也不是立刻就全部装载进去，但为了便于解析这里先不考虑分页相关内容</em></p><p><em>虚拟内存 存在保留段, 是从0x08048000开始的 这样还能够防止 0x0这个地址对指针造成影响</em></p><p>然后从<code>0x08048000</code>开始装载 <code>.init</code>段 然后<code>.text</code>段 再之后<code>.fini</code>段, 之后是<code>.rodata</code> 接着<code>.data</code>和<code>.bss</code>.</p><p><strong>这几段分别是什么?</strong></p><p><code>.init</code> 包含着初始化相关代码 这些代码是自动加进来的 用于程序运行的初始化操作</p><p><code>.text</code> 是我们自己编写的代码</p><p><code>.fini</code> 则是终结相关代码</p><p><code>.rodata</code> 我们看到表中的大小是<code>1d</code> 偏移是<code>000005f8</code> 我们使用hexdump来查看下这块内容</p><pre><code class="shell">[root@fish ~] hexdump -s 0x5f8 -n 0x1d -C g-main # -s 跳过指定字节 -n 显示指定字节 -C 显示对应字符000005f8  01 00 02 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|00000608  48 65 6c 6c 6f 20 57 6f  72 6c 64 21 00           |Hello World!.|00000615</code></pre><p>我们看到了<code>Hello World!\0</code> 这段内容说明这正是全局const变量和字符串常量的内容</p><p><code>.data</code> 可以看到这里存储的是<code>static int static_int1 = 1;</code> 这个带有初始值的static变量</p><pre><code class="shell">[root@fish ~] hexdump -s 0x1018 -n 0x8 -C g-main 00001018  00 00 00 00 01 00 00 00                           |........|00001020</code></pre><p><code>.bss</code> 这段实际上是没有内容的 虽然存在size和off_set 但可以看到他没有<code>CONTENTS</code><br>这里存储的是不带初始值的static变量<code>static int static_int2;</code> 方便进行统一的初始化为0, 同时不占用文件大小.</p><p>这样上面相关的6段就装载完成了, 除此之外还有堆段和栈段, 最终布局如下</p><table><thead><tr><th>内存空间</th></tr></thead><tbody><tr><td>内核占用3-4GB</td></tr><tr><td>栈段 向低地址增长</td></tr><tr><td>?</td></tr><tr><td>堆段 向高地址增长</td></tr><tr><td>.bss</td></tr><tr><td>.data</td></tr><tr><td>.rodata</td></tr><tr><td>.fini</td></tr><tr><td>.text</td></tr><tr><td>.init</td></tr><tr><td>从0x0x08048000开始</td></tr></tbody></table><p>下面是图片对应</p><p><img src="https://img2018.cnblogs.com/blog/1414775/201906/1414775-20190617204757277-275139699.png" alt=""></p><h2 id="装入内存后如何启动程序"><a href="#装入内存后如何启动程序" class="headerlink" title="装入内存后如何启动程序?"></a>装入内存后如何启动程序?</h2><p>装载完毕后会设定相关的内容使程序从<code>.init</code>段开始执行代码</p><h2 id="启动程序是从main开始的吗"><a href="#启动程序是从main开始的吗" class="headerlink" title="启动程序是从main开始的吗?"></a>启动程序是从main开始的吗?</h2><p>到这里应该有个简单的答案了, 不是从这个函数开始.</p><p>在<code>.init</code>段中的初始化代码<code>_start</code>函数(汇编的形式保存在<code>/usr/lib64/crt1.o</code>)首先执行, 程序传入的参数是保存在栈中的</p><p><code>_start</code>函数会调用<code>__libc_start_main</code>, 实现从栈中读取设定环境变量指针,设定argc和argv. 然后调用``/usr/lib64/crtbegin.o`中的代码进行全局初始化比如static变量的设定等</p><p>然后调用main函数</p><p>返回后调用<code>.finit</code>段中的代码进行收尾操作, 其中就调用了``/usr/lib64/crtend.o<code>中的代码进行全局变量的析构之类的收尾工作, 之后调用atexit设定的函数(通过链表链接的多个atexit函数退出时执行), 再之后将main的返回值传给</code>exit`程序退出</p><h2 id="malloc相关实现"><a href="#malloc相关实现" class="headerlink" title="malloc相关实现"></a>malloc相关实现</h2><p>简单来说malloc会在分配小于128KB的空间时在堆段通过<code>brk</code>函数上移<code>esp寄存器</code>中的地址实现堆段的扩大</p><p>如果大于128KB则会在上面彩图中的<code>Memory Mapping Segment段中</code>的<code>anonymous mappings</code>开辟空间, 通过的是<code>mmap</code>函数, <code>mmap</code>函数将分配到的虚拟内存<code>不</code>映射到具体的文件,这样称之为匿名空间,匿名空间则可以作为堆空间使用</p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS的基本流程和原理</title>
      <link href="/2021/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTPS/"/>
      <url>/2021/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-HTTPS/</url>
      
        <content type="html"><![CDATA[<h1 id="对称加密-or-非对称加密"><a href="#对称加密-or-非对称加密" class="headerlink" title="对称加密 or 非对称加密"></a>对称加密 or 非对称加密</h1><p>加密分为对称加密和非对称加密, 对称加密速度快但是涉及到了key的明文传输 非对称加密速度慢但是可以加密内容</p><p>如果仅使用对称加密, 虽然传输过程中数据不会被解密 但是双方在交换密钥的时候 是明文进行交换的</p><p>如果仅使用非对称加密, 虽然安全性好 但是会消耗很多的资源</p><p>所以使用非对称加密来保护<code>对称加密key</code> 后续再使用对称加密进行通信 这样兼顾安全性和效率</p><h1 id="数字证书合法性校验"><a href="#数字证书合法性校验" class="headerlink" title="数字证书合法性校验"></a>数字证书合法性校验</h1><p>通过上面分析知道了会使用非对称加密加密<code>对称加密key</code>, 但是如何防止<code>公钥</code>被掉包? 也就是说如何确认<code>公钥</code>是服务器发送来的而不是中间人发送来的?</p><p><strong>使用数字证书</strong></p><p>服务器向CA申请证书后 得到了一份<code>证书</code>以及CA在hash证书后使用CA私钥对其加密得到的<code>数字签名</code>两个东西组成<code>数字证书</code></p><p>当浏览器得到<code>数字证书</code>后可以从中得到<code>证书</code>和<code>数字签名</code> 使用CA的公钥对数字签名解密得到<code>T1</code>. 然后使用证书中的算法对<code>证书</code>hash得到<code>T2</code> 比较<code>T1</code>和<code>T2</code></p><p>二者相等说明证书可信.</p><p>如果有人篡改了<code>证书</code>, 但是由于没有CA的私钥无法生成加密后的<code>数字签名</code>, 所以浏览器比较的时候<code>T1和T2</code>不相等</p><p>如果掉包整个<code>证书</code>, 由于<code>证书</code>中包含了域名, 直接比对域名就知道有没有被掉包了</p><h1 id="证书有了加密的一些简单细节是什么"><a href="#证书有了加密的一些简单细节是什么" class="headerlink" title="证书有了加密的一些简单细节是什么"></a>证书有了加密的一些简单细节是什么</h1><p>HTTP的默认端口从80改到了443端口 浏览器放服务器发起TCP连接</p><p>浏览器首先生成随机串CLIENT1, 服务器接收到后回复证书和SERVER1, 浏览器验证证书后生成随机串CLIENT2并使用公钥加密, 服务器收到后解密出CLENT2</p><p>然后浏览器和服务器根据上面的三个随机串使用相同的算法生成最终的<code>对称加密key</code>. 后续就可以使用<code>对称机密key</code>来进行加密通信了</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>class struct typename</title>
      <link href="/2021/02/CPP-class%20struct%20typename/"/>
      <url>/2021/02/CPP-class%20struct%20typename/</url>
      
        <content type="html"><![CDATA[<h1 id="class-和-struct的区别"><a href="#class-和-struct的区别" class="headerlink" title="class 和 struct的区别"></a>class 和 struct的区别</h1><ol><li>class默认访问权限是private, struct默认访问权限是public</li><li>class默认private继承, struct默认public继承</li><li>struct在没有构造函数, 可以使用大括号初始化. class则要求全部public下才能大括号初始化</li></ol><pre><code class="c++">#include &lt;cstdio&gt;struct Foo1 {} foo1;class Foo2 {} foo2;struct Foo3 {int a; int b;};class Foo4{int a; int b;};class Foo44{public: int a; int b;};int main(){    printf(&quot;sizeof struct-Foo1: %zu\n&quot;, sizeof foo1); // 1    printf(&quot;sizeof class-Foo2: %zu\n&quot;, sizeof foo2); // 1    Foo3 foo3 = {1, 2};    // Foo4 foo4 = {1, 2}; error: could not convert ‘{1, 2}’ from ‘&lt;brace-enclosed initializer list&gt;’ to ‘Foo4’    Foo44 foo44 = {1, 2};    return 0;}</code></pre><h1 id="typename-class"><a href="#typename-class" class="headerlink" title="typename class"></a>typename class</h1><p><a href="https://stackoverflow.com/questions/2023977/difference-of-keywords-typename-and-class-in-templates" target="_blank" rel="noopener">https://stackoverflow.com/questions/2023977/difference-of-keywords-typename-and-class-in-templates</a></p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer</title>
      <link href="/2021/02/%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/"/>
      <url>/2021/02/%E7%AE%97%E6%B3%95-%E5%89%91%E6%8C%87Offer/</url>
      
        <content type="html"><![CDATA[<h3 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 03. 数组中重复的数字</a></h3><p>Difficulty: <strong>简单</strong></p><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><pre><code>输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 </code></pre><p><strong>限制：</strong></p><p><code>2 &lt;= n &lt;= 100000</code></p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Language: ****</p><pre><code>​</code></pre><h3 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">剑指 Offer 04. 二维数组中的查找</a></h3><p>Difficulty: <strong>中等</strong></p><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p><strong>示例:</strong></p><p>现有矩阵 matrix 如下：</p><pre><code>[  [1,   4,  7, 11, 15],  [2,   5,  8, 12, 19],  [3,   6,  9, 16, 22],  [10, 13, 14, 17, 24],  [18, 21, 23, 26, 30]]</code></pre><p>给定 target = <code>5</code>，返回 <code>true</code>。</p><p>给定 target = <code>20</code>，返回 <code>false</code>。</p><p><strong>限制：</strong></p><p><code>0 &lt;= n &lt;= 1000</code></p><p><code>0 &lt;= m &lt;= 1000</code></p><p><strong>注意：</strong>本题与主站 240 题相同：</p><h4 id="菜鸡第一印象-暴力法"><a href="#菜鸡第一印象-暴力法" class="headerlink" title="菜鸡第一印象-暴力法"></a>菜鸡第一印象-暴力法</h4><p>O(nm)</p><pre><code class="c++">​class Solution {public:    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target)    {        if (matrix.empty() || matrix[0].empty())        {            return false;        }        for (const auto&amp; vec : matrix)        {            if (vec[0] &gt; target)            {                return false;            }            for (const auto&amp; num : vec)            {                if (num == target)                {                    return true;                }                if (num &gt; target)                {                    break;                }            }        }        return false;    }};</code></pre><h4 id="大神点拨-站在右上角看-这个矩阵其实就像是一个BST"><a href="#大神点拨-站在右上角看-这个矩阵其实就像是一个BST" class="headerlink" title="大神点拨-站在右上角看,这个矩阵其实就像是一个BST"></a>大神点拨-站在右上角看,这个矩阵其实就像是一个BST</h4><pre><code class="c++">class Solution {public:    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target)    {        if (matrix.empty() || matrix[0].empty())        {            return false;        }        int row_max = matrix.size();        int column = matrix[0].size() - 1;        int row = 0;        while (row &lt; row_max &amp;&amp; column &gt;= 0)        {            if (matrix[row][column] == target)            {                return true;            }            else if (matrix[row][column] &gt; target)            {                column--;            }            else            {                row++;            }        }        return false;    }};</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>初看题目, 还是没有详细审题漏掉了<code>每一列都按照从上到下递增的顺序排序</code>. 然后按照暴力法做了出来, 看了眼评论第一上面那句话让我翻回去看了下绝了.</p><h3 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">剑指 Offer 05. 替换空格</a></h3><p>Difficulty: <strong>简单</strong></p><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;</code></pre><p><strong>限制：</strong></p><p><code>0 &lt;= s 的长度 &lt;= 10000</code></p><h4 id="Solution-额外字符串reserve版本"><a href="#Solution-额外字符串reserve版本" class="headerlink" title="Solution - 额外字符串reserve版本"></a>Solution - 额外字符串reserve版本</h4><pre><code class="c++">​class Solution {public:    string replaceSpace(string s)    {        string result;        result.reserve(s.size() * 3);        for (char c : s)        {            if (c == &#39; &#39;)            {                result.append(&quot;%20&quot;);            }            else            {                result += c;            }        }        return result;    }};</code></pre><h4 id="Solution-精打细算-resize原地"><a href="#Solution-精打细算-resize原地" class="headerlink" title="Solution - 精打细算 resize原地"></a>Solution - 精打细算 resize原地</h4><pre><code class="c++">class Solution {public:    string replaceSpace(string s)    {        int num = 0;        for (int i = 0; i &lt; s.size(); ++i)        {            if (s[i] == &#39; &#39;)            {                num++;            }        }        s.resize(num * 2 + s.size());        int sub = num * 2 + s.size();        for (int i = s.size() - 1; i &gt;= 0; --i)        {            if (s[i] != &#39; &#39;)            {                sub--;                s[sub] = s[i];            }            else            {                sub -= 3;                s[sub] = &#39;%&#39;;                s[sub + 1] = &#39;2&#39;;                s[sub + 2] = &#39;0&#39;;            }        }        return s;    }};</code></pre><h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 06. 从尾到头打印链表</a></h3><p>Difficulty: <strong>简单</strong></p><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><pre><code>输入：head = [1,3,2]输出：[2,3,1]</code></pre><p><strong>限制：</strong></p><p><code>0 &lt;= 链表长度 &lt;= 10000</code></p><h4 id="Solution-两次遍历"><a href="#Solution-两次遍历" class="headerlink" title="Solution - 两次遍历"></a>Solution - 两次遍历</h4><pre><code class="c++">class Solution {public:    vector&lt;int&gt; reversePrint(ListNode* head)    {        if (!head)        {            return vector&lt;int&gt;();        }        int length = 0;        ListNode* temp = head;        while (temp)        {            length++;            temp = temp-&gt;next;        }        vector&lt;int&gt; result;        result.resize(length);        for (int i = length - 1; i &gt;= 0; --i)        {            result[i] = head-&gt;val;            head = head-&gt;next;        }        return result;    }};</code></pre><h4 id="Solution-递归"><a href="#Solution-递归" class="headerlink" title="Solution - 递归"></a>Solution - 递归</h4><pre><code class="c++">class Solution {public:    vector&lt;int&gt; reversePrint(ListNode* head)    {        vector&lt;int&gt; result;        reversePrint(head, &amp;result);        return result;    }    void reversePrint(ListNode* head, vector&lt;int&gt;* result)    {        if (!head)        {            return;        }        reversePrint(head-&gt;next, result);        result-&gt;push_back(head-&gt;val);    } };</code></pre><h4 id="Solution-栈"><a href="#Solution-栈" class="headerlink" title="Solution - 栈"></a>Solution - 栈</h4><pre><code class="c++">class Solution {public:    vector&lt;int&gt; reversePrint(ListNode* head)    {        stack&lt;ListNode*&gt; sta;        ListNode* temp = head;        while (temp)        {            sta.push(temp);            temp = temp-&gt;next;        }        vector&lt;int&gt; result(sta.size());        int sub = 0;        while (!sta.empty())        {            result[sub++] = sta.top()-&gt;val;            sta.pop();        }        return result;    }};</code></pre><h3 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树</a></h3><p>Difficulty: <strong>中等</strong></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><pre><code>前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]</code></pre><p>返回如下的二叉树：</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 5000</code></p><p><strong>注意</strong>：本题与主站 105 题重复：</p><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder)    {        return buildTree(preorder, inorder, 0, 0, inorder.size());    }    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int pre_l, int in_l, int in_r)    {        if (in_l == in_r)        {            return nullptr;        }        TreeNode* node = new TreeNode(preorder[pre_l]);        for (int i = in_l; i &lt; in_r; ++i)        {            if (inorder[i] == preorder[pre_l])            {                node-&gt;left = buildTree(preorder, inorder, pre_l + 1, in_l, i);                node-&gt;right = buildTree(preorder, inorder, pre_l + 1 + i - in_l, i + 1, in_r);            }        }        return node;    }};</code></pre><h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></h3><p>Difficulty: <strong>简单</strong></p><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p><strong>示例 1：</strong></p><pre><code>输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li></ul><h4 id="Solution-版本1-拷贝多"><a href="#Solution-版本1-拷贝多" class="headerlink" title="Solution - 版本1 拷贝多"></a>Solution - 版本1 拷贝多</h4><pre><code class="c++">class CQueue {public:    CQueue() {    }    void appendTail(int value)    {        while (!core_stack.empty())        {            int temp = core_stack.top();            core_stack.pop();            temp_stack.push(temp);        }        temp_stack.push(value);    }    int deleteHead()    {        while (!temp_stack.empty())        {            int temp = temp_stack.top();            temp_stack.pop();            core_stack.push(temp);        }        int result = -1;        if (!core_stack.empty())        {            result = core_stack.top();            core_stack.pop();        }        return result;    }    stack&lt;int&gt; temp_stack;    stack&lt;int&gt; core_stack;};</code></pre><h4 id="Solution-版本2-减少了拷贝"><a href="#Solution-版本2-减少了拷贝" class="headerlink" title="Solution - 版本2 减少了拷贝"></a>Solution - 版本2 减少了拷贝</h4><pre><code class="c++">​class CQueue {public:    CQueue() {    }    void appendTail(int value)    {        temp_stack.push(value);    }    int deleteHead()    {        int result = -1;        if (!core_stack.empty())        {            result = core_stack.top();            core_stack.pop();        }        else        {            while (!temp_stack.empty())            {                int temp = temp_stack.top();                temp_stack.pop();                core_stack.push(temp);            }            if (!core_stack.empty())            {                result = core_stack.top();                core_stack.pop();            }        }        return result;    }    stack&lt;int&gt; temp_stack;    stack&lt;int&gt; core_stack;};</code></pre><h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 10- I. 斐波那契数列</a></h3><p>Difficulty: <strong>简单</strong></p><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><pre><code>F(0) = 0,   F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</code></pre><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 2输出：1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 5输出：5</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">class Solution {public:    int fib(int n)    {        int arr[max(n + 1, 2)];        arr[0] = 0;        arr[1] = 1;        for (int i = 2; i &lt;= n; ++i)        {            arr[i] = (arr[i - 1] + arr[i - 2]) % 1000000007;        }        return arr[n];    }};</code></pre><h3 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="#剑指-Offer-10-II-青蛙跳台阶问题" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题"></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/" target="_blank" rel="noopener">剑指 Offer 10- II. 青蛙跳台阶问题</a></h3><p>Difficulty: <strong>简单</strong></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code> 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 2输出：2</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 7输出：21</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：n = 0输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul><p>注意：本题与主站 70 题相同：</p><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    int numWays(int n)    {        int dp[max(n + 1, 2)];        dp[0] = 1;        dp[1] = 1;        for (int i = 2; i &lt;= n; ++i)        {            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;        }        return dp[n];    }};</code></pre><h3 id="剑指-Offer-11-旋转数组的最小数字"><a href="#剑指-Offer-11-旋转数组的最小数字" class="headerlink" title="剑指 Offer 11. 旋转数组的最小数字"></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 11. 旋转数组的最小数字</a></h3><p>Difficulty: <strong>简单</strong></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一个旋转，该数组的最小值为1。  </p><p><strong>示例 1：</strong></p><pre><code>输入：[3,4,5,1,2]输出：1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[2,2,2,0,1]输出：0</code></pre><p>注意：本题与主站 154 题相同：</p><h4 id="Solution-暴力法"><a href="#Solution-暴力法" class="headerlink" title="Solution - 暴力法"></a>Solution - 暴力法</h4><pre><code class="c++">class Solution {public:    int minArray(vector&lt;int&gt;&amp; numbers)    {        int result = numbers[0];        for (int i = 0; i &lt; numbers.size() - 1; ++i)        {            if (numbers[i] &gt; numbers[i + 1])            {                result = numbers[i + 1];                break;            }        }        return result;    }};​</code></pre><h4 id="Solution-二分-一个排序好的数组-虽然打乱一次-但仍应该首先考虑二分"><a href="#Solution-二分-一个排序好的数组-虽然打乱一次-但仍应该首先考虑二分" class="headerlink" title="Solution - 二分 (一个排序好的数组, 虽然打乱一次 但仍应该首先考虑二分)"></a>Solution - 二分 (一个排序好的数组, 虽然打乱一次 但仍应该首先考虑二分)</h4><pre><code class="c++">class Solution {public:    int minArray(vector&lt;int&gt;&amp; numbers)    {        int low = 0;        int high = numbers.size() - 1;        while (low &lt; high)        {            int mid = (low + high) / 2;            if (numbers[mid] &gt; numbers[high])            {                low = mid + 1;            }            else if (numbers[mid] &lt; numbers[high])            {                high = mid;            }            else            {                high--;            }        }        return numbers[low];    }};</code></pre><h3 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 12. 矩阵中的路径</a></h3><p>Difficulty: <strong>中等</strong></p><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”<strong>b</strong>“,”c”,”e”],<br>[“s”,”<strong>f</strong>“,”<strong>c</strong>“,”s”],<br>[“a”,”d”,”<strong>e</strong>“,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p><strong>示例 1：</strong></p><pre><code>输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出：true</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;输出：false</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= board.length &lt;= 200</code></li><li><code>1 &lt;= board[i].length &lt;= 200</code></li></ul><p>注意：本题与主站 79 题相同：</p><h4 id="Solution-dfs"><a href="#Solution-dfs" class="headerlink" title="Solution - dfs"></a>Solution - dfs</h4><p>Language: ****</p><pre><code class="c++">​class Solution {public:    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word)    {        for (int i = 0; i &lt; board.size(); ++i)        {            for (int j = 0; j &lt; board[0].size(); ++j)            {                if (word[0] == board[i][j])                {                    if (exist(board, word, i, j, 0))                    {                        return true;                    }                }            }        }        return false;    }    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, const string&amp; word, int x, int y, int sub)    {        if (sub &gt;= word.size())        {            return true;        }        if (x &lt; 0 || y &lt; 0 || x &gt;= board.size() || y &gt;= board[0].size())        {            return false;        }        if (board[x][y] == &#39; &#39;)        {            return false;        }        if (board[x][y] != word[sub])        {            return false;        }        char back = board[x][y];        board[x][y] = &#39; &#39;;        if (exist(board, word, x + 1, y, sub + 1) ||                 exist(board, word, x, y + 1, sub + 1) ||                exist(board, word, x - 1, y, sub + 1) ||                exist(board, word, x, y - 1, sub + 1))        {            return true;        }        board[x][y] = back;        return false;    }};</code></pre><h3 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">剑指 Offer 13. 机器人的运动范围</a></h3><p>Difficulty: <strong>中等</strong></p><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p><strong>示例 1：</strong></p><pre><code>输入：m = 2, n = 3, k = 1输出：3</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：m = 3, n = 1, k = 0输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n,m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= 20</code></li></ul><h4 id="Solution-dfs-1"><a href="#Solution-dfs-1" class="headerlink" title="Solution - dfs"></a>Solution - dfs</h4><pre><code class="c++">​class Solution {public:    bool Check(int x, int y, int k)    {        int temp = 0;        while (x != 0)        {            temp += x % 10;            x /= 10;        }        while (y != 0)        {            temp += y % 10;            y /= 10;        }        return temp &lt;= k;    }    int movingCount(int m, int n, int k)    {        vector&lt;vector&lt;int&gt;&gt; vec(m, vector&lt;int&gt;(n, 0));        return movingCount(vec, 0, 0, k);    }    constexpr static int SS = 4;    int xx[SS] = {1, -1, 0, 0};    int yy[SS] = {0, 0, 1, -1};    int movingCount(vector&lt;vector&lt;int&gt;&gt;&amp; vec, int x, int y, int k)    {        if (!Check(x, y, k))        {            return 0;        }        if (x &lt; 0 || y &lt; 0 || x &gt;= vec.size() || y &gt;= vec[0].size())        {            return 0;        }        if (vec[x][y] == 1)        {            return 0;        }        vec[x][y] = 1;        int result = 1;        for (int i = 0; i &lt; SS; ++i)        {            result += movingCount(vec, x + xx[i], y + yy[i], k);        }        return result;    }};</code></pre><h3 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 14- I. 剪绳子</a></h3><p>Difficulty: <strong>中等</strong></p><p>给你一根长度为 <code>n</code> 的绳子，请把绳子剪成整数长度的 <code>m</code> 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m-1]</code> 。请问 <code>k[0]*k[1]*...*k[m-1]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p><strong>示例 1：</strong></p><pre><code>输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</code></pre><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 58</code></li></ul><p>注意：本题与主站 343 题相同：</p><h4 id="Solution-dp"><a href="#Solution-dp" class="headerlink" title="Solution - dp"></a>Solution - dp</h4><pre><code class="c++">​class Solution{public:    int cuttingRope(int n)    {        int* dp = new int[n + 1]{};        // 初始状态        dp[2] = 1;        // 状态转移方程        for(int i = 3; i &lt; n + 1; i++)        {            for(int j = 2; j &lt; i; j++)            {                dp[i] = max(dp[i], max(j * dp[i-j], j * (i - j)));            }        }        // 返回值        return dp[n];    }};</code></pre><h3 id="剑指-Offer-15-二进制中1的个数"><a href="#剑指-Offer-15-二进制中1的个数" class="headerlink" title="剑指 Offer 15. 二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 15. 二进制中1的个数</a></h3><p>Difficulty: <strong>简单</strong></p><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p><strong>示例 1：</strong></p><pre><code>输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</code></pre><p><strong>提示：</strong></p><ul><li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li></ul><p>注意：本题与主站 191 题相同：</p><h4 id="Solution-右移运算符-循环M次-M为二进制位数和-负数会出错导致死循环"><a href="#Solution-右移运算符-循环M次-M为二进制位数和-负数会出错导致死循环" class="headerlink" title="Solution - 右移运算符 循环M次 M为二进制位数和 负数会出错导致死循环"></a>Solution - 右移运算符 循环M次 M为二进制位数和 负数会出错导致死循环</h4><pre><code class="c++">​class Solution {public:    int hammingWeight(uint32_t n)    {        int result = 0;        while (n != 0)        {            result += n &amp; 1;            n = n &gt;&gt; 1;        }        return result;    }};</code></pre><h4 id="Solution-解决负数的一种方法"><a href="#Solution-解决负数的一种方法" class="headerlink" title="Solution - 解决负数的一种方法"></a>Solution - 解决负数的一种方法</h4><pre><code class="c++">class Solution{public:    int hammingWeight(uint32_t n)    {    }}</code></pre><h4 id="Solution-更加高效的-循环M次-M为二进制1的位数"><a href="#Solution-更加高效的-循环M次-M为二进制1的位数" class="headerlink" title="Solution - 更加高效的 循环M次 M为二进制1的位数"></a>Solution - 更加高效的 循环M次 M为二进制1的位数</h4><pre><code class="c++">class Solution {public:    int hammingWeight(uint32_t n)    {        int result = 0;        while (n != 0)        {            result++;            n &amp;= n - 1;        }        return result;    }};</code></pre><p>把一个整数减去1之后再和原来的整数作<code>&amp;</code>运算, 得到的结果相当于将二进制表示中的最右边一个1变成0</p><h3 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">剑指 Offer 16. 数值的整数次方</a></h3><p>Difficulty: <strong>中等</strong></p><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p><strong>示例 1:</strong></p><pre><code>输入: 2.00000, 10输出: 1024.00000</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: 2.10000, 3输出: 9.26100</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25</code></pre><p><strong>说明:</strong></p><ul><li>-100.0 &lt; <em>x</em> &lt; 100.0</li><li><em>n</em> 是 32 位有符号整数，其数值范围是 [−2<sup>31</sup>, 2<sup>31 </sup>− 1] 。</li></ul><p>注意：本题与主站 50 题相同：</p><h4 id="Solution-快速幂"><a href="#Solution-快速幂" class="headerlink" title="Solution - 快速幂"></a>Solution - 快速幂</h4><pre><code class="c++">​class Solution {public:    double myPow(double x, int n)    {        if (n == 0)        {            return 1;        }        bool flag = true;        if (n &gt; 0)        {            flag = false;            n = -n;        }        double result = x;        vector&lt;double&gt; ex;        while (n &lt; -1)        {            if (n % 2 == -1)            {                ex.push_back(result);            }            result *= result;            n = n / 2;         }        while (!ex.empty())        {            result *= ex.back();            ex.pop_back();        }        if (flag)        {            result = 1 / result;        }        return result;    }};</code></pre><h4 id="Solution-快速幂-减少空间-去除vector"><a href="#Solution-快速幂-减少空间-去除vector" class="headerlink" title="Solution - 快速幂 减少空间 去除vector"></a>Solution - 快速幂 减少空间 去除vector</h4><pre><code class="c++">class Solution {public:    double myPow(double x, int n)    {        if (n == 0)        {            return 1;        }        bool flag = true;        if (n &gt; 0)        {            flag = false;            n = -n;        }        double result = x;        double ex = 1.0;        while (n &lt; -1)        {            if (n % 2 == -1)            {                ex *= result;            }            result *= result;            n = n / 2;         }        result *= ex;        if (flag)        {            result = 1 / result;        }        return result;    }};</code></pre><h3 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 18. 删除链表的节点</a></h3><p>Difficulty: <strong>简单</strong></p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p><strong>注意：</strong>此题对比原题有改动</p><p><strong>示例 1:</strong></p><pre><code>输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</code></pre><p><strong>说明：</strong></p><ul><li>题目保证链表中节点的值互不相同</li><li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li></ul><h4 id="Solution-爆栈Warning"><a href="#Solution-爆栈Warning" class="headerlink" title="Solution 爆栈Warning"></a>Solution 爆栈Warning</h4><pre><code class="c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* deleteNode(ListNode* head, int val)    {        if (!head)        {            return nullptr;        }        if (head-&gt;val == val)        {            return head-&gt;next;        }        head-&gt;next = deleteNode(head-&gt;next, val);        return head;    }};</code></pre><h4 id="Solution-保存last"><a href="#Solution-保存last" class="headerlink" title="Solution - 保存last"></a>Solution - 保存last</h4><pre><code class="c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* deleteNode(ListNode* head, int val)    {        if (!head)        {            return nullptr;        }        if (head-&gt;val == val)        {            return head-&gt;next;        }        ListNode* last = head;        ListNode* temp = head-&gt;next;        while (temp)        {            if (temp-&gt;val == val)            {                last-&gt;next = temp-&gt;next;            }            last = temp;            temp = temp-&gt;next;        }        return head;    }};</code></pre><h3 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 20. 表示数值的字符串</a></h3><p>Difficulty: <strong>中等</strong></p><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p><h4 id="Solution-if-else-我愿称其为最强题目-尝试了N遍才过"><a href="#Solution-if-else-我愿称其为最强题目-尝试了N遍才过" class="headerlink" title="Solution if else - 我愿称其为最强题目 尝试了N遍才过"></a>Solution if else - 我愿称其为最强题目 尝试了N遍才过</h4><pre><code class="c++">​class Solution {public:    bool isNumber(string s)    {        int begin = 0;        int end = s.size();        bool num = false;        // 去除开头结尾空格        while (begin &lt; end &amp;&amp; s[begin] == &#39; &#39;)        {            begin++;        }        while (end &gt; begin &amp;&amp; s[end - 1] == &#39; &#39;)        {            end--;        }        int sub = begin;        // + - 打头直接去掉        if (s[sub] == &#39;+&#39; || s[sub] == &#39;-&#39;)        {            sub++;        }        // 判断+-之后是否有小数点        bool has_point = false;        if (s[sub] == &#39;.&#39;)        {            has_point = true;            sub++;        }        // 正常数字判断        while (sub &lt; end)        {            if (s[sub] == &#39;.&#39;)            {                if (has_point)                {                    return false; // 小数点只能出现一次                }                has_point = true;            }            else if (s[sub] &gt;= &#39;0&#39; &amp;&amp; s[sub] &lt;= &#39;9&#39;)            {                num = true; // 是一个数字            }            else            {                break;            }            sub++;        }        // 科学计数法判断 E或e 不作为第一个或者最后一个字符        if (sub &gt; begin &amp;&amp; sub &lt; end - 1 &amp;&amp; (s[sub] == &#39;e&#39; || s[sub] == &#39;E&#39;))        {            sub++;            // 去掉E e之后紧接着的 +- 必须 +-只有还有数字            if ((s[sub] == &#39;+&#39; || s[sub] == &#39;-&#39;) &amp;&amp; sub &lt; end - 1)            {                sub++;            }            while (sub &lt; end &amp;&amp; s[sub] &gt;= &#39;0&#39; &amp;&amp; s[sub] &lt;= &#39;9&#39;)            {                sub++;            }        }        return num &amp;&amp; sub == end; // 含数字且已经遍历完毕    }};</code></pre><h4 id="Solution-自动状态机"><a href="#Solution-自动状态机" class="headerlink" title="Solution -  自动状态机"></a>Solution -  自动状态机</h4><pre><code class="c++"></code></pre><h3 id="剑指-Offer-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指-Offer-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank" rel="noopener">剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</a></h3><p>Difficulty: <strong>简单</strong></p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p><strong>示例：</strong></p><pre><code>输入：nums = [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。</code></pre><p><strong>提示：</strong></p><ol><li><code>0 &lt;= nums.length &lt;= 50000</code></li><li><code>1 &lt;= nums[i] &lt;= 10000</code></li></ol><h4 id="Solution-代码不简洁版本-双指针"><a href="#Solution-代码不简洁版本-双指针" class="headerlink" title="Solution - 代码不简洁版本 双指针"></a>Solution - 代码不简洁版本 双指针</h4><pre><code class="c++">​class Solution {public:    vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums)    {        if (nums.empty())        {            return nums;        }        int begin = 0;        int end = nums.size() - 1;        while (begin &lt; end)        {            while (nums[end] % 2 == 0)            {                end--;                if (begin &gt; end)                {                    return nums;                }            }            if (nums[begin] % 2 == 0)            {                swap(nums[begin], nums[end--]);            }            else            {                begin++;            }        }        return nums;    }};</code></pre><h4 id="Solution-使用continue简化边界判断-双指针"><a href="#Solution-使用continue简化边界判断-双指针" class="headerlink" title="Solution - 使用continue简化边界判断 双指针"></a>Solution - 使用continue简化边界判断 双指针</h4><pre><code class="c++">class Solution {public:    vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums)    {        int left = 0;         int right = nums.size() - 1;        while (left &lt; right)        {            if ((nums[left] &amp; 1) != 0)            {                left ++;                continue;            }            if ((nums[right] &amp; 1) != 1)            {                right --;                continue;            }            swap(nums[left++], nums[right--]);        }        return nums;    }};</code></pre><h4 id="Solution-快慢指针"><a href="#Solution-快慢指针" class="headerlink" title="Solution - 快慢指针"></a>Solution - 快慢指针</h4><pre><code class="c++">class Solution {public:    vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums)    {        int slow = 0;        int fast = 0;        while (fast &lt; nums.size())        {            if ((nums[fast] &amp; 1) == 0)            {                fast++;                continue;            }            swap(nums[slow++], nums[fast++]);        }        return nums;    }};</code></pre><p>慢指针负责指向偶数, 当快指针寻找到奇数时 进行替换 然后两者都向前移动</p><p>不过这个代码存在原地tp的问题 极端情况下如果全是奇数则会替换size次</p><h3 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 22. 链表中倒数第k个节点</a></h3><p>Difficulty: <strong>简单</strong></p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p><p><strong>示例：</strong></p><pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5.</code></pre><h4 id="Solution-依旧是解决链表问题的通用方法-快慢指针"><a href="#Solution-依旧是解决链表问题的通用方法-快慢指针" class="headerlink" title="Solution - 依旧是解决链表问题的通用方法 快慢指针"></a>Solution - 依旧是解决链表问题的通用方法 快慢指针</h4><pre><code class="c++">​class Solution {public:    ListNode* getKthFromEnd(ListNode* head, int k)    {        if (!head)        {            return nullptr;        }        ListNode* fast = head;        for (int i = 0; i &lt; k; ++i)        {            fast = fast-&gt;next;        }        ListNode* slow = head;        while (fast)        {            slow = slow-&gt;next;            fast = fast-&gt;next;        }        return slow;    }};</code></pre><p>判断链表环依然采用快慢指针, 快指针一次走两步 注意判断两次fast不为nullptr 当fast==low的时候说明有环</p><p>判断环长度, 第一次相遇后 到 第二次相遇 慢指针走的次数即为长度. 快指针在相遇后正好比慢指针多走一圈</p><p>1-&gt;2-&gt;3-&gt;4</p><p>1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>取中间节点 快指针走两步 慢指针走一步 当快指针无法走两步的时候 慢指针所指为中间</p><h3 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 24. 反转链表</a></h3><p>Difficulty: <strong>简单</strong></p><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><strong>示例:</strong></p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 5000</code></p><p><strong>注意</strong>：本题与主站 206 题相同：</p><h4 id="Solution1-代码过长的递归"><a href="#Solution1-代码过长的递归" class="headerlink" title="Solution1 - 代码过长的递归"></a>Solution1 - 代码过长的递归</h4><pre><code class="c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* reverseList(ListNode* head)    {        if (!head)        {            return nullptr;        }        ListNode* new_head = nullptr;        ListNode* front = reverse(head, &amp;new_head);        front-&gt;next = nullptr;        return new_head;    }    ListNode* reverse(ListNode* node, ListNode** head)    {        if (!node)        {            return nullptr;        }        ListNode* front = reverse(node-&gt;next, head);        if (front)        {            front-&gt;next = node;        }        else        {            *head = node;        }        return node;    }};</code></pre><h4 id="Solution2-代码简洁的递归"><a href="#Solution2-代码简洁的递归" class="headerlink" title="Solution2 - 代码简洁的递归"></a>Solution2 - 代码简洁的递归</h4><pre><code class="c++">class Solution {public:    ListNode* reverseList(ListNode* head)    {        if (!head || !head-&gt;next)        {            return head;        }        ListNode* ret = reverseList(head-&gt;next);        head-&gt;next-&gt;next = head;        head-&gt;next = nullptr;        return ret;    }};</code></pre><p>首先S2开头的<code>!head-&gt;next</code>的判断减少了一次了递归 同时也简化了S1中的<code>front</code>的判断 不会有空指针.</p><p>然后S1使用的返回值 返回的下一个节点. 然而实际上下一个节点已经可以通过本节点的<code>next</code>访问 通过<code>next-&gt;next</code>来倒转指向</p><p>这样将返回值省了出来 返回原链表的尾结点 作为新的头结点</p><h4 id="Solution-双指针-又双叒叕"><a href="#Solution-双指针-又双叒叕" class="headerlink" title="Solution - 双指针 又双叒叕"></a>Solution - 双指针 又双叒叕</h4><pre><code class="c++">class Solution {public:    ListNode* reverseList(ListNode* head)    {        if (!head)        {            return nullptr;        }        ListNode* node2 = head-&gt;next;        ListNode* node1 = head;        node1-&gt;next = nullptr;        ListNode* back = nullptr;        while (node2)        {            back = node2-&gt;next;            node2-&gt;next = node1;            node1 = node2;            node2 = back;        }        return node1;    }};</code></pre><h3 id="剑指-Offer-25-合并两个排序的链表"><a href="#剑指-Offer-25-合并两个排序的链表" class="headerlink" title="剑指 Offer 25. 合并两个排序的链表"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank" rel="noopener">剑指 Offer 25. 合并两个排序的链表</a></h3><p>Difficulty: <strong>简单</strong></p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><strong>示例1：</strong></p><pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><p><strong>限制：</strong></p><p><code>0 &lt;= 链表长度 &lt;= 1000</code></p><p>注意：本题与主站 21 题相同：</p><h4 id="Solution-未使用虚拟头结点-代码较长且重复"><a href="#Solution-未使用虚拟头结点-代码较长且重复" class="headerlink" title="Solution - 未使用虚拟头结点 代码较长且重复"></a>Solution - 未使用虚拟头结点 代码较长且重复</h4><pre><code class="c++">class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)    {        if (!l1)        {            return l2;        }        if (!l2)        {            return l1;        }        ListNode* ret = nullptr;        if (l1-&gt;val &lt; l2-&gt;val)        {            ret = l1;            l1 = l1-&gt;next;        }        else        {            ret = l2;            l2 = l2-&gt;next;        }        ListNode* node = ret;        while (l1 || l2)        {            if (!l1)            {                node-&gt;next = l2;                break;            }            if (!l2)            {                node-&gt;next = l1;                break;            }            if (l1-&gt;val &lt; l2-&gt;val)            {                node-&gt;next = l1;                l1 = l1-&gt;next;            }            else            {                node-&gt;next = l2;                l2 = l2-&gt;next;            }            node = node-&gt;next;        }        return ret;    }};</code></pre><h4 id="Solution-使用虚拟头结点-代码大幅简洁-去除了重复片段"><a href="#Solution-使用虚拟头结点-代码大幅简洁-去除了重复片段" class="headerlink" title="Solution - 使用虚拟头结点 代码大幅简洁 去除了重复片段"></a>Solution - 使用虚拟头结点 代码大幅简洁 去除了重复片段</h4><pre><code class="c++">class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)    {        ListNode* dumy = new ListNode(0);        ListNode* node = dumy;        while (l1 || l2)        {            if (!l1)            {                node-&gt;next = l2;                break;            }            if (!l2)            {                node-&gt;next = l1;                break;            }            if (l1-&gt;val &lt; l2-&gt;val)            {                node-&gt;next = l1;                l1 = l1-&gt;next;            }            else            {                node-&gt;next = l2;                l2 = l2-&gt;next;            }            node = node-&gt;next;        }        return dumy-&gt;next;    }};</code></pre><p>使用了虚拟头结点 直接简化了重复片段 tql</p><h3 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener">剑指 Offer 26. 树的子结构</a></h3><p>Difficulty: <strong>中等</strong></p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 A:</p><p><code>3      / \     4   5    / \   1   2</code><br>给定的树 B：</p><p><code>4     /   1</code><br>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><pre><code>输入：A = [1,2,3], B = [3,1]输出：false</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：A = [3,4,5,1,2], B = [4,1]输出：true</code></pre><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 10000</code></p><h4 id="Solution-先序遍历"><a href="#Solution-先序遍历" class="headerlink" title="Solution - 先序遍历"></a>Solution - 先序遍历</h4><pre><code class="c++">​class Solution {public:    bool isSubStructure(TreeNode* A, TreeNode* B)    {        if (!A || !B)        {            return false;        }        if (A-&gt;val == B-&gt;val)        {            if (cmpTree(A, B))            {                return true;            }        }        return isSubStructure(A-&gt;left, B) ||        isSubStructure(A-&gt;right, B);    }    bool cmpTree(TreeNode* A, TreeNode* B)    {        if (!B)        {            return true;        }        if (!A)        {            return false;        }        if (A-&gt;val == B-&gt;val)        {            return cmpTree(A-&gt;left, B-&gt;left) &amp;&amp; cmpTree(A-&gt;right, B-&gt;right);        }        return false;    }};</code></pre><h4 id="Solution-简洁了一些-但我认为一个ifelse比一个函数调用更加高效"><a href="#Solution-简洁了一些-但我认为一个ifelse比一个函数调用更加高效" class="headerlink" title="Solution - 简洁了一些 但我认为一个ifelse比一个函数调用更加高效"></a>Solution - 简洁了一些 但我认为一个ifelse比一个函数调用更加高效</h4><pre><code class="c++">class Solution {public:    bool isSubStructure(TreeNode* A, TreeNode* B)    {        if (!A || !B)        {            return false;        }        return cmpTree(A, B) || isSubStructure(A-&gt;left, B) ||        isSubStructure(A-&gt;right, B);    }    bool cmpTree(TreeNode* A, TreeNode* B)    {        if (!B)        {            return true;        }        if (!A)        {            return false;        }        return (A-&gt;val == B-&gt;val) &amp;&amp; cmpTree(A-&gt;left, B-&gt;left) &amp;&amp; cmpTree(A-&gt;right, B-&gt;right);    }};</code></pre><h3 id="剑指-Offer-27-二叉树的镜像"><a href="#剑指-Offer-27-二叉树的镜像" class="headerlink" title="剑指 Offer 27. 二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">剑指 Offer 27. 二叉树的镜像</a></h3><p>Difficulty: <strong>简单</strong></p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>例如输入：</p><p><code>4     /   \    2     7   / \   / \  1   3 6   9</code><br>镜像输出：</p><p><code>4     /   \    7     2   / \   / \  9   6 3   1</code></p><p><strong>示例 1：</strong></p><pre><code>输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]</code></pre><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 1000</code></p><p>注意：本题与主站 226 题相同：</p><h4 id="Solution-递归-1"><a href="#Solution-递归-1" class="headerlink" title="Solution - 递归"></a>Solution - 递归</h4><pre><code class="c++">​class Solution {public:    TreeNode* mirrorTree(TreeNode* root)    {        if (!root)        {            return nullptr;        }        swap(root-&gt;left, root-&gt;right);        mirrorTree(root-&gt;left);        mirrorTree(root-&gt;right);        return root;    }};</code></pre><h4 id="Solution-迭代"><a href="#Solution-迭代" class="headerlink" title="Solution - 迭代"></a>Solution - 迭代</h4><pre><code class="c++">class Solution {public:    TreeNode* mirrorTree(TreeNode* root)    {        if (!root)        {            return nullptr;        }        deque&lt;TreeNode*&gt; nodes;        nodes.push_back(root);        while (!nodes.empty())        {            TreeNode* node = nodes.front();            nodes.pop_front();            swap(node-&gt;left, node-&gt;right);            if (node-&gt;left)            {                nodes.push_back(node-&gt;left);            }            if (node-&gt;right)            {                nodes.push_back(node-&gt;right);            }        }        return root;    }};</code></pre><h3 id="剑指-Offer-28-对称的二叉树"><a href="#剑指-Offer-28-对称的二叉树" class="headerlink" title="剑指 Offer 28. 对称的二叉树"></a><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 28. 对称的二叉树</a></h3><p>Difficulty: <strong>简单</strong></p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p><code>1     / \    2   2   / \ / \  3  4 4  3</code><br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><p><code>1     / \    2   2     \   \     3    3</code></p><p><strong>示例 1：</strong></p><pre><code>输入：root = [1,2,2,3,4,4,3]输出：true</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [1,2,2,null,3,null,3]输出：false</code></pre><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 1000</code></p><p>注意：本题与主站 101 题相同：</p><h4 id="Solution-递归-2"><a href="#Solution-递归-2" class="headerlink" title="Solution - 递归"></a>Solution - 递归</h4><pre><code class="c++">​class Solution {public:    bool isSymmetric(TreeNode* root)    {        if (!root)        {            return true;        }        return solve(root-&gt;left, root-&gt;right);    }    bool solve(TreeNode* lhs, TreeNode* rhs)    {        if (!lhs &amp;&amp; !rhs)        {            return true;        }        if (!lhs || !rhs)        {            return false;        }        if (lhs-&gt;val == rhs-&gt;val)        {            return solve(lhs-&gt;left, rhs-&gt;right) &amp;&amp; solve(lhs-&gt;right, rhs-&gt;left);        }        return false;    }};</code></pre><h4 id="Solution-迭代-1"><a href="#Solution-迭代-1" class="headerlink" title="Solution - 迭代"></a>Solution - 迭代</h4><pre><code class="c++">class Solution {public:    bool isSymmetric(TreeNode* root)    {        if (!root)        {            return true;        }        list&lt;TreeNode*&gt; nodes;        nodes.push_back(root-&gt;left);        nodes.push_back(root-&gt;right);        while (!nodes.empty())        {            TreeNode* node1 = nodes.front();            nodes.pop_front();            TreeNode* node2 = nodes.front();            nodes.pop_front();            if (!node1 &amp;&amp; !node2)            {                continue;            }            else if (node1 &amp;&amp; node2)            {                if (node1-&gt;val != node2-&gt;val)                {                    return false;                }                nodes.push_back(node1-&gt;left);                nodes.push_back(node2-&gt;right);                nodes.push_back(node1-&gt;right);                nodes.push_back(node2-&gt;left);            }            else            {                return false;            }        }        return true;    }};</code></pre><h3 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">剑指 Offer 29. 顺时针打印矩阵</a></h3><p>Difficulty: <strong>简单</strong></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><strong>示例 1：</strong></p><pre><code>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]</code></pre><p><strong>限制：</strong></p><ul><li><code>0 &lt;= matrix.length &lt;= 100</code></li><li><code>0 &lt;= matrix[i].length &lt;= 100</code></li></ul><p>注意：本题与主站 54 题相同：</p><h4 id="Solution-额外MN空间"><a href="#Solution-额外MN空间" class="headerlink" title="Solution - 额外MN空间"></a>Solution - 额外MN空间</h4><pre><code class="c++">class Solution {public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)    {        if (matrix.empty() || matrix[0].empty())        {            return vector&lt;int&gt;();        }        const int MX = matrix.size();        const int MY = matrix[0].size();        vector&lt;vector&lt;int&gt;&gt; flags(MX, vector&lt;int&gt;(MY, 0));        int x = 0, y = 0;        vector&lt;int&gt; result;        result.reserve(MX * MY);        int xx[] = {0, 1, 0, -1};        int yy[] = {1, 0, -1, 0};        int i = 0;        while (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; MX &amp;&amp; y &lt; MY &amp;&amp; flags[x][y] != 1)        {            for (;x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; MX &amp;&amp; y &lt; MY &amp;&amp; flags[x][y] != 1;                 x += xx[i], y += yy[i])            {                flags[x][y] = 1;                result.push_back(matrix[x][y]);            }            x -= xx[i];            y -= yy[i];            i = (i + 1) % 4;            x += xx[i];            y += yy[i];        }        return result;    }};</code></pre><h4 id="Solution-边界控制-不使用额外空间"><a href="#Solution-边界控制-不使用额外空间" class="headerlink" title="Solution - 边界控制 不使用额外空间"></a>Solution - 边界控制 不使用额外空间</h4><pre><code class="c++">class Solution {public:    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix)    {        if (matrix.empty() || matrix[0].empty())        {            return vector&lt;int&gt;();        }        const int MX = matrix.size();        const int MY = matrix[0].size();        vector&lt;int&gt; result;        result.reserve(MX * MY);        int xx[] = {0, 1, 0, -1};        int yy[] = {1, 0, -1, 0};        // int nn[] = {1, 0, 0, 0};        // int ee[] = {0, -1, 0, 0};        // int ss[] = {0, 0, -1, 0};        // int ww[] = {0, 0, 0, 1};        int i = 0;        int x = 0, y = 0;        int e = MY, s = MX, w = 0, n = 0;        while (x &gt;= n &amp;&amp; y &gt;= w &amp;&amp; x &lt; s &amp;&amp; y &lt; e)        {            for (;x &gt;= n &amp;&amp; y &gt;= w &amp;&amp; x &lt; s &amp;&amp; y &lt; e;                 x += xx[i], y += yy[i])            {                result.push_back(matrix[x][y]);            }            x -= xx[i];            y -= yy[i];            // n += nn[i];            // e += ee[i];            // s += ss[i]; 更短的写法            // w += ww[i];            if (i == 0)            {                n++;            }            else if (i == 1)            {                e--;            }            else if (i == 2)            {                s--;            }            else            {                w++;            }            i = (i + 1) % 4;            x += xx[i];            y += yy[i];        }        return result;    }};</code></pre><h3 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 31. 栈的压入、弹出序列</a></h3><p>Difficulty: <strong>中等</strong></p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。</code></pre><p><strong>提示：</strong></p><ol><li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li><li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li><li><code>pushed</code> 是 <code>popped</code> 的排列。</li></ol><p>注意：本题与主站 946 题相同：</p><h4 id="Solution1-X一样长的代码"><a href="#Solution1-X一样长的代码" class="headerlink" title="Solution1 - X一样长的代码"></a>Solution1 - X一样长的代码</h4><pre><code class="c++">class Solution {public:    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped)    {        stack&lt;int&gt; lstack;        int i = 0, j = 0;        while (i &lt; pushed.size() &amp;&amp; j &lt; popped.size())        {            while (!lstack.empty())            {                if (lstack.top() == popped[j])                {                    lstack.pop();                    j++;                }                else                {                    break;                }            }            if (pushed[i] == popped[j])            {                i++;                j++;            }            else            {                lstack.push(pushed[i]);                i++;            }        }        while (!lstack.empty())        {            if (lstack.top() == popped[j])            {                lstack.pop();                j++;            }            else            {                return false;            }        }        return true;    }};</code></pre><h4 id="Solution2-大佬精简的代码"><a href="#Solution2-大佬精简的代码" class="headerlink" title="Solution2 - 大佬精简的代码"></a>Solution2 - 大佬精简的代码</h4><pre><code class="c++">class Solution {public:    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped)    {        stack&lt;int&gt; lstack;        int j = 0;        for (int num : pushed)        {            lstack.push(num);            while (!lstack.empty() &amp;&amp; lstack.top() == popped[j])            {                lstack.pop();                j++;            }        }        return j == popped.size();    }};</code></pre><p><strong>精简思路</strong></p><p>源代码是栈不为空的时候 比较栈顶和<code>popped[i]</code></p><p>如果相等则出栈</p><p>如果不相等 转去判断<code>pushed当前元素</code>和<code>popped[i]</code></p><p>如果两者相等则后移</p><p>如果两者不相等则入栈当前元素.</p><p><em>实际上这里就可以直接入栈元素然后再判断,如果相等了就出栈 如果不相等也恰好入栈了</em></p><h3 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - I. 从上到下打印二叉树</a></h3><p>Difficulty: <strong>中等</strong></p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回：</p><pre><code>[3,9,20,15,7]</code></pre><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><h4 id="Solution-deque"><a href="#Solution-deque" class="headerlink" title="Solution - deque"></a>Solution - deque</h4><pre><code class="c++">​class Solution {public:    vector&lt;int&gt; levelOrder(TreeNode* root)    {        if (!root)        {            return {};        }        deque&lt;TreeNode*&gt; nodes;        nodes.push_back(root);        vector&lt;int&gt; result;        while (!nodes.empty())        {            TreeNode* node = nodes.front();            nodes.pop_front();            result.push_back(node-&gt;val);            if (node-&gt;left)            {                nodes.push_back(node-&gt;left);            }            if (node-&gt;right)            {                nodes.push_back(node-&gt;right);            }        }        return result;    }};</code></pre><h3 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h3><p>Difficulty: <strong>简单</strong></p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回其层次遍历结果：</p><pre><code>[  [3],  [9,20],  [15,7]]</code></pre><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><p>注意：本题与主站 102 题相同：</p><h4 id="Solution-使用nullptr标记"><a href="#Solution-使用nullptr标记" class="headerlink" title="Solution - 使用nullptr标记"></a>Solution - 使用nullptr标记</h4><pre><code class="c++">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)    {        if (!root)        {            return {};        }        deque&lt;TreeNode*&gt; nodes;        nodes.push_back(root);        nodes.push_back(nullptr);        vector&lt;vector&lt;int&gt;&gt; result;        result.push_back(vector&lt;int&gt;());        while (!nodes.empty())        {            TreeNode* node = nodes.front();            nodes.pop_front();            if (node)            {                result.back().push_back(node-&gt;val);                if (node-&gt;left)                {                    nodes.push_back(node-&gt;left);                }                if (node-&gt;right)                {                    nodes.push_back(node-&gt;right);                }            }            else            {                if (!nodes.empty())                {                    result.push_back(vector&lt;int&gt;());                    nodes.push_back(nullptr);                }            }        }        return result;    }};</code></pre><p>首先想出的就是这个方法</p><h4 id="使用for循环-提前保存变量解决size会改变的问题"><a href="#使用for循环-提前保存变量解决size会改变的问题" class="headerlink" title="- 使用for循环 提前保存变量解决size会改变的问题"></a>- 使用for循环 提前保存变量解决size会改变的问题</h4><pre><code class="c++">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)    {        if (!root)        {            return {};        }        deque&lt;TreeNode*&gt; nodes;        nodes.push_back(root);        vector&lt;vector&lt;int&gt;&gt; result;        while (!nodes.empty())        {            result.push_back(vector&lt;int&gt;());            int ss = nodes.size();            for (int i = 0; i &lt; ss; ++i)            {                TreeNode* node = nodes.front();                nodes.pop_front();                result.back().push_back(node-&gt;val);                if (node-&gt;left)                {                    nodes.push_back(node-&gt;left);                }                if (node-&gt;right)                {                    nodes.push_back(node-&gt;right);                }            }        }        return result;    }};</code></pre><p>写完S1就去看了看题解 没想到还有这种方法, 妙蛙种子在米奇妙妙屋吃妙脆角</p><h3 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank" rel="noopener">剑指 Offer 32 - III. 从上到下打印二叉树 III</a></h3><p>Difficulty: <strong>中等</strong></p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回其层次遍历结果：</p><pre><code>[  [3],  [20,9],  [15,7]]</code></pre><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 1000</code></li></ol><h4 id="Solution-设置标志位"><a href="#Solution-设置标志位" class="headerlink" title="Solution - 设置标志位"></a>Solution - 设置标志位</h4><pre><code class="c++">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)     {        if (!root)        {            return {};        }        deque&lt;TreeNode*&gt; nodes;        nodes.push_back(root);        bool right = true;        vector&lt;vector&lt;int&gt;&gt; result;        while (!nodes.empty())        {            result.emplace_back();            int SS = nodes.size();            if (right)            {                right = false;                for (int i = 0; i &lt; SS; ++i)                {                    TreeNode* node = nodes.front();                    nodes.pop_front();                    result.back().push_back(node-&gt;val);                    if (node-&gt;left)                    {                        nodes.push_back(node-&gt;left);                    }                    if (node-&gt;right)                    {                        nodes.push_back(node-&gt;right);                    }                }            }            else            {                right = true;                for (int i = SS - 1; i &gt;= 0; --i)                {                    TreeNode* node = nodes.back();                    nodes.pop_back();                    result.back().push_back(node-&gt;val);                    if (node-&gt;right)                    {                        nodes.push_front(node-&gt;right);                    }                    if (node-&gt;left)                    {                        nodes.push_front(node-&gt;left);                    }                }            }        }        return result;    }};​</code></pre><h4 id="Solution-使用reverse"><a href="#Solution-使用reverse" class="headerlink" title="Solution - 使用reverse"></a>Solution - 使用reverse</h4><pre><code class="c++">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root)     {        if (!root)        {            return {};        }        deque&lt;TreeNode*&gt; nodes;        nodes.push_back(root);        vector&lt;vector&lt;int&gt;&gt; result;        bool even = false;        while (!nodes.empty())        {            result.emplace_back();            int SS = nodes.size();            vector&lt;int&gt;&amp; tmp = result.back();            for (int i = 0; i &lt; SS; ++i)            {                TreeNode* node = nodes.front();                nodes.pop_front();                tmp.push_back(node-&gt;val);                if (node-&gt;left)                {                    nodes.push_back(node-&gt;left);                }                if (node-&gt;right)                {                    nodes.push_back(node-&gt;right);                }            }            if (even)            {                std::reverse(tmp.begin(), tmp.end());            }            even = !even;        }        return result;    }};</code></pre><h3 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></h3><p>Difficulty: <strong>中等</strong></p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><pre><code>     5    / \   2   6  / \ 1   3</code></pre><p><strong>示例 1：</strong></p><pre><code>输入: [1,6,3,2,5]输出: false</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: [1,3,2,6,5]输出: true</code></pre><p><strong>提示：</strong></p><ol><li><code>数组长度 &lt;= 1000</code></li></ol><h4 id="Solution-递归-3"><a href="#Solution-递归-3" class="headerlink" title="Solution - 递归"></a>Solution - 递归</h4><pre><code class="c++">​class Solution {public:    bool verifyPostorder(vector&lt;int&gt;&amp; postorder)    {        return verifyPostorder(postorder, 0, postorder.size());    }    bool verifyPostorder(vector&lt;int&gt;&amp; postorder, int begin, int end)    {        if (end - begin &lt;= 2)        {            return true;        }        int root_sub = end - 1;        int r_begin = begin;        for (int i = begin; i &lt; root_sub; ++i)        {            if (postorder[i] &lt; postorder[root_sub])            {                r_begin++;            }            else            {                break;            }        }        for (int i = r_begin; i &lt; root_sub; ++i)        {            if (postorder[i] &lt; postorder[root_sub])            {                return false;            }        }        return verifyPostorder(postorder, begin, r_begin) &amp;&amp;             verifyPostorder(postorder, r_begin, root_sub);    }};</code></pre><p>睡前来一道, 这是我第一次 一次通过的剑指里面的中等题目-_- 睡了睡了</p><h4 id="Solution-迭代-栈"><a href="#Solution-迭代-栈" class="headerlink" title="Solution - 迭代 栈"></a>Solution - 迭代 栈</h4><h3 id="剑指-Offer-34-二叉树中和为某一值的路径"><a href="#剑指-Offer-34-二叉树中和为某一值的路径" class="headerlink" title="剑指 Offer 34. 二叉树中和为某一值的路径"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener">剑指 Offer 34. 二叉树中和为某一值的路径</a></h3><p>Difficulty: <strong>中等</strong></p><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p><pre><code>              5             / \            4   8           /   / \          11  13  4         /  \    / \        7    2  5   1</code></pre><p>返回:</p><pre><code>[   [5,4,11,2],   [5,8,4,5]]</code></pre><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 10000</code></li></ol><p>注意：本题与主站 113 题相同：</p><h4 id="Solution-回溯法"><a href="#Solution-回溯法" class="headerlink" title="Solution - 回溯法"></a>Solution - 回溯法</h4><pre><code class="c++">​class Solution {public:    vector&lt;int&gt; path;    vector&lt;vector&lt;int&gt;&gt; result;    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum)    {        dfs(root, sum);        return result;     }    void dfs(TreeNode* root, int sum)    {        if (!root)        {            return;        }        path.push_back(root-&gt;val);        if (sum == root-&gt;val &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right)        {            result.push_back(path);        }        else        {            dfs(root-&gt;left, sum - root-&gt;val);            dfs(root-&gt;right, sum - root-&gt;val);        }        path.pop_back();    }};</code></pre><h3 id="剑指-Offer-37-序列化二叉树"><a href="#剑指-Offer-37-序列化二叉树" class="headerlink" title="剑指 Offer 37. 序列化二叉树"></a><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 37. 序列化二叉树</a></h3><p>Difficulty: <strong>困难</strong></p><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>*<em>示例: *</em></p><pre><code>你可以将以下二叉树：    1   / \  2   3     / \    4   5序列化为 &quot;[1,2,3,null,null,4,5]&quot;</code></pre><p>注意：本题与主站 297 题相同：</p><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">class Codec {public:    // Encodes a tree to a single string.    string serialize(TreeNode* root)    {        if (!root)        {            return &quot;[null]&quot;;        }        deque&lt;TreeNode*&gt; nodes;        nodes.push_back(root);        string result;        while (!nodes.empty())        {            TreeNode* node = nodes.front();            nodes.pop_front();            if (node)            {                result += &quot;,&quot; + to_string(node-&gt;val);                nodes.push_back(node-&gt;left);                nodes.push_back(node-&gt;right);            }            else            {                result += &quot;,null&quot;;            }        }        result[0] = &#39;[&#39;;        result += &#39;]&#39;;        return result;    }    // Decodes your encoded data to tree.    TreeNode* deserialize(string data)    {        deque&lt;TreeNode*&gt; nodes;        ParseData(data, nodes);        TreeNode* ret = nodes.front();        nodes.pop_front();        if (nodes.size() == 0)        {            return ret;        }        deque&lt;TreeNode*&gt; temp_nodes;        temp_nodes.push_back(ret);        while (!temp_nodes.empty())        {            const int SS = temp_nodes.size();            if (nodes.size() &lt; SS * 2)            {                break;            }            for (int i = 0; i &lt; SS; ++i)            {                TreeNode* node = temp_nodes.front();                temp_nodes.pop_front();                node-&gt;left = nodes.front();                nodes.pop_front();                node-&gt;right = nodes.front();                nodes.pop_front();                if (node-&gt;left)                {                    temp_nodes.push_back(node-&gt;left);                }                if (node-&gt;right)                {                    temp_nodes.push_back(node-&gt;right);                }            }        }        return ret;    }    void ParseData(const string&amp; data, deque&lt;TreeNode*&gt;&amp; nodes)    {        int i = 1;        int num = 0;        bool empty = false;        int flag = 1; // -        while (i &lt; data.size())        {            char c = data[i++];            if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)            {                num = num * 10 + c - &#39;0&#39;;            }            else if (c == &#39;,&#39; || c == &#39;]&#39;)            {                if (empty)                {                    nodes.push_back(nullptr);                    empty = false;                }                else                {                    nodes.push_back(new TreeNode(num * flag));                    num = 0;                    flag = 1;                }            }            else if (c == &#39;n&#39;)            {                empty = true;            }            else if (c == &#39;-&#39;)            {                flag = -1;            }        }    }};​</code></pre><h3 id="剑指-Offer-38-字符串的排列-30MIN"><a href="#剑指-Offer-38-字符串的排列-30MIN" class="headerlink" title="剑指 Offer 38. 字符串的排列 - 30MIN"></a><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 38. 字符串的排列</a> - 30MIN</h3><p>Difficulty: <strong>中等</strong></p><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><strong>示例:</strong></p><pre><code>输入：s = &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</code></pre><p><strong>限制：</strong></p><p><code>1 &lt;= s 的长度 &lt;= 8</code></p><h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    vector&lt;string&gt; result;    vector&lt;string&gt; permutation(string s)    {        std::string temp;        temp.resize(s.size());        permutation(s, 0, temp);        return result;    }    void permutation(string&amp; s, int sub, std::string&amp; temp)    {        if (sub == s.size())        {            result.push_back(temp);            return;        }        char flag[&#39;z&#39; - &#39;A&#39; + 1]{};        for (int i = 0; i &lt; s.size(); ++i)        {            char back = s[i];            if (back != &#39;#&#39;)            {                if (flag[back - &#39;A&#39;] == 0)                {                    flag[back - &#39;A&#39;] = 1;                    temp[sub] = s[i];                    s[i] = &#39;#&#39;;                    permutation(s, sub + 1, temp);                    s[i] = back;                }            }        }    }};</code></pre><p>代码中防止重复的代码太巧了, 自己一开始使用的set去重. 然后看到了题解的剪枝方法 在每一层中一个字母仅能出现一次, 时间消耗大幅下降了</p><h4 id="Solution-改进版-源字符串上swap"><a href="#Solution-改进版-源字符串上swap" class="headerlink" title="Solution - 改进版 - 源字符串上swap"></a>Solution - 改进版 - 源字符串上swap</h4><pre><code class="c++">class Solution {public:    vector&lt;string&gt; result;    vector&lt;string&gt; permutation(string s)    {                permutation(s, 0);        return result;    }    void permutation(string&amp; s, int sub)    {        if (sub == s.size() - 1) // 仅剩一个字符 该字符正好位于末尾 直接保存        {            result.push_back(s);            return;        }        char flag[&#39;z&#39; - &#39;A&#39; + 1]{};        for (int i = sub; i &lt; s.size(); ++i) // 从本层开始 sub之前的字符已经被使用了        {            char back = s[i];            if (flag[back - &#39;A&#39;] == 0)            {                flag[back - &#39;A&#39;] = 1;                swap(s[i], s[sub]); // 交换未使用元素到本层位置                permutation(s, sub + 1);                swap(s[i], s[sub]);            }        }    }};</code></pre><p>由于是全排列, 其实可以将未使用元素挨个的交换到本层位置 这样本层位置之前的字符是使用过的.</p><h3 id="剑指-Offer-39-数组中出现次数超过一半的数字-20MIN"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字-20MIN" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字 - 20MIN"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 39. 数组中出现次数超过一半的数字</a> - 20MIN</h3><p>Difficulty: <strong>简单</strong></p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1:</strong></p><pre><code>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2</code></pre><p><strong>限制：</strong></p><p><code>1 &lt;= 数组长度 &lt;= 50000</code></p><p>注意：本题与主站 169 题相同：</p><h4 id="Solution-Map统计次数"><a href="#Solution-Map统计次数" class="headerlink" title="Solution - Map统计次数"></a>Solution - Map统计次数</h4><pre><code class="c++">​int majorityElement(vector&lt;int&gt;&amp; nums){    map&lt;int, int&gt; times;    int end_time = nums.size() / 2;    for (auto&amp; num : nums)    {        times[num]++;        if (times[num] &gt; end_time)        {            return num;        }    }    return 0;}</code></pre><h4 id="Solution-sort排序-中间位置元素为结果"><a href="#Solution-sort排序-中间位置元素为结果" class="headerlink" title="Solution - sort排序 中间位置元素为结果"></a>Solution - sort排序 中间位置元素为结果</h4><pre><code class="c++">int majorityElement(vector&lt;int&gt;&amp; nums){    sort(nums.begin(), nums.end());    return nums[nums.size() / 2];}</code></pre><h4 id="Solution-摩尔投票法"><a href="#Solution-摩尔投票法" class="headerlink" title="Solution - 摩尔投票法"></a>Solution - 摩尔投票法</h4><pre><code class="c++">int majorityElement(vector&lt;int&gt;&amp; nums){    int vote = nums[0];    int sum = 0;    for (auto&amp; num : nums)    {        sum += vote == num ? 1 : -1;        if (sum &lt; 0)        {            vote = num;            sum = 1;        }    }    // int times = 0;    // for (auto&amp; num : nums)    // {    //     times += num == vote ? 1 : 0;    // }    // 如果可能不存在结果 则需要进行验证    return vote;}</code></pre><h3 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a></h3><p>Difficulty: <strong>简单</strong></p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 1：</strong></p><pre><code>输入：arr = [3,2,1], k = 2输出：[1,2] 或者 [2,1]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：arr = [0,1,2,1], k = 1输出：[0]</code></pre><p><strong>限制：</strong></p><ul><li><code>0 &lt;= k &lt;= arr.length &lt;= 10000</code></li><li><code>0 &lt;= arr[i] &lt;= 10000</code></li></ul><h4 id="Solution-维护最大堆-O-nlogk-O-k"><a href="#Solution-维护最大堆-O-nlogk-O-k" class="headerlink" title="Solution - 维护最大堆 O(nlogk) O(k)"></a>Solution - 维护最大堆 O(nlogk) O(k)</h4><pre><code class="c++">​class Solution {public:    priority_queue&lt;int&gt; min_heap;    void TryToAdd(int num, int k)    {        if (min_heap.size() &lt; k)        {            min_heap.push(num);        }        else        {            if (num &lt; min_heap.top())            {                min_heap.pop();                min_heap.push(num);            }        }    }    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k)    {        if (k &lt;= 0)        {            return {};        }        for (auto num : arr)        {            TryToAdd(num, k);        }        vector&lt;int&gt; result(k);        for (int i = 0; i &lt; k; ++i)        {            result[i] = min_heap.top();            min_heap.pop();        }        return result;    }};</code></pre><h4 id="Solution-基于快排分区思想-O-n-O-logn"><a href="#Solution-基于快排分区思想-O-n-O-logn" class="headerlink" title="Solution - 基于快排分区思想 O(n) O(logn)"></a>Solution - 基于快排分区思想 O(n) O(logn)</h4><pre><code class="c++">class Solution {public:    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k)    {        if (k == 0)        {            return {};        }        Partition(arr, 0, arr.size() - 1, k);        return vector&lt;int&gt;(arr.begin(), arr.begin() + k);    }    int Partition(vector&lt;int&gt;&amp; arr, int left , int right, int k)    {        if (right - left &lt;= 0)        {            return left;        }        int ret = left;        int index = ret + 1;        for (int i = index; i &lt;= right; ++i)        {            if (arr[i] &lt; arr[ret])            {                swap(arr[index], arr[i]);                index++;            }        }        swap(arr[index - 1], arr[ret]);        int part = index - 1;        if (part == k)        {            return part;        }        else if (part &lt; k)        {            return Partition(arr, part + 1, right, k);        }        else        {            return Partition(arr, left, part - 1, k);        }    }};</code></pre><h3 id="剑指-Offer-41-数据流中的中位数-30MIN"><a href="#剑指-Offer-41-数据流中的中位数-30MIN" class="headerlink" title="剑指 Offer 41. 数据流中的中位数 - 30MIN"></a><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 41. 数据流中的中位数</a> - 30MIN</h3><p>Difficulty: <strong>困难</strong></p><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[1],[2],[],[3],[]]输出：[null,null,null,1.50000,null,2.00000]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[2],[],[3],[]]输出：[null,null,2.00000,null,2.50000]</code></pre><p><strong>限制：</strong></p><ul><li>最多会对 <code>addNum、findMedian</code> 进行 <code>50000</code> 次调用。</li></ul><p>注意：本题与主站 295 题相同：</p><h4 id="Solution-最大堆-最小堆-求中位数"><a href="#Solution-最大堆-最小堆-求中位数" class="headerlink" title="Solution 最大堆 + 最小堆 求中位数"></a>Solution 最大堆 + 最小堆 求中位数</h4><pre><code class="c++">​class MedianFinder {public:    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_heap;    priority_queue&lt;int&gt; max_heap;    int size = 0;    /** initialize your data structure here. */    MedianFinder() {    }    void addNum(int num)    {        if (size == 0)        {            min_heap.push(num);        }        else        {            if (size % 2 == 0)            {                if (num &gt; max_heap.top())                {                    min_heap.push(num);                }                else                {                    max_heap.push(num);                    min_heap.push(max_heap.top());                    max_heap.pop();                }            }            else            {                if (num &lt; min_heap.top())                {                    max_heap.push(num);                }                else                {                    min_heap.push(num);                    max_heap.push(min_heap.top());                    min_heap.pop();                }            }        }        size++;    }    double findMedian()    {        if (size % 2 == 0)        {            return (max_heap.top() + min_heap.top()) / 2.0;        }        else        {            return min_heap.top();        }    }};</code></pre><p>最开始写的时候堆的调整写在了findMedian里面, 实际应该写在addNum这样函数的功能才分工明确 而且由于两个堆大小基本平衡效率更高</p><h3 id="剑指-Offer-42-连续子数组的最大和-5MIN"><a href="#剑指-Offer-42-连续子数组的最大和-5MIN" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和 - 5MIN"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">剑指 Offer 42. 连续子数组的最大和</a> - 5MIN</h3><p>Difficulty: <strong>简单</strong></p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例1:</strong></p><pre><code>输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-100 &lt;= arr[i] &lt;= 100</code></li></ul><p>注意：本题与主站 53 题相同：</p><h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums)    {        int sum = 0;        int ret = nums[0];        for (auto&amp; num : nums)        {            if (sum &gt;= 0)            {                sum += num;            }            else            {                sum = num;            }            ret = max(sum, ret);        }        return ret;    }};</code></pre><h3 id="剑指-Offer-45-把数组排成最小的数"><a href="#剑指-Offer-45-把数组排成最小的数" class="headerlink" title="剑指 Offer 45. 把数组排成最小的数"></a><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 45. 把数组排成最小的数</a></h3><p>Difficulty: <strong>中等</strong></p><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例 1:</strong></p><pre><code>输入: [10,2]输出: &quot;102&quot;</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [3,30,34,5,9]输出: &quot;3033459&quot;</code></pre><p><strong>提示:</strong></p><ul><li><code>0 &lt; nums.length &lt;= 100</code></li></ul><p><strong>说明:</strong></p><ul><li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li><li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li></ul><h4 id="Solution-遇事不决dfs-超时"><a href="#Solution-遇事不决dfs-超时" class="headerlink" title="Solution - 遇事不决dfs 超时.."></a>Solution - 遇事不决dfs 超时..</h4><pre><code class="c++">​class Solution {public:    string minNumber(vector&lt;int&gt;&amp; nums)    {        string result;        string temp;        dfs(nums, 0, result, temp);        return result;    }    void dfs(vector&lt;int&gt;&amp; nums, int sub, string&amp; result, string&amp; temp)    {        if (!result.empty() &amp;&amp; result.compare(temp) &lt; 0) // 剪枝        {            return;        }        if (sub == nums.size())        {            if (result.empty() || result.compare(temp) &gt; 0)            {                result = temp;            }            return;        }        set&lt;int&gt; exist;        for (int i = sub; i &lt; nums.size(); ++i)        {            auto iter = exist.lower_bound(nums[i]); // 剪枝            if (iter == exist.end() || *iter != nums[i])            {                exist.insert(iter, nums[i]);                swap(nums[i], nums[sub]);                string num = to_string(nums[sub]);                temp += num;                dfs(nums, sub + 1, result, temp);                temp.erase(temp.end() - num.size(), temp.end());                swap(nums[i], nums[sub]);            }        }    }};</code></pre><h4 id="Solution-特殊的排序-另类的comp函数"><a href="#Solution-特殊的排序-另类的comp函数" class="headerlink" title="Solution - 特殊的排序(另类的comp函数)"></a>Solution - 特殊的排序(另类的comp函数)</h4><pre><code class="c++">class Solution {public:    void QuickSort(vector&lt;string&gt;&amp; strs, int left, int right)    {        if (right - left &lt;= 0)        {            return;        }        auto comp =            [](const string&amp; lhs, const string&amp; rhs)            {                return lhs + rhs &lt; rhs + lhs;            };        int pivot = left;        int index = left + 1;        for (int i = index; i &lt;= right; ++i)        {            if (comp(strs[i], strs[pivot]))            {                swap(strs[i], strs[index]);                index++;            }        }        swap(strs[pivot], strs[index - 1]);        // int le = left;        // int ri = right;        // while (le &lt; ri)        // {        //     while (le &lt; ri &amp;&amp; !comp(strs[ri], strs[pivot]))        //     {        //         ri--;        //     }        //     while (le &lt; ri &amp;&amp; comp(strs[le], strs[pivot]))        //     {        //         le++;        //     }        //     swap(strs[le], strs[ri]);        // }        // swap(strs[le], strs[pivot]);        QuickSort(strs, left, index - 2);        QuickSort(strs, index, right);    }    string minNumber(vector&lt;int&gt;&amp; nums)    {        vector&lt;string&gt; strs;        strs.reserve(nums.size());        for (int num : nums)        {            strs.push_back(to_string(num));        }        QuickSort(strs, 0, strs.size() - 1);        string result;        for (const auto&amp; str : strs)        {            result += str;        }        return result;    }};</code></pre><h3 id="剑指-Offer-46-把数字翻译成字符串"><a href="#剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="剑指 Offer 46. 把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 46. 把数字翻译成字符串</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>示例 1:</strong></p><pre><code>输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= num &lt; 2&lt;sup&gt;31&lt;/sup&gt;</code></li></ul><h4 id="Solution-遇事不决dfs"><a href="#Solution-遇事不决dfs" class="headerlink" title="Solution - 遇事不决dfs"></a>Solution - 遇事不决dfs</h4><pre><code class="c++">​class Solution {public:    int translateNum(int num)    {        string num_str = to_string(num);        return dfs(num_str, 0);    }    int dfs(const string&amp; str, int sub)    {        if (sub &gt; str.size())        {            return 0;        }        else if (sub &gt;= str.size() - 1)        {            return 1;        }        int time = 0;        if (sub &lt; str.size() - 1 &amp;&amp; str[sub] == &#39;1&#39;)        {            time += dfs(str, sub + 2);        }        else if (sub &lt; str.size() - 1 &amp;&amp; str[sub] == &#39;2&#39; &amp;&amp;                 str[sub + 1] &gt;= &#39;0&#39; &amp;&amp; str[sub + 1] &lt;= &#39;5&#39;)        {            time += dfs(str, sub + 2);        }        time += dfs(str, sub + 1);        return time;    }};</code></pre><h4 id="Solution-DP"><a href="#Solution-DP" class="headerlink" title="Solution - DP"></a>Solution - DP</h4><pre><code class="c++">class Solution {public:    int translateNum(int num)    {        string num_str = to_string(num);        vector&lt;int&gt; dp(num_str.size() + 1);        dp[0] = 1;        dp[1] = 1;        for (int i = 2; i &lt;= num_str.size(); ++i)        {            dp[i] = dp[i - 1];            if (num_str[i - 2] == &#39;1&#39;)            {                dp[i] += dp[i - 2];            }            else if (num_str[i - 2] == &#39;2&#39; &amp;&amp; num_str[i - 1] &gt;= &#39;0&#39; &amp;&amp; num_str[i - 1] &lt;= &#39;5&#39;)            {                dp[i] += dp[i - 2];            }        }        return dp[num_str.size()];    }};</code></pre><p>可以对dp数组进行降维打击 易读性也被降维打击了</p><pre><code class="c++">class Solution {public:    int translateNum(int num)    {        string num_str = to_string(num);        int a = 1; // i - 2        int b = 1; // i - 1        int dp = b; // i        for (int i = 2; i &lt;= num_str.size(); ++i)        {            dp = b;            if (num_str[i - 2] == &#39;1&#39;)            {                dp += a;            }            else if (num_str[i - 2] == &#39;2&#39; &amp;&amp; num_str[i - 1] &gt;= &#39;0&#39; &amp;&amp; num_str[i - 1] &lt;= &#39;5&#39;)            {                dp += a;            }            a = b;            b = dp;        }        return dp;    }};</code></pre><p><code>dp[0]=1</code>这点没有考虑到, 本来设置的为0. </p><p>然而当num为25的时候<code>dp[2]</code>应该为2, 所以必须把<code>dp[0]</code>设置为1</p><p>状态转移方程<code>dp[i] = dp[i - 1] + dp[i - 2](i-1和i-2字符需要能连接)</code> 是因为如果把<code>i-1和i-2</code>连接有<code>dp[i-2]</code>种</p><p>如果不连接则有<code>dp[i - 1]</code>种 所以最终是二者之和</p><p>可以对str字符串进行降维打击 易读性又双被降维打击了</p><pre><code class="c++">class Solution {public:    int translateNum(int num)    {        int a = 1; // i - 2        int b = 1; // i - 1        int dp = b; // i        int last_s = num % 10;        int now_s;        num /= 10;        while (num != 0)        {            now_s = num % 10;            num /= 10;            dp = b;            int temp = now_s * 10 + last_s;            if (temp &gt;= 10 &amp;&amp; temp &lt;= 25)            {                dp += a;            }            a = b;            b = dp;            last_s = now_s;        }        return dp;    }};</code></pre><h3 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 47. 礼物的最大价值</a></h3><p>Difficulty: <strong>中等</strong></p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><pre><code>输入: [  [1,3,1],  [1,5,1],  [4,2,1]]输出: 12解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</code></pre><p>提示：</p><ul><li><code>0 &lt; grid.length &lt;= 200</code></li><li><code>0 &lt; grid[0].length &lt;= 200</code></li></ul><h4 id="Solution-备忘录-接近超时"><a href="#Solution-备忘录-接近超时" class="headerlink" title="Solution - 备忘录 接近超时"></a>Solution - 备忘录 接近超时</h4><pre><code class="c++">​class Solution {public:    int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid)    {        return dfs(grid, 0, 0);    }    std::map&lt;std::string, int&gt; bwl;    int dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y)    {        if (x == grid.size() - 1 &amp;&amp; y == grid[0].size() - 1)        {            return grid[x][y];        }        std::string key = to_string(x) + &quot;,&quot; + to_string(y);        auto iter = bwl.find(key);        if (iter != bwl.end())        {            return iter-&gt;second;        }        int r = 0;        int d = 0;        if (x &lt; grid.size() - 1 &amp;&amp; y &lt; grid[0].size())        {            r = dfs(grid, x + 1, y);        }        if (y &lt; grid[0].size() - 1 &amp;&amp; x &lt; grid.size())        {            d = dfs(grid, x, y + 1);        }        int result = max(r, d) + grid[x][y];        bwl[key] = result;        return result;    }};</code></pre><h4 id="Solution-dp-table-接近100"><a href="#Solution-dp-table-接近100" class="headerlink" title="Solution - dp table 接近100%"></a>Solution - dp table 接近100%</h4><pre><code class="c++">class Solution {public:    int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid)    {        const int XS = grid.size();        const int YS = grid[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(XS + 1, vector&lt;int&gt;(YS + 1, 0));        for (int x = 1; x &lt;= XS; ++x)        {            for (int y = 1; y &lt;= YS; ++y)            {                dp[x][y] = max(dp[x - 1][y], dp[x][y - 1]) + grid[x - 1][y - 1];            }        }        return dp[XS][YS];    }};</code></pre><h3 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 48. 最长不含重复字符的子字符串</a></h3><p>Difficulty: <strong>中等</strong></p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><p>提示：</p><ul><li><code>s.length &lt;= 40000</code></li></ul><p>注意：本题与主站 3 题相同：</p><h4 id="Solution-双指针-hash表"><a href="#Solution-双指针-hash表" class="headerlink" title="Solution - 双指针 + hash表"></a>Solution - 双指针 + hash表</h4><pre><code class="c++">​class Solution {public:    int lengthOfLongestSubstring(string s)     {        if (s.empty())        {            return 0;        }        int begin = 0;        int end = 0;        int hash[128]{};        for (int i = 0; i &lt; 128; ++i)        {            hash[i] = -1;        }        int ret = 1;        for (;end &lt; s.size(); ++end)        {            char c = s[end];            if (hash[c] &gt;= begin)            {                int len = end - begin;                ret = max(len, ret);                begin = hash[c] + 1;            }            hash[c] = end;        }        ret = max(end - begin, ret);        return ret;    }};</code></pre><pre><code class="c++">​class Solution {public:    int lengthOfLongestSubstring(string s)     {        int begin = 0;        int end = 0;        int hash[128]{};        for (int i = 0; i &lt; 128; ++i)        {            hash[i] = -1;        }        int ret = 0;        for (;end &lt; s.size(); ++end)        {            char c = s[end];            if (hash[c] &gt;= begin)            {                begin = hash[c] + 1;            }            ret = max(end - begin + 1, ret);            hash[c] = end;        }        return ret;    }};</code></pre><p>简化版, <code>hash[c] &gt;= begin</code>主要是更细begin指针, 而更新ret的可以放一起. 原版是end在重复的字符上进行取长度, 新版则是end未在重复字符上 所以需要长度 + 1</p><h4 id="Solution-Dp-hash表"><a href="#Solution-Dp-hash表" class="headerlink" title="Solution - Dp + hash表"></a>Solution - Dp + hash表</h4><pre><code class="c++">class Solution {public:    int lengthOfLongestSubstring(string s)     {        int hash[128]{};        vector&lt;int&gt; dp(s.size() + 1);        dp[0] = 0;        int begin = 1;        int ret = 0;        for(int i = 1; i &lt;= s.size(); ++i)        {            char c = s[i - 1];            if (hash[c] &gt;= begin)            {                dp[i] = i - hash[c];                begin = hash[c] + 1;            }             else            {                dp[i] = dp[i - 1] + 1;            }            hash[c] = i;            ret = max(ret, dp[i]);        }        return ret;    }};</code></pre><h3 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 49. 丑数</a></h3><p>Difficulty: <strong>中等</strong></p><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p><strong>示例:</strong></p><pre><code>输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</code></pre><p>*<em>说明: *</em> </p><ol><li><code>1</code> 是丑数。</li><li><code>n</code> <strong>不超过</strong>1690。</li></ol><p>注意：本题与主站 264 题相同：</p><h4 id="Solution-逐个计算-超时"><a href="#Solution-逐个计算-超时" class="headerlink" title="Solution - 逐个计算 超时"></a>Solution - 逐个计算 超时</h4><pre><code class="c++">​class Solution {public:    int nthUglyNumber(int n)    {        if (n &lt;= 1)        {            return 1;        }        unordered_set&lt;int&gt; ugly_num;        vector&lt;int&gt; bases = {2, 3, 5};        ugly_num.insert(1);        int k = 1;        int num = 1;        while (k &lt; n)        {            num++;            for (int base : bases)            {                if (num % base == 0 &amp;&amp; ugly_num.find(num / base) != ugly_num.end())                {                    ugly_num.insert(num);                    k++;                    break;                }            }        }        return num;    }};</code></pre><h4 id="Solution-生成丑数"><a href="#Solution-生成丑数" class="headerlink" title="Solution - 生成丑数"></a>Solution - 生成丑数</h4><pre><code class="c++">class Solution {public:    int nthUglyNumber(int n)    {        int dp[n];        dp[0] = 1;        int a = 0, b = 0, c = 0;        for (int i = 1; i &lt; n; ++i)        {            int numa = dp[a] * 2;            int numb = dp[b] * 3;            int numc = dp[c] * 5;            int min_abc = min(numa, min(numb, numc));            dp[i] = min_abc;            if (min_abc == numa)            {                a++;            }            if (min_abc == numb)            {                b++;            }            if (min_abc == numc)            {                c++;            }        }        return dp[n - 1];    }};</code></pre><p>每个新的丑数都是已有丑数的2 3 5倍, 需要按循序将这些丑数排好. 如果一个数字已经提供过了新的丑数, 那么就应该有这个新的丑数尝试去提供, 否则一定是重复的 对应了</p><p>代码中的a++ b++ c++, 每次取出最小的丑数添加到结果中</p><h3 id="剑指-Offer-50-第一个只出现一次的字符"><a href="#剑指-Offer-50-第一个只出现一次的字符" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符"></a><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank" rel="noopener">剑指 Offer 50. 第一个只出现一次的字符</a></h3><p>Difficulty: <strong>简单</strong></p><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><strong>示例:</strong></p><pre><code>s = &quot;abaccdeff&quot;返回 &quot;b&quot;s = &quot;&quot; 返回 &quot; &quot;</code></pre><p><strong>限制：</strong></p><p><code>0 &lt;= s 的长度 &lt;= 50000</code></p><h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    char firstUniqChar(string s)    {        if (s.empty())        {            return &#39; &#39;;        }        int hash2[26]{};        for (int i = 0; i &lt; 26; ++i)        {            hash2[i] = -1;        }        for (int i = 0; i &lt; s.size(); ++i)        {            int c = s[i] - &#39;a&#39;;            if (hash2[c] == -1)            {                hash2[c] = i; // 标记第一次出现的位置            }            else            {                hash2[c] = -2;            }        }        int min_sub = -1;        int min = INT_MAX;        for (int i = 0; i &lt; 26; ++i)        {            if (hash2[i] &gt;= 0 &amp;&amp; hash2[i] &lt; min)            {                min = hash2[i];                min_sub = i;              }        }        if (min_sub == -1)        {            return &#39; &#39;;        }        char result = &#39;a&#39; + min_sub;        return result;    }};</code></pre><h3 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">剑指 Offer 51. 数组中的逆序对</a></h3><p>Difficulty: <strong>困难</strong></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>示例 1:</strong></p><pre><code>输入: [7,5,6,4]输出: 5</code></pre><p><strong>限制：</strong></p><p><code>0 &lt;= 数组长度 &lt;= 50000</code></p><h4 id="Solution-归并排序-求逆序对"><a href="#Solution-归并排序-求逆序对" class="headerlink" title="Solution - 归并排序 求逆序对"></a>Solution - 归并排序 求逆序对</h4><pre><code class="c++">class Solution {public:    int reversePairs(vector&lt;int&gt;&amp; nums)    {        vector&lt;int&gt; temp(nums.size());        return MergeSort(nums, temp, 0, nums.size() - 1);    }    int MergeSort(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; temp, int left, int right)    {        if (left &gt;= right)        {            return 0;        }        int mid = (left + right) / 2;        int result = 0;        result += MergeSort(nums, temp, left, mid);        result += MergeSort(nums, temp, mid + 1, right);        int temp_i = left;        int i = left;        int j = mid + 1;        int begin_j = j;        while (i &lt;= mid &amp;&amp; j &lt;= right)        {            if (nums[i] &lt;= nums[j])            {                temp[temp_i++] = nums[i];                i++;                result += (j - begin_j);            }            else            {                temp[temp_i++] = nums[j];                j++;            }        }        for (;i &lt;= mid; ++i)        {            temp[temp_i++] = nums[i];            result += (j - begin_j);        }        for (; j &lt;= right; ++j)        {            temp[temp_i++] = nums[j];        }        std::copy(temp.begin() + left, temp.begin() + right + 1, nums.begin() + left);        return result;    }};</code></pre><h3 id="剑指-Offer-52-两个链表的第一个公共节点"><a href="#剑指-Offer-52-两个链表的第一个公共节点" class="headerlink" title="剑指 Offer 52. 两个链表的第一个公共节点"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 52. 两个链表的第一个公共节点</a></h3><p>Difficulty: <strong>简单</strong></p><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表<strong>：</strong></p><p>在节点 c1 开始相交。</p><p><strong>示例 1：</strong></p><pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。</code></pre><p><strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li><li>本题与主站 160 题相同：</li></ul><h4 id="Solution-相遇"><a href="#Solution-相遇" class="headerlink" title="Solution - 相遇"></a>Solution - 相遇</h4><pre><code class="c++">class Solution {public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)     {        if (!headA || !headB)        {            return nullptr;        }        ListNode* temp_a = headA;        ListNode* temp_b = headB;        while (temp_a-&gt;next || temp_b-&gt;next)        {            if (temp_a == temp_b)            {                return temp_a;            }            temp_a = temp_a-&gt;next ? temp_a-&gt;next : headB;            temp_b = temp_b-&gt;next ? temp_b-&gt;next : headA;         }        return temp_a == temp_b ? temp_a : nullptr;    }};</code></pre><p>这里踩了一个坑, 我开始是修改了next指针 首先题目不允许修改 其次修改之后会影响另一个指针的判断, 因为修改的这个node很可能是共享的node</p><pre><code class="c++">​class Solution {public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB)     {        ListNode* temp_a = headA;        ListNode* temp_b = headB;        while (temp_a != temp_b)        {            temp_a = temp_a ? temp_a-&gt;next : headB;            temp_b = temp_b ? temp_b-&gt;next : headA;         }        return temp_a;    }};</code></pre><p>退出条件优化了, 两种可能一种是二者相遇了 一种是二者都为空指针 这样代码能简化很多</p><h3 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 53 - II. 0～n-1中缺失的数字</a></h3><p>Difficulty: <strong>简单</strong></p><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><strong>示例 1:</strong></p><pre><code>输入: [0,1,3]输出: 2</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [0,1,2,3,4,5,6,7,9]输出: 8</code></pre><p><strong>限制：</strong></p><p><code>1 &lt;= 数组长度 &lt;= 10000</code></p><h4 id="Solution-二分法"><a href="#Solution-二分法" class="headerlink" title="Solution - 二分法"></a>Solution - 二分法</h4><pre><code class="c++">​class Solution {public:    int missingNumber(vector&lt;int&gt;&amp; nums)    {        if (nums[0] != 0)        {            return 0;        }        int ret = find(nums, 0, nums.size() - 1);        if (ret == -1)        {            return nums[nums.size() - 1] + 1;        }        return ret;    }    int find(vector&lt;int&gt;&amp; nums, int left, int right)    {        if (left &gt;= right)        {            return -1;        }        int mid = (left + right) / 2;        if (mid + 1 &lt;= right &amp;&amp; nums[mid] == nums[mid + 1] - 2)        {            return nums[mid] + 1;        }        else if (mid - 1 &gt;= left &amp;&amp; nums[mid] == nums[mid - 1] + 2)        {            return nums[mid] - 1;        }        else        {            int ret = find(nums, left, mid - 1);            if (ret == -1)            {                ret = find(nums, mid + 1, right);            }            return ret;        }    }};</code></pre><p>没错写了这么长的二分….  第一印象没有想到迭代版本 如何收缩区间. 索性就两侧都搜索. 实际看了题解才发现</p><p>漏掉了一个条件, 当<code>num[i] &gt; i</code>的时候就说明了缺失的数字在左边 反过来就是在右边</p><pre><code class="c++">class Solution {public:    int missingNumber(vector&lt;int&gt;&amp; nums)    {        int left = 0;        int right = nums.size() - 1;        while (left &lt;= right)        {            int mid = (left + right) / 2;            if (nums[mid] &gt; mid)            {                right = mid - 1;            }            else if (nums[mid] == mid)            {                left = mid + 1;            }        }        return left;    }};</code></pre><p>题解上面还多了一个判断点 循环结束的时候left位于右子数组的开始 right位于左子数组的结束</p><p>结果为右子数组开始元素的下标</p><pre><code class="c++">0 1 2 3 4 50 1 2 3 5 6 // 右子数组 56 左子数组 0 1 2 3  5对应的下标4位答案 </code></pre><h3 id="剑指-Offer-54-二叉搜索树的第k大节点"><a href="#剑指-Offer-54-二叉搜索树的第k大节点" class="headerlink" title="剑指 Offer 54. 二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/" target="_blank" rel="noopener">剑指 Offer 54. 二叉搜索树的第k大节点</a></h3><p>Difficulty: <strong>简单</strong></p><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><strong>示例 1:</strong></p><pre><code>输入: root = [3,1,4,null,2], k = 1   3  / \ 1   4  \   2输出: 4</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: root = [5,3,6,2,4,null,null,1], k = 3       5      / \     3   6    / \   2   4  / 1输出: 4</code></pre><p><strong>限制：</strong></p><p>1 ≤ k ≤ 二叉搜索树元素个数</p><h4 id="Solution-中序遍历得到递增序列"><a href="#Solution-中序遍历得到递增序列" class="headerlink" title="Solution - 中序遍历得到递增序列"></a>Solution - 中序遍历得到递增序列</h4><pre><code class="c++">​class Solution {public:    int kthLargest(TreeNode* root, int k)    {        vector&lt;int&gt; temp;        dfs(root, k, temp);        return temp[temp.size() - k];    }    void dfs(TreeNode* root, int k, vector&lt;int&gt;&amp; temp)    {        if (!root)        {            return 0;        }        dfs(root-&gt;left, k, temp);        temp.push_back(root-&gt;val);        dfs(root-&gt;right, k, temp);    }};</code></pre><h4 id="Solution-先右再左的中序遍历-得到的是递减序列"><a href="#Solution-先右再左的中序遍历-得到的是递减序列" class="headerlink" title="Solution - 先右再左的中序遍历 得到的是递减序列!!"></a>Solution - 先右再左的中序遍历 得到的是递减序列!!</h4><pre><code class="c++">class Solution {public:    int result;    int kthLargest(TreeNode* root, int k)    {        dfs(root, k);        return result;    }    void dfs(TreeNode* root, int&amp; k)    {        if (!root)        {            return;        }        dfs(root-&gt;right, k);        if (k == 0)        {            return; // 提前返回这里也非常妙啊        }        if (--k == 0)        {            result = root-&gt;val;        }        dfs(root-&gt;left, k);    }};</code></pre><p>看到题解这句话直接惊呆我了<code>先右再左的中序遍历 得到的是递减序列</code></p><p>还有提前返回的判断</p><h3 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - I. 二叉树的深度</a></h3><p>Difficulty: <strong>简单</strong></p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回它的最大深度 3 。</p><p><strong>提示：</strong></p><ol><li><code>节点总数 &lt;= 10000</code></li></ol><p>注意：本题与主站 104 题相同：</p><h4 id="Solution-bfs-nullptr"><a href="#Solution-bfs-nullptr" class="headerlink" title="Solution - bfs + nullptr"></a>Solution - bfs + nullptr</h4><pre><code class="c++">​class Solution {public:    int maxDepth(TreeNode* root)    {        if (!root)        {            return 0;        }        deque&lt;TreeNode*&gt; nodes;        nodes.push_back(root);        nodes.push_back(nullptr);        int result = 0;        while (!nodes.empty())        {            TreeNode* node = nodes.front();            nodes.pop_front();            if (node == nullptr)            {                if (!nodes.empty())                {                    nodes.push_back(nullptr);                }                result++;                continue;            }            if (node-&gt;left)            {                nodes.push_back(node-&gt;left);            }            if (node-&gt;right)            {                nodes.push_back(node-&gt;right);            }        }        return result;    }};</code></pre><p>第一印象还是使用了nullptr作为层之间的区分, 前面做过类似的第一印象也是nullptr实际上应该用</p><p>for循环更加好 提前取出循环次数, 这样就算更改deque的size也不影响循环次数了</p><pre><code class="c++">class Solution {public:    int maxDepth(TreeNode* root)    {        if (!root)        {            return 0;        }        deque&lt;TreeNode*&gt; nodes;        nodes.push_back(root);        int result = 0;        while (!nodes.empty())        {            result++;            const int SS = nodes.size();            for (int i = 0; i &lt; SS; ++i)            {                TreeNode* node = nodes.front();                nodes.pop_front();                if (node-&gt;left)                {                    nodes.push_back(node-&gt;left);                }                if (node-&gt;right)                {                    nodes.push_back(node-&gt;right);                }            }        }        return result;    }};</code></pre><h4 id="dfs-第一个想出来的竟然不是这个…"><a href="#dfs-第一个想出来的竟然不是这个…" class="headerlink" title="dfs 第一个想出来的竟然不是这个…"></a>dfs 第一个想出来的竟然不是这个…</h4><pre><code class="c++">class Solution {public:    int maxDepth(TreeNode* root)    {        if (!root)        {            return 0;        }        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;    }};</code></pre><h3 id="剑指-Offer-55-II-平衡二叉树"><a href="#剑指-Offer-55-II-平衡二叉树" class="headerlink" title="剑指 Offer 55 - II. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 55 - II. 平衡二叉树</a></h3><p>Difficulty: <strong>简单</strong></p><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><strong>示例 1:</strong></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回 <code>true</code> 。  </p><p><strong>示例 2:</strong></p><p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p><pre><code>       1      / \     2   2    / \   3   3  / \ 4   4</code></pre><p>返回 <code>false</code> 。</p><p><strong>限制：</strong></p><ul><li><code>0 &lt;= 树的结点个数 &lt;= 10000</code></li></ul><p>注意：本题与主站 110 题相同：</p><h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    bool isBalanced(TreeNode* root)    {        return depth(root) != -1;    }    int depth(TreeNode* node)    {        if (!node)        {            return 0;        }        int left = depth(node-&gt;left);        if (left == -1)        {            return -1;        }        int right = depth(node-&gt;right);        if (right == -1)        {            return -1;        }        if (abs(left - right) &gt; 1)        {            return -1;        }        return max(left, right) + 1;    }};</code></pre><h3 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - I. 数组中数字出现的次数</a></h3><p>Difficulty: <strong>中等</strong></p><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [4,1,4,6]输出：[1,6] 或 [6,1]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1,2,10,4,1,4,3,3]输出：[2,10] 或 [10,2]</code></pre><p><strong>限制：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 10000</code></li></ul><h4 id="Solution-xor-以及xor分组"><a href="#Solution-xor-以及xor分组" class="headerlink" title="Solution - xor 以及xor分组"></a>Solution - xor 以及xor分组</h4><pre><code class="c++">​class Solution {public:    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums)    {        int xor_result = 0;        for (int num : nums)        {            xor_result ^= num;        }        int bit_1 = 1;        while ((xor_result &amp; 1) == 0)        {            xor_result = xor_result &gt;&gt; 1;            bit_1++;        }        int xor_1 = 0;        int xor_2 = 0;        bit_1--;        for (int num : nums)        {            int bit_1_temp = (num &gt;&gt; bit_1) &amp; 1;            if (bit_1_temp == 1)            {                xor_1 ^= num;            }            else            {                xor_2 ^= num;            }        }        return {xor_1, xor_2};    }};</code></pre><p>第一印象看到这个题目想到了用xor运算, 然而却没有想到如何将两个不同的数字分开.</p><p>看了题解发现 第一次xor出来的<code>xor_result</code> 如果是<code>11101</code>则说明两个不同的数字的右数第一位不同. 这样通过</p><p>其他数字的最后一位是1还是0就能分成两个数组 然后分别xor</p><pre><code class="c++">class Solution {public:    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums)    {        int xor_result = 0;        for (int num : nums)        {            xor_result ^= num;        }        int bit_1 = 1;        while ((xor_result &amp; bit_1) == 0)        {            bit_1 = bit_1 &lt;&lt; 1; // 通过逻辑左移取位        }        int xor_1 = 0;        int xor_2 = 0;        for (int num : nums)        {            if (num &amp; bit_1) // 这里也变了            {                xor_1 ^= num;            }            else            {                xor_2 ^= num;            }        }        return {xor_1, xor_2};    }};</code></pre><h3 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank" rel="noopener">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h3><p>Difficulty: <strong>中等</strong></p><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [3,4,3,3]输出：4</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [9,1,7,9,7,9,7]输出：1</code></pre><p><strong>限制：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10000</code></li><li><code>1 &lt;= nums[i] &lt; 2^31</code></li></ul><h4 id="Solution-二进制位出现次数-3"><a href="#Solution-二进制位出现次数-3" class="headerlink" title="Solution - 二进制位出现次数 % 3"></a>Solution - 二进制位出现次数 % 3</h4><pre><code class="c++">​class Solution {public:    int singleNumber(vector&lt;int&gt;&amp; nums)    {        int bits[32]{};        for (int num : nums)        {            int index = 0;            while (num != 0)            {                bits[index] += num &amp; 1;                num = num &gt;&gt; 1;                index++;            }        }        int result = 0;        for (int i = 0; i &lt; 32; ++i)        {            result = result &lt;&lt; 1;            result |= bits[31 - i] % 3;        }        return result;    }};</code></pre><h4 id="Solution-状态机"><a href="#Solution-状态机" class="headerlink" title="Solution - 状态机"></a>Solution - 状态机</h4><h3 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 57. 和为s的两个数字</a></h3><p>Difficulty: <strong>简单</strong></p><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [2,7,11,15], target = 9输出：[2,7] 或者 [7,2]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [10,26,30,31,47,60], target = 40输出：[10,30] 或者 [30,10]</code></pre><p><strong>限制：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^6</code></li></ul><h4 id="Solution-双指针-O-n-O-1"><a href="#Solution-双指针-O-n-O-1" class="headerlink" title="Solution - 双指针 O(n) O(1)"></a>Solution - 双指针 O(n) O(1)</h4><pre><code class="c++">​class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)     {        int le = 0;        int ri = nums.size() - 1;        while (le &lt; ri)        {            int sum = nums[le] + nums[ri];            if (sum == target)            {                return {nums[le], nums[ri]};            }            else if (sum &gt; target)            {                ri--;            }            else            {                le++;            }        }        return {0, 0};    }};</code></pre><h4 id="Solution-如果题目是无序数组-用Hash表-O-n-O-n"><a href="#Solution-如果题目是无序数组-用Hash表-O-n-O-n" class="headerlink" title="Solution - 如果题目是无序数组 用Hash表 O(n) O(n)"></a>Solution - 如果题目是无序数组 用Hash表 O(n) O(n)</h4><pre><code class="c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target)     {        unordered_set&lt;int&gt; set;        for (int num : nums)        {            int need = target - num;            auto iter = set.find(need);            if (iter == set.end())            {                set.insert(num);            }            else            {                return {num, *iter};            }        }        return {0, 0};    }};</code></pre><h3 id="剑指-Offer-57-II-和为s的连续正数序列"><a href="#剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="剑指 Offer 57 - II. 和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 57 - II. 和为s的连续正数序列</a></h3><p>Difficulty: <strong>简单</strong></p><p>输入一个正整数 <code>target</code> ，输出所有和为 <code>target</code> 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><strong>示例 1：</strong></p><pre><code>输入：target = 9输出：[[2,3,4],[4,5]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：target = 15输出：[[1,2,3,4,5],[4,5,6],[7,8]]</code></pre><p><strong>限制：</strong></p><ul><li><code>1 &lt;= target &lt;= 10^5</code></li></ul><h4 id="Solution-滑动窗口"><a href="#Solution-滑动窗口" class="headerlink" title="Solution - 滑动窗口"></a>Solution - 滑动窗口</h4><pre><code class="c++">​class Solution {public:    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target)     {        vector&lt;vector&lt;int&gt;&gt; result;        int begin = 1;        int end = 2;        int sum = 3;        while (end &lt; target &amp;&amp; begin != end)        {            if (sum == target)            {                result.emplace_back();                vector&lt;int&gt;&amp; vec = result.back();                vec.reserve(end - begin + 1);                for (int i = begin; i &lt;= end; ++i)                {                    vec.push_back(i);                }                end++;                sum += end;            }            else if (sum &lt; target)            {                end++;                sum += end;            }            else            {                sum -= begin;                begin++;            }        }        return result;    }};</code></pre><h3 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank" rel="noopener">剑指 Offer 58 - I. 翻转单词顺序</a></h3><p>Difficulty: <strong>简单</strong></p><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p><strong>示例 1：</strong></p><pre><code>输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot;</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: &quot;  hello world!  &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入: &quot;a good   example&quot;输出: &quot;example good a&quot;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</code></pre><p><strong>说明：</strong></p><ul><li>无空格字符构成一个单词。</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><p><strong>注意：</strong>本题与主站 151 题相同：</p><p><strong>注意：</strong>此题对比原题有改动</p><h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    string reverseWords(string s)    {        if (s.empty())        {            return &quot;&quot;;        }        int begin = 0;        int end = s.size();        while (begin &lt; s.size() &amp;&amp; s[begin] == &#39; &#39;)        {            begin++;        }        while (end &gt;= 1 &amp;&amp; s[end - 1] == &#39; &#39;)        {            end--;        }        if (begin &gt;= end)        {            return &quot;&quot;;        }        reverse(s.begin() + begin, s.begin() + end);        int word_begin = begin;        for (int i = begin; i &lt; end; ++i)        {            if (s[i] == &#39; &#39;)            {                int word_end = i;                reverse(s.begin() + word_begin, s.begin() + word_end);                word_begin = i + 1;            }        }        reverse(s.begin() + word_begin, s.begin() + end);        string result;        result.reserve(end - begin);        for (int i = begin; i &lt; end; ++i)        {            if (s[i] == &#39; &#39;)            {                if (result[result.size() - 1] != &#39; &#39;)                {                    result.append(1, &#39; &#39;);                }            }            else            {                result.append(1, s[i]);            }        }        return result;    }};</code></pre><p>我用的解法是先翻转整个字符串 然后再把单词翻转过来 这样组成结果</p><p>实际上可以直接从尾部遍历, 然后一个单词一个单词的拼接出结果</p><pre><code class="c++">class Solution {public:    string reverseWords(string s)    {        int begin = 0;        int end = s.size();        while (begin &lt; s.size() &amp;&amp; s[begin] == &#39; &#39;)        {            begin++;        }        while (end &gt;= 1 &amp;&amp; s[end - 1] == &#39; &#39;)        {            end--;        }        if (begin &gt;= end)        {            return &quot;&quot;;        }        string result;        result.reserve(end - begin);        int i = end - 1;        int j = end;        while (i &gt;= begin)        {            while (i &gt;= begin &amp;&amp; s[i] != &#39; &#39;)            {                i--;            }            result.append(s.begin() + i + 1, s.begin() + j);            result.append(1, &#39; &#39;); // 注意这里 第一个参数数量 第二个是字符 反过来也能运行 但是结果出错            while (i &gt;= begin &amp;&amp; s[i] == &#39; &#39;)            {                i--;            }            j = i + 1;        }        return result.substr(0, result.size() - 1);    }};</code></pre><h3 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - I. 滑动窗口的最大值</a></h3><p>Difficulty: <strong>简单</strong></p><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p><strong>示例:</strong></p><pre><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释:   滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7</code></pre><p><strong>提示：</strong></p><p>你可以假设 <em>k</em> 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><p>注意：本题与主站 239 题相同：</p><h4 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k)    {        if (nums.empty())        {            return {};        }        vector&lt;int&gt; result;        result.reserve(nums.size() - k + 1);        int temp_i = 0;        for (int i = 1; i &lt; k; ++i)        {            if (nums[i] &gt; nums[temp_i])            {                temp_i = i;            }        }        result.push_back(nums[temp_i]);        int left = 1;        int right = k;        while (right &lt; nums.size())        {            if (left &gt; temp_i)            {                temp_i = left;                for (int j = left + 1; j &lt;= right; ++j)                {                    if (nums[j] &gt; nums[temp_i])                    {                        temp_i = j;                    }                }            }            else            {                if (nums[right] &gt; nums[temp_i])                {                    temp_i = right;                }            }            result.push_back(nums[temp_i]);            left++;            right++;        }        return result;    }};</code></pre><p>实际不用在将最大元素移出时进行遍历,  可以采用如下方式, 添加一个deque来解决. 这样能保证获取最大元素为O(1)</p><pre><code class="c++">class Solution {public:    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k)    {        if (nums.empty())        {            return {};        }        vector&lt;int&gt; result;        result.reserve(nums.size() - k + 1);        deque&lt;int&gt; window;        for (int i = 0; i &lt; k; ++i)        {            while (!window.empty() &amp;&amp; nums[window.back()] &lt; nums[i])            {                window.pop_back();            }            window.push_back(i);        }        result.push_back(nums[window.front()]);        for (int i = k; i &lt; nums.size(); ++i)        {            if (i - k + 1 &gt; window.front()) // 移除已经滑动出去的值            {                window.pop_front();            }            while (!window.empty() &amp;&amp; nums[window.back()] &lt; nums[i]) // 每次添加元素前将小于其的元素移除 保证队列内有序            {                window.pop_back();            }            window.push_back(i);            result.push_back(nums[window.front()]);        }        return result;    }};</code></pre><h3 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">剑指 Offer 59 - II. 队列的最大值</a></h3><p>Difficulty: <strong>中等</strong></p><p>请定义一个队列并实现函数 <code>max_value</code> 得到队列里的最大值，要求函数<code>max_value</code>、<code>push_back</code> 和 <code>pop_front</code> 的<strong>均摊</strong>时间复杂度都是O(1)。</p><p>若队列为空，<code>pop_front</code> 和 <code>max_value</code> 需要返回 -1</p><p><strong>示例 1：</strong></p><pre><code>输入: [&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[1],[2],[],[],[]]输出: [null,null,null,2,1,2]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: [&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;][[],[],[]]输出: [null,-1,-1]</code></pre><p><strong>限制：</strong></p><ul><li><code>1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000</code></li><li><code>1 &lt;= value &lt;= 10^5</code></li></ul><h4 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h4><p>鉴于上一题所以这一题一开始就想的这种方法, 结果有个地方开始没转过来</p><p>如果压入123 那么maxs里面只会保留3 不管是否pop_front掉1和2 最大值只会是3, pop_front掉于最大值前面压入的数不会影响最大值</p><pre><code class="c++">​class MaxQueue {public:    MaxQueue()    {    }    int max_value()    {        return maxs.empty() ? -1 : maxs.front();    }    void push_back(int value)    {        nums.push(value);        while (!maxs.empty() &amp;&amp; maxs.back() &lt; value)        {            maxs.pop_back();        }        maxs.push_back(value);    }    int pop_front()    {        if (nums.empty())        {            return -1;        }        int ret = nums.front();        nums.pop();        if (maxs.front() == ret)        {            maxs.pop_front();        }        return ret;    }    queue&lt;int&gt; nums;    deque&lt;int&gt; maxs;};</code></pre><h3 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 60. n个骰子的点数</a></h3><p>Difficulty: <strong>中等</strong></p><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><strong>示例 1:</strong></p><pre><code>输入: 1输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: 2输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</code></pre><p><strong>限制：</strong></p><p><code>1 &lt;= n &lt;= 11</code></p><h4 id="Solution-暴力法-1"><a href="#Solution-暴力法-1" class="headerlink" title="Solution - 暴力法"></a>Solution - 暴力法</h4><pre><code class="c++">​class Solution {public:    vector&lt;int&gt; counter;    int n_back;    void dfs(int n, int sum)    {        if (n == 0)        {            counter[sum - n_back]++;            return;        }        for (int i = 1; i &lt;= 6; ++i)        {            dfs(n - 1, sum + i);        }    }    vector&lt;double&gt; dicesProbability(int n)     {        n_back = n;        counter.resize(n * 6 - n + 1);        dfs(n, 0);        double sum_count = pow(6, n);        vector&lt;double&gt; result;        result.resize(n *  6 - n + 1);        for (int i = 0; i &lt; n * 6 - n + 1; ++i)        {            result[i] = counter[i] / sum_count;        }        return result;    }};</code></pre><p>每个骰子都可能是1-6 将骰子掷完就能得到结果</p><h4 id="Solution-动态规划"><a href="#Solution-动态规划" class="headerlink" title="Solution - 动态规划"></a>Solution - 动态规划</h4><pre><code class="c++">​class Solution {public:    vector&lt;double&gt; dicesProbability(int n)     {        vector&lt;int&gt; vec1(n * 6 + 1, 0);        vector&lt;int&gt; vec2(n * 6 + 1, 0);        for (int i = 1; i &lt;= 6; ++i) // n == 1时 是 1 1 1 1 1 1        {            vec1[i] = 1;        }        for (int i = 2; i &lt;= n; ++i)        {            for (int j = 0; j &lt; i; ++j)            {                vec2[j] = 0;            }            for (int j = i; j &lt;= i * 6; ++j)            {                vec2[j] = 0;                for (int k = 1; j &gt;= k &amp;&amp; k &lt;= 6; ++k)                {                    vec2[j] += vec1[j - k];                }            }            vec1.swap(vec2);        }        double sum = pow(6, n);        vector&lt;double&gt; ret;        ret.reserve(n * 6 - n + 1);        for (int i = n; i &lt;= n * 6; ++i)        {            ret.push_back(vec1[i] / sum);        }        return ret;    }};</code></pre><p>当投掷n个骰子的时候出现总和为m  那么 <code>x[n][m] = x[n-1][m-1] + x[n-1][m-2] + x[n-1][m-3] + x[n-1][m-4] + x[n-1][m-5] + x[n-1][m-6]</code></p><p>这样每计算n个骰子的时候只需要第n-1轮的结果 可以使用两个数组, 计算完第n轮后将这个数组swap到”上一轮数组”用于计算n+1轮</p><h3 id="剑指-Offer-61-扑克牌中的顺子"><a href="#剑指-Offer-61-扑克牌中的顺子" class="headerlink" title="剑指 Offer 61. 扑克牌中的顺子"></a><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank" rel="noopener">剑指 Offer 61. 扑克牌中的顺子</a></h3><p>Difficulty: <strong>简单</strong></p><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p><strong>示例 1:</strong></p><pre><code>输入: [1,2,3,4,5]输出: True</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [0,0,1,2,5]输出: True</code></pre><p><strong>限制：</strong></p><p>数组长度为 5 </p><p>数组的数取值为 [0, 13] .</p><h4 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    bool isStraight(vector&lt;int&gt;&amp; nums)    {        vector&lt;int&gt; vec(13, 0);        int left_sub = vec.size();        int zero_count = 0;        for (int num : nums)        {            if (num == 0)            {                zero_count++; // 统计0的数量            }            else if (vec[num - 1] == 0)            {                vec[num - 1] = 1; // 标记出现的非0卡牌                left_sub = min(left_sub, num - 1); // 更新第一张非0卡牌的开始位置            }            else            {                return false; // 存在重复的卡牌            }        }        int right_sub = left_sub;        while (right_sub &lt; vec.size() &amp;&amp; (vec[right_sub] == 1 || zero_count &gt; 0))        {            if (vec[right_sub] == 0) // 为0表示没有这张卡 需要消耗一张0来补齐            {                zero_count--;            }            right_sub++;        }        return right_sub - left_sub + zero_count == nums.size(); // 输入数据的长度 = 顺子的长度(含补齐) + 剩余下的0    }};</code></pre><h3 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank" rel="noopener">剑指 Offer 63. 股票的最大利润</a></h3><p>Difficulty: <strong>中等</strong></p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><p><strong>示例 1:</strong></p><pre><code>输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre><p><strong>限制：</strong></p><p><code>0 &lt;= 数组长度 &lt;= 10^5</code></p><p><strong>注意：</strong>本题与主站 121 题相同：</p><h4 id="Solution-动态规划-1"><a href="#Solution-动态规划-1" class="headerlink" title="Solution - 动态规划"></a>Solution - 动态规划</h4><pre><code class="c++">​class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices)    {        int buy_price = INT_MAX;        int ans = 0;        for (int curr_price : prices)        {            if (curr_price &gt; buy_price)            {                // try sell                ans = max(ans, curr_price - buy_price); // 当前价格大于卖出价格尝试卖出            }            else if (curr_price &lt; buy_price)            {                // buy this                buy_price = curr_price; // 当前价格小于买入价格 尝试改为当前价格买入            }        }        return ans;    }};</code></pre><h3 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">剑指 Offer 64. 求1+2+…+n</a></h3><p>Difficulty: <strong>中等</strong></p><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p><strong>示例 1：</strong></p><pre><code>输入: n = 3输出: 6</code></pre><p><strong>示例 2：</strong></p><pre><code>输入: n = 9输出: 45</code></pre><p><strong>限制：</strong></p><ul><li><code>1 &lt;= n &lt;= 10000</code></li></ul><h4 id="Solution-sizeof代替乘法-短路运算控制返回"><a href="#Solution-sizeof代替乘法-短路运算控制返回" class="headerlink" title="Solution - sizeof代替乘法 + 短路运算控制返回"></a>Solution - sizeof代替乘法 + 短路运算控制返回</h4><pre><code class="c++">​class Solution {public:    // int sumNums(int n)    // {    //     char a[n][n + 1];    //     return (sizeof a) &gt;&gt; 1;    // }    int sumNums(int n)    {        n &gt; 1 &amp;&amp; (n += sumNums(n - 1)); // 短路运算右边对n进行赋值        return n;    }};</code></pre><h3 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">剑指 Offer 65. 不用加减乘除做加法</a></h3><p>Difficulty: <strong>简单</strong></p><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><p><strong>示例:</strong></p><pre><code>输入: a = 1, b = 1输出: 2</code></pre><p><strong>提示：</strong></p><ul><li><code>a</code>, <code>b</code> 均可能是负数或 0</li><li>结果不会溢出 32 位整数</li></ul><h4 id="Solution-a-b-x-进位信息-使用-amp-lt-lt-1-y-本位信息-使用-xor"><a href="#Solution-a-b-x-进位信息-使用-amp-lt-lt-1-y-本位信息-使用-xor" class="headerlink" title="Solution a + b = x(进位信息 使用 &amp; &lt;&lt; 1) + y(本位信息 使用 xor)"></a>Solution a + b = x(进位信息 使用 &amp; &lt;&lt; 1) + y(本位信息 使用 xor)</h4><pre><code class="c++">​class Solution {public:    int add(int a, int b)    {        while (b != 0)        {            int c = (a &amp; b) &lt;&lt; 1; // 进位信息  1 + 1 = 10 由于1&amp;1=1所以需要 &lt;&lt;            a ^= b; // 本位信息 0 + 0 = 0  1 + 0 = 1 0 + 1 = 0 1 + 1 = 0            b = c; // a + b = x1(进位) + y1(本位) = x2(进位) + y2(本位) .... + 到进位为0 这样就是结果了 0 + x = x;        } // 已知a+b = 进位+本位 而进位+本位也是两个数字相加 所以可以连续调用公式 直到进位为0 本位就是结果        return a;    }};</code></pre><h3 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</a></h3><p>Difficulty: <strong>简单</strong></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt=""></p><p><strong>示例 1:</strong></p><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><p>注意：本题与主站 235 题相同：</p><h4 id="Solution-读题-利用好每一个条件"><a href="#Solution-读题-利用好每一个条件" class="headerlink" title="Solution - 读题 利用好每一个条件"></a>Solution - 读题 利用好每一个条件</h4><pre><code class="c++">​/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)    {        if (!root)        {            return nullptr;        }        if (p-&gt;val &gt; q-&gt;val)        {            swap(p, q);        }        while (true)        {            if (root-&gt;val &lt; p-&gt;val)            {                root = root-&gt;right;            }            else if (root-&gt;val &gt; q-&gt;val)            {                root = root-&gt;left;            }            else            {                break;            }        }        return root;    }};</code></pre><p>我第一次写这个题目没有用上二叉搜索树这个条件, 把下一个题目二叉树给写出来了….</p><p>没利用好题目, 没读好题 我有罪</p><p>这个题目利用的是二叉搜索树 如果两个数都小于根节点 则位于根节点的左子树 两个都大于则位于根节点的右子树</p><p>如果一个大于一个小于说明位于左右子树则当前节点即为答案. 通过保证p的值小于q可以简化以上的判断.  如果最小的p都大于根节点则较大的q也一定大于</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>void*|function|any|optional|variant, How when and why</title>
      <link href="/2021/02/CPP-stdany,%20How%20when%20and%20why/"/>
      <url>/2021/02/CPP-stdany,%20How%20when%20and%20why/</url>
      
        <content type="html"><![CDATA[<p>C++17引入的<code>std::any</code>挺想用的, 毕竟要学会使用modern c++.</p><p>之前都是通过<code>void*</code>来实现相关的功能, 这次看看<code>std::any</code>的怎么使用何时使用和为何使用</p><p>参考文章 </p><ol><li><a href="https://devblogs.microsoft.com/cppblog/stdany-how-when-and-why/" target="_blank" rel="noopener">std::any: How, when, and why</a></li><li><a href="https://devblogs.microsoft.com/cppblog/stdoptional-how-when-and-why/" target="_blank" rel="noopener">std::optional: How, when, and why</a></li><li><a href="https://zh.cppreference.com/w/cpp/utility/variant" target="_blank" rel="noopener">std::variant</a></li></ol><h1 id="void"><a href="#void" class="headerlink" title="void*"></a>void*</h1><p>从C而来的<code>void*</code>可以用来存储任意参数的地址, 在Linux的系统Api上有相当部分的Api使用了<code>void*</code>参数. </p><p>常用之一就是<code>pthread_create</code>.</p><ol><li>将<code>void*</code>转换回原来的类型会由于缺少类型信息来提供安全机制, 一旦转换成了错误的类型 极可能程序直接崩溃</li><li>需要自己管理生命周期 (可以通过智能指针解决这个问题)</li><li>无法进行高效的拷贝, 你需要将其转换为原始类型才能进行深拷贝 否则只能简单的拷贝下指针的地址 因为你不知道指针指向内存块的长度</li></ol><h1 id="any"><a href="#any" class="headerlink" title="any"></a>any</h1><p>相对于void* 解决了其三个缺点. 当然对于将会绑定的类型不确定的话使用any更好,这点消耗是值得的. 如果对于确定类型使用则可能会造成不必要的消耗</p><pre><code class="c++">#include &lt;cassert&gt;#include &lt;any&gt;#include &lt;iostream&gt;int main(){    std::any a;    std::any b = 648;    assert(!a.has_value());    assert(b.type() == typeid(int));    try    {        std::any_cast&lt;float&gt;(b);    }    catch(const std::exception&amp; ex)    {        std::cout &lt;&lt; ex.what(); // bad any_cast    }    auto ptra = std::any_cast&lt;int&gt;(&amp;a); // 为空或者类型不匹配返回nullptr    assert(!ptra);    auto ptrb = std::any_cast&lt;int&gt;(&amp;b);    assert(ptrb);    *ptrb = 328;    return 0;}</code></pre><h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><p>可用于存储函数, 相对于使用函数指针 function调用成员函数更加方便</p><h1 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h1><p>用于解决可选的参数传入和可选的返回值输出</p><pre><code class="c++">std::optional&lt;std::string&gt; Foo(bool b){    if (b)    {        return &quot;123456&quot;;    }    else    {        return {};    }}int main(){    if (!Foo(false).has_value())    {        std::cout &lt;&lt; &quot;no value&quot; &lt;&lt; std::endl; // no value    }    std::cout &lt;&lt; Foo(false).value_or(&quot;(null)&quot;); // (null)    std::cout &lt;&lt; Foo(true).value_or(&quot;no value&quot;); // 123456}</code></pre><h1 id="variant"><a href="#variant" class="headerlink" title="variant"></a>variant</h1><p>提供一个已知类型的集合类型</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode</title>
      <link href="/2021/02/%E7%AE%97%E6%B3%95-leetcode/"/>
      <url>/2021/02/%E7%AE%97%E6%B3%95-leetcode/</url>
      
        <content type="html"><![CDATA[<h3 id="N3-无重复字符的最长子串"><a href="#N3-无重复字符的最长子串" class="headerlink" title="N3.无重复字符的最长子串"></a>N3.无重复字符的最长子串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p>示例 2:</p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p>示例 3:</p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:int lengthOfLongestSubstring(string s){    bool char_flag[128]; // 记录字符是否出现过    int char_sub[128]; // 记录字符下标    memset(char_flag, false, sizeof char_flag);    int max_result = 0;    int begin_sub = 0;    int sub = 0;    while (sub &lt; s.length())    {        char current_char = s[sub];        if (char_flag[current_char])        {            if (sub - begin_sub &gt; max_result)            {                max_result = sub - begin_sub;            }            for (int i = begin_sub; i &lt; char_sub[current_char]; ++i)            {                char_flag[s[i]] = false;            }            begin_sub = char_sub[current_char] + 1;            char_sub[current_char] = sub;        }        else        {            char_sub[current_char] = sub;            char_flag[current_char] = true;        }        sub++;        if (sub == s.length())        {            if (sub - begin_sub &gt; max_result)            {                max_result = sub - begin_sub;            }        }    }    return max_result;}};</code></pre><p>思路是按顺序读取char, 如果没有出现过则标记出现记录下标.</p><p>如果出现了则用当前下标减去开始下标判断是否更长来记录, 同时更新开始下标为重复字符的下标后一个字符下标.</p><p>移动开始下标后 需要取消 新开始标记和旧开始标记之前的char标记</p><h4 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h4><pre><code class="c++">class Solution {public:    int lengthOfLongestSubstring(string s)    {        int heap[128] = {0};        int res = 0;        for(int i = 0, j = 0; j &lt; s.size(); ++j)        {            heap[s[j]]++; // 标记字符出现            while(heap[s[j]] &gt; 1) // 再次出现            {              /*              开始符号标记下标 向前滑动 1 将开始下标的字符滑动出去              如果滑出去的字符是本次遇到的重复字符 则继续 否则一直滑动到重复字符位置              */                heap[s[i]]--;                i++;            }            res = max(res, j - i + 1);        }        return res;    }};</code></pre><p>首先看上去 代码就非常的短 我的写了40行而这个仅有10行</p><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>我的虽然不是一次滑动一个字符 而是滑动一步到位. 但是仍需要一个for循环来去掉滑出的字符. 所以同样例代码思想.</p><p>所以没有必要一次滑动到位, 反正for循环需要执行就在for之中慢慢滑动. <code>这样可以省去记录字符出现的下标</code></p><p>我字符出现记录使用的bool数组然而使用<code>int数组却能包含更多的信息</code>.</p><p>我原版代码需要额外判定一次是否到了尾部, 当最后一个字符没有重复的时候 循环就结束了.</p><h3 id="N34-在排序数组中查找元素的第一个和最后一个位置"><a href="#N34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="N34.在排序数组中查找元素的第一个和最后一个位置"></a>N34.在排序数组中查找元素的第一个和最后一个位置</h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1:</p><pre><code>输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4]</code></pre><p>示例 2:</p><pre><code>输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1]</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target)    {        int left = 0;        int right = nums.size();        while (left &lt; right)        {            int sub = (right + left) &gt;&gt; 1;            if (target == nums[sub])            {                int l_sub, r_sub;                for (l_sub = sub - 1; l_sub &gt;=0 &amp;&amp; nums[l_sub] == target; --l_sub)                {                }                for (r_sub = sub + 1; r_sub &lt;= nums.size() - 1 &amp;&amp; nums[r_sub] == target; ++r_sub)                {                }                return {l_sub + 1, r_sub - 1};            }            else if (target &lt; nums[sub])            {                right = sub;            }            else            {                left = sub + 1;            }        }        return {-1, -1};    }};</code></pre><p>思路使用二分搜索找到目标元素 然后想左右扩散寻找边界</p><h3 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h3><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><pre><code>输入: nums = [5,7,7,8,8,10], target = 8输出: 2</code></pre><p>示例 2:</p><pre><code>输入: nums = [5,7,7,8,8,10], target = 6输出: 0</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="代码1-2"><a href="#代码1-2" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:    int search(vector&lt;int&gt;&amp; nums, int target)    {        int left = 0;        int right = nums.size();        while (left &lt; right)        {            int sub = (right + left) &gt;&gt; 1;            if (target == nums[sub])            {                int result = 1;                for (int l_sub = sub - 1; l_sub &gt;=0 &amp;&amp; nums[l_sub] == target; --l_sub)                {                    ++result;                }                for (int r_sub = sub + 1; r_sub &lt;= nums.size() - 1 &amp;&amp; nums[r_sub] == target; ++r_sub)                {                    ++result;                }                return result;            }            else if (target &lt; nums[sub])            {                right = sub;            }            else            {                left = sub + 1;            }        }        return 0;    }};</code></pre><p>思路同上, 返回值不同</p><h3 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例 1：</p><pre><code>输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><p>示例 2：</p><pre><code>输入：lists = []输出：[]</code></pre><p>示例 3：</p><pre><code>输入：lists = [[]]输出：[]</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="代码1-3"><a href="#代码1-3" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public:    ListNode* Merge(const vector&lt;ListNode*&gt;&amp; lists, int left, int right)    {        if (right - left &lt;= 1)        {            return lists[left];        }        else if (right - left == 2)        {            ListNode* node1 = lists[left];            ListNode* node2 = lists[left + 1];            if (!node1)            {                return node2;            }            else if (!node2)            {                return node1;            }            ListNode* head = new ListNode;            ListNode* node = head;            if (node1-&gt;val &lt;= node2-&gt;val)            {                head-&gt;val = node1-&gt;val;                node1 = node1-&gt;next;            }            else            {                head-&gt;val = node2-&gt;val;                node2 = node2-&gt;next;            }            while (node1 != nullptr || node2 != nullptr)            {                if (!node1 || (node2 &amp;&amp; node2-&gt;val &lt;= node1-&gt;val))                {                    node-&gt;next = new ListNode(node2-&gt;val);                    node = node-&gt;next;                    node2 = node2-&gt;next;                }                else if (node2 == nullptr || (node1 &amp;&amp; node1-&gt;val &lt; node2-&gt;val))                {                    node-&gt;next = new ListNode(node1-&gt;val);                    node = node-&gt;next;                    node1 = node1-&gt;next;                }            }            return head;        }        else        {            int mid = (left + right) &gt;&gt; 1;            ListNode* node1 = Merge(lists, left, mid);            ListNode* node2 = Merge(lists, mid, right);            ListNode* result = Merge({ node1, node2 }, 0, 2);            return result;        }    }    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)    {        if (lists.empty())        {            return nullptr;        }        return Merge(lists, 0, lists.size());    }};</code></pre><p>思路的话比较简单 使用分治和递归. 将若干个<code>ListNode*</code>的合并的最终分解为 两两合并. 然后将合并结果再两两合并</p><p>第一版代码 我甚至没有delete临时用的指针… 有内存泄漏的问题  最终提交后 <code>Time-33%</code>…. 好吧</p><p>仔细想了下部分地方不需要这么多的拷贝 直接复用已有的<code>ListNode*</code>就行</p><h4 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h4><pre><code class="c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public:    ListNode* Merge(const vector&lt;ListNode*&gt;&amp; lists, int left, int right)    {        if (right - left &lt;= 1)        {            return lists[left];        }        else if (right - left == 2) // 主要改动从这里开始        {            ListNode* node1 = lists[left];            ListNode* node2 = lists[left + 1];            if (!node1)            {                return node2;            }            else if (!node2)            {                return node1;            }            ListNode* head;            if (node1-&gt;val &lt;= node2-&gt;val)            {                head = node1;                node1 = node1-&gt;next;            }            else            {                head = node2;                node2 = node2-&gt;next;            }            ListNode* node = head;            while (node1 != nullptr || node2 != nullptr)            {                if (!node1) // 同时在`node1`或`node2`为空的时候 直接append 避免额外的扫描                {                    node-&gt;next = node2;                    break;                }                else if (!node2)                {                    node-&gt;next = node1;                    break;                }                else                {                    if (node2-&gt;val &lt;= node1-&gt;val)                    {                        node-&gt;next = node2;                        node = node-&gt;next;                        node2 = node2-&gt;next;                    }                    else                    {                        node-&gt;next = node1;                        node = node-&gt;next;                        node1 = node1-&gt;next;                    }                }            }            return head;        }        else        {            int mid = (left + right) &gt;&gt; 1;            ListNode* node1 = Merge(lists, left, mid);            ListNode* node2 = Merge(lists, mid, right);            ListNode* result = Merge({ node1, node2 }, 0, 2);            return result;        }    }    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists)    {        if (lists.empty())        {            return nullptr;        }        return Merge(lists, 0, lists.size());    }};</code></pre><p>这次改动去掉了所有的new 因为直接复用已有的ListNode即可 同时在<code>node1</code>或<code>node2</code>为空的时候 直接append 避免额外的扫描</p><p>从<code>Time-33%</code>变化到了<code>Time-67%</code>  </p><h4 id="样例代码-1"><a href="#样例代码-1" class="headerlink" title="样例代码"></a>样例代码</h4><pre><code class="c++">class Solution {public:    // 合并两个有序链表    ListNode* merge(ListNode* p1, ListNode* p2){ // 合并        if(!p1) return p2;        if(!p2) return p1;        if(p1-&gt;val &lt;= p2-&gt;val){            p1-&gt;next = merge(p1-&gt;next, p2);            return p1;        }else{            p2-&gt;next = merge(p1, p2-&gt;next);            return p2;        }    }    ListNode* merge(vector&lt;ListNode*&gt;&amp; lists, int start, int end){ // 负责拆分和合并        if(start == end) return lists[start];        int mid = (start + end) / 2;        ListNode* l1 = merge(lists, start, mid);        ListNode* l2 = merge(lists, mid+1, end);        return merge(l1, l2);    }    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {        if(lists.size() == 0) return nullptr;        return merge(lists, 0, lists.size()-1);    }};</code></pre><p>这代码太精简了…</p><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><pre><code>输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。</code></pre><p>示例 2：</p><pre><code>输入: &quot;cbbd&quot;输出: &quot;bb&quot;</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="代码1-中心扩散法"><a href="#代码1-中心扩散法" class="headerlink" title="代码1 - 中心扩散法"></a>代码1 - 中心扩散法</h4><pre><code class="c++">class Solution {public:    string longestPalindrome(string s)    {        /* 开头老套路 先处理了最简单的输入*/        if (s.length() &lt;= 1)        {            return s;        }        /* 记录最大长度*/        int max_len = 0;        /* 记录最大长度子串的开始下标 用于return时的substr 解决拷贝问题*/        int result_begin_sub = 0;        int i = 0;        while (i &lt; s.length())        {            int l_begin = i, r_begin = i;            /* 从当前下标开始 找到最长的相同字符子串*/            /* lbegin指向此子串的开始字符 rbegin指向结尾字符*/            while (r_begin &lt; s.length() - 1 &amp;&amp; s[r_begin + 1] == s[i])            {                r_begin++;            }            /* 更新下标 减少循环次数*/            i = r_begin + 1;            /* 向左右两侧遍历 相同字符则 向左移动lbegin 向右移动rbegin*/            do            {                l_begin--;                r_begin++;            }            while (l_begin &gt;=0 &amp;&amp; r_begin &lt; s.length() &amp;&amp; s[l_begin] == s[r_begin]);            /* 更新最大长度*/            int len = r_begin - l_begin - 1;            if (len &gt; max_len)            {                max_len = len;                result_begin_sub = l_begin + 1;            }        }        return s.substr(result_begin_sub, max_len);    }};</code></pre><p>遍历字符串 从当前循环开始下标找到最长的相同字符子串 如a 或 bb 或 ccc</p><p>然后向左右两侧遍历 如果左右字符相同 继续遍历 最终得到两个下标</p><p>左下标指向当前最大回文子串的左边一个字符 右下标指向右边一个字符</p><p>这样就得到了子串的开始下标和长度 更新最大长度 继续遍历</p><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><p>示例 1:</p><pre><code>输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3  解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</code></pre><p>示例 2:</p><pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</code></pre><p>示例 3:</p><pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0。</code></pre><p>提示:</p><pre><code>1 &lt;= text1.length &lt;= 10001 &lt;= text2.length &lt;= 1000输入的字符串只含有小写英文字符。</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="代码1-4"><a href="#代码1-4" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">    int longest(const std::string&amp; text1, const std::string&amp; text2,         int text1_sub, int text2_sub)    {        if (text1_sub &gt;= text1.length() || text2_sub &gt;= text2.length())        {            return 0;        }        if (text1[text1_sub] == text2[text2_sub])        {            return 1 + longest(text1, text2, text1_sub + 1, text2_sub + 1);        }        else        {            return max(longest(text1, text2, text1_sub + 1, text2_sub),                         longest(text1, text2, text1_sub, text2_sub + 1));        }    }    int longestCommonSubsequence(string text1, string text2)    {        return longest(text1, text2, 0, 0);    }</code></pre><p>最简单的思路 然而会超时</p><h4 id="代码2-动态规划"><a href="#代码2-动态规划" class="headerlink" title="代码2 动态规划"></a>代码2 动态规划</h4><pre><code class="c++">int longestCommonSubsequence(string text1, string text2)    {        int result[1005][1005]{};        for (int i1 = 0; i1 &lt; text1.length(); ++i1)        {            for (int i2 = 0; i2 &lt; text2.length(); ++i2)            {                if (text1[i1] == text2[i2])                {                    result[i1 + 1][i2 + 1] = result[i1][i2] + 1;                }                else                {                    result[i1 + 1][i2 + 1] = max(result[i1][i2 + 1], result[i1 + 1][i2]);                }            }        }        return result[text1.length()][text2.length()];    }</code></pre><p>设text1和text2的解是T</p><ul><li>如果text1和text2的最后两个字符相等, 则T的最后一个字符也是这个字符</li></ul><p>这样 text1和text2分别去掉最后一个字符后, T去掉最后一个字符后的T1 是前面两个新字符串的最长公共子序列</p><ul><li>如果最后两个字符不同, 则T可能是text1去掉最后一个字符后和text2的最长公共子序列 也可能是text2去掉最后一个字符后和text1的最长公共子序列</li></ul><p>这个可以循环下去, 直到最后两个字符相等 转入上方过程</p><p>由于存在多种可能便需要设置result数组存储中间结果<code>result[i][j]</code>是text1前i个字符和text2前j个字符的最长公共子序列长度</p><p>数组填充方式 为上方描述的逆过程. </p><ul><li><p>如果i1 i2所指字符相同 <code>result[i][j]</code>结果是<code>result[i - 1][j - 1] + 1</code><br>表示的是text1前i-1字符和text2前j-1字符最长公共子序列 加上 这个相同的字符 得到前i和前j的最长公共子序列</p></li><li><p>如果所指字符不同则<code>result[i][j]</code>可能是<code>result[i][j - 1]</code> 也可能是<code>result[i][j - 1]</code>取最大值<br>表示的是前ij的最长公共子序列是 text1前i字符和text2前j-1字符最长公共子序列 或者是 前i-1和前j的最长公共子序列</p></li></ul><p>最终得到结果<code>result[text1.length()][text2.length()]</code> 表示前length1和前length2的最长公共子序列</p><h3 id="E53-最大子序和"><a href="#E53-最大子序和" class="headerlink" title="E53.最大子序和"></a>E53.最大子序和</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><pre><code>输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6</code></pre><p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="代码1-5"><a href="#代码1-5" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums)    {        vector&lt;int&gt; b(nums.size());        b[0] = nums[0];        for (int i = 1; i &lt; nums.size(); ++i)        {            if (b[i - 1] &gt; 0)            {                b[i] = b[i - 1] + nums[i];            }            else            {                b[i] = nums[i];            }        }        int result = b[0];        for (int i = 1; i &lt; b.size(); ++i)        {            if (b[i] &gt; result)            {                result = b[i];            }        }        return result;    }};</code></pre><h4 id="代码2-1"><a href="#代码2-1" class="headerlink" title="代码2"></a>代码2</h4><pre><code class="c++">class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums)    {        int numss = nums.size();        int temp = nums[0];        int result = nums[0];        for (int i = 1; i &lt; numss; ++i)        {            temp = temp &gt; 0 ? temp + nums[i] : nums[i];            result = result &gt; temp ? result : temp;        }        return result;    }};</code></pre><p>省去了一个vector 代码看起来也简洁不少</p><h3 id="H51-amp-H52N皇后"><a href="#H51-amp-H52N皇后" class="headerlink" title="H51&amp;H52N皇后"></a>H51&amp;H52N皇后</h3><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png" alt=""></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例：</p><pre><code>输入：4输出：[ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]</code></pre><p>解释: 4 皇后问题存在两个不同的解法。</p><p>提示：</p><ul><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/n-queens" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-queens</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="代码1-6"><a href="#代码1-6" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:    bool Check(int n, vector&lt;string&gt;&amp; temp, int row, int column)    {        for (int c = 0; c &lt; column; ++c)        {            if (temp[row][c] == &#39;Q&#39;)            {                return false;            }        }        for (int r = row - 1, c = column - 1 ; r &gt;= 0 &amp;&amp; c &gt;= 0; --r, --c)        {            if (temp[r][c] == &#39;Q&#39;)            {                return false;            }        }        for (int r = row + 1, c = column - 1 ; r &lt; n &amp;&amp; c &gt;= 0; ++r, --c)        {            if (temp[r][c] == &#39;Q&#39;)            {                return false;            }        }        return true;    }    void Solve(int n, int column, vector&lt;string&gt;&amp; temp, vector&lt;vector&lt;string&gt;&gt;&amp; result)    {        if (column &gt;= n)        {            result.push_back(temp);            return;        }        for (int i = 0; i &lt; n; ++i)        {            temp[i][column] = &#39;Q&#39;;            if (Check(n, temp, i, column))            {                Solve(n, column + 1, temp, result);            }            temp[i][column] = &#39;.&#39;;        }    }    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) // H51 N皇后    {        vector&lt;vector&lt;string&gt;&gt; result;        vector&lt;string&gt; temp(n, string(n, &#39;.&#39;));        Solve(n, 0, temp, result);        return result;    }    int totalNQueens(int n) // H52 N皇后    {        return solveNQueens(n).size();    }};</code></pre><p>不知道第几次做了.. 思路很清晰</p><h3 id="N55-跳跃游戏"><a href="#N55-跳跃游戏" class="headerlink" title="N55.跳跃游戏"></a>N55.跳跃游戏</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p>示例 1:</p><pre><code>输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</code></pre><p>示例 2:</p><pre><code>输入: [3,2,1,0,4]输出: false</code></pre><p>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/jump-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jump-game</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="代码1-7"><a href="#代码1-7" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:    bool canJump(vector&lt;int&gt;&amp; nums)    {        int level = 0;        int numss = nums.size();        while (level &lt; numss)        {            if (nums[level] == 0)            {                int back_level = level - 1;                while (back_level &gt;= 0 &amp;&amp; back_level + nums[back_level] &lt;= level)                {                    back_level--;                }                if (back_level &lt; 0)                {                    break;                }                level = back_level + nums[back_level];            }            else            {                level += nums[level];            }        }        return level + 1 &gt;= numss;    }};</code></pre><p>能跳则跳最大长度, 不能跳则每一回退一个台阶 回退后的台阶必须能够跳到原台阶的后面位置</p><p>如果跳到numss上或者外说明能到, 如果因为回退回到了起点则不能跳过</p><h4 id="代码2-2"><a href="#代码2-2" class="headerlink" title="代码2"></a>代码2</h4><pre><code class="c++">class Solution {public:    bool canJump(vector&lt;int&gt;&amp; nums)    {        int numss = nums.size();        int max_level = 0;        for (int i = 0; i &lt; numss; ++i)        {            if (i &lt;= max_level)            {                max_level = max(max_level, i + nums[i]);                if (max_level &gt;= numss - 1)                {                    return true;                }            }            else            {                return false;            }        }        return false;    }};</code></pre><p>然而真的需要回退吗? 可以遍历nums直接算能到的最大长度. 就算有0存在也不影响最远长度 能跳过0去在遍历到0前 max_level就已经跳过去了</p><h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个字符串 <code>s</code> ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 <code>s</code> 的最大长度为 <code>1000</code> 。</p><p><strong>示例 1:</strong><br>输入:</p><pre><code>&quot;bbbab&quot;</code></pre><p>输出:</p><pre><code>4</code></pre><p>一个可能的最长回文子序列为 “bbbb”。</p><p><strong>示例 2:</strong><br>输入:</p><pre><code>&quot;cbbd&quot;</code></pre><p>输出:</p><pre><code>2</code></pre><p>一个可能的最长回文子序列为 “bb”。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 只包含小写英文字母</li></ul><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">class Solution {public:    int longestPalindromeSubseq(string s)    {        int ws = s.size();        int dp[ws][ws];        memset(dp, 0, sizeof dp);        for (int i = 0; i &lt; ws; ++i)        {            dp[i][i] = 1;        }        for (int i = 1; i &lt; ws; ++i)        {            for (int j = 0; j &lt; ws - i; j += 1)            {                if (s[j] == s[j + i])                {                    dp[j][j + i] = dp[j + 1][j + i - 1] + 2;                }                else                {                    dp[j][j + i] = max(                        dp[j + 1][j + i],                        dp[j][j + i - 1]                    );                }            }        }        return dp[0][ws - 1];    }};</code></pre><h3 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h3><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例 1:</p><pre><code>输入: 123输出: 321</code></pre><p> 示例 2:</p><pre><code>输入: -123输出: -321</code></pre><p>示例 3:</p><pre><code>输入: 120输出: 21</code></pre><p>注意:</p><pre><code>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-integer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="代码1-8"><a href="#代码1-8" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:    int reverse(int x)    {        int result = 0;        while (x != 0)        {            int pop = x % 10;            x /= 10;            if (result &gt; INT_MAX / 10 || (result == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0; // 2^31 - 1 = 2147483647            if (result &lt; INT_MIN / 10 || (result == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; // -2^31 = -2147483648            result = result * 10 + pop;        }        return result;    }};</code></pre><h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p><p>你需要原地修改栈。</p><p>示例1:</p><pre><code>输入：A = [2, 1, 0], B = [], C = []输出：C = [2, 1, 0]</code></pre><p>示例2:</p><pre><code>输入：A = [1, 0], B = [], C = []输出：C = [1, 0]</code></pre><p>提示:</p><pre><code>A中盘子的数目不大于14个。</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/hanota-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hanota-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="代码1-9"><a href="#代码1-9" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:    void hanota(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C)    {        int n = A.size();        move(n, A, B, C);    }    void move(int n, vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C){        if (n == 1)        {            C.push_back(A.back());            A.pop_back();            return;        }        move(n-1, A, C, B);    // 将A上面n-1个通过C移到B        C.push_back(A.back());  // 将A最后一个移到C        A.pop_back();          // 这时，A空了        move(n-1, B, A, C);     // 将B上面n-1个通过空的A移到C    }};</code></pre><h3 id="整数转罗马数字"><a href="#整数转罗马数字" class="headerlink" title="整数转罗马数字"></a>整数转罗马数字</h3><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p><p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p>示例 1:</p><pre><code>输入: 3输出: &quot;III&quot;</code></pre><p>示例 2:</p><pre><code>输入: 4输出: &quot;IV&quot;</code></pre><p>示例 3:</p><pre><code>输入: 9输出: &quot;IX&quot;</code></pre><p>示例 4:</p><pre><code>输入: 58输出: &quot;LVIII&quot;解释: L = 50, V = 5, III = 3.</code></pre><p>示例 5:</p><pre><code>输入: 1994输出: &quot;MCMXCIV&quot;解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="代码1-10"><a href="#代码1-10" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:    string intToRoman(int num)    {        std::string result;        auto p = [&amp;](auto a, auto b)        {            result += a;            num -= b;        };        int time = num / 1000;        for (int i = 0; i &lt; time; ++i)        {            p(&quot;M&quot;, 1000);        }        if (num &gt;= 900)        {            p(&quot;CM&quot;, 900);        }        else if (num &gt;= 500)        {            p(&quot;D&quot;, 500);        }        else if (num &gt;= 400)        {            p(&quot;CD&quot;, 400);        }        time = num / 100;        for (int i = 0; i &lt; time; ++i)        {            p(&quot;C&quot;, 100);        }        if (num &gt;= 90)        {            p(&quot;XC&quot;, 90);        }        else if (num &gt;= 50)        {            p(&quot;L&quot;, 50);        }        else if (num &gt;= 40)        {            p(&quot;XL&quot;, 40);        }        time = num / 10;        for (int i = 0; i &lt; time; ++i)        {            p(&quot;X&quot;, 10);        }        if (num &gt;= 9)        {            p(&quot;IX&quot;, 9);        }        else if (num &gt;= 5)        {            p(&quot;V&quot;, 5);        }        else if (num &gt;= 4)        {            p(&quot;IV&quot;, 4);        }        time = num;        for (int i = 0; i &lt; time; ++i)        {            p(&quot;I&quot;, 1);        }        return result;    }};</code></pre><p>一堆if else 当时看到后第一时间想到的便是这个做法 然而代码太长了. 然而程序中都是重复的逻辑, 看一下样例答案</p><h4 id="代码2-3"><a href="#代码2-3" class="headerlink" title="代码2"></a>代码2</h4><pre><code class="c++">class Solution {public:    string intToRoman(int num) {        int values[]={1000,900,500,400,100,90,50,40,10,9,5,4,1};        string reps[]={&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;};        string res;        for (int i=0; i&lt;13; i++)        {            while (num&gt;=values[i])            {                num -= values[i];                res += reps[i];            }        }        return res;    }};</code></pre><p>同样的逻辑 样例代码却能够使用两个数组来打成….. 太妙了 而且修改起来也比较方便</p><h3 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h3><p>Invert a binary tree.</p><p>Example:</p><pre><code>Input:     4   /   \  2     7 / \   / \1   3 6   9Output:     4   /   \  7     2 / \   / \9   6 3   1</code></pre><p>Trivia:<br>This problem was inspired by this original tweet by Max Howell:</p><p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p><pre><code class="c++">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    TreeNode* invertTree(TreeNode* root)    {        if (!root)        {            return nullptr;        }        TreeNode* temp = root-&gt;left;        root-&gt;left = root-&gt;right;        root-&gt;right = temp;        invertTree(root-&gt;left);        invertTree(root-&gt;right);        return root;    }};</code></pre><h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h3><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><pre><code>你只能使用常量级额外空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</code></pre><p>示例：</p><pre><code>输入：root = [1,2,3,4,5,6,7]输出：[1,#,2,3,#,4,5,6,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</code></pre><p>提示：</p><pre><code>树中节点的数量少于 4096-1000 &lt;= node.val &lt;= 1000</code></pre><pre><code class="c++">/*// Definition for a Node.class Node {public:    int val;    Node* left;    Node* right;    Node* next;    Node() : val(0), left(NULL), right(NULL), next(NULL) {}    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}    Node(int _val, Node* _left, Node* _right, Node* _next)        : val(_val), left(_left), right(_right), next(_next) {}};*/class Solution {public:    Node* connect(Node* root)    {        if (!root)        {            return root;        }        connectTwoNode(root-&gt;left, root-&gt;right);        return root;    }    void connectTwoNode(Node* node1, Node* node2)    {        if (!node1 || !node2)        {            return;        }        node1-&gt;next = node2;        connectTwoNode(node1-&gt;left, node1-&gt;right);        connectTwoNode(node2-&gt;left, node2-&gt;right);        connectTwoNode(node1-&gt;right, node2-&gt;left);    }};</code></pre><h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h3><p>给定一个二叉树，原地将它展开为一个单链表。</p><p>例如，给定二叉树</p><pre><code>    1   / \  2   5 / \   \3   4   6</code></pre><p>将其展开为：</p><pre><code>1 \  2   \    3     \      4       \        5         \          6</code></pre><pre><code class="c++">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public:    void flatten(TreeNode* root)    {        if (!root)        {            return;        }        flatten(root-&gt;left);        flatten(root-&gt;right);        TreeNode* right = root-&gt;right;        root-&gt;right = root-&gt;left;        root-&gt;left = nullptr;        TreeNode* temp = root;        while (temp-&gt;right)        {            temp = temp-&gt;right;        }        temp-&gt;right = right;    }};</code></pre><h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 *<em>key *</em>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>说明：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p><p><strong>示例:</strong></p><pre><code>root = [5,3,6,2,4,null,7]key = 3    5   / \  3   6 / \   \2   4   7给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。    5   / \  4   6 /     \2       7另一个正确答案是 [5,2,6,null,4,null,7]。    5   / \  2   6   \   \    4   7</code></pre><h4 id="代码1-11"><a href="#代码1-11" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public:    int GetMin(TreeNode* root)    {        while (root-&gt;left)        {            root = root-&gt;left;        }        return root-&gt;val;    }    TreeNode* deleteNode(TreeNode* root, int key)    {        if (!root)        {            return nullptr;        }        if (root-&gt;val == key)        {            if (!root-&gt;left)            {                return root-&gt;right;            }            else if (!root-&gt;right)            {                return root-&gt;left;            }            else            {                root-&gt;val = GetMin(root-&gt;right);                root-&gt;right = deleteNode(root-&gt;right, root-&gt;val);            }        }        else if (root-&gt;val &lt; key)        {            root-&gt;right = deleteNode(root-&gt;right, key);        }        else if (root-&gt;val &gt; key)        {            root-&gt;left = deleteNode(root-&gt;left, key);        }        return root;    }};</code></pre><h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt=""></p><pre><code>输入：root = [4,2,7,1,3], val = 5输出：[4,2,7,1,3,5]解释：另一个满足题目要求可以通过的树是：</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：root = [40,20,60,10,30,50,70], val = 25输出：[40,20,60,10,30,50,70,null,null,25]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5输出：[4,2,7,1,3,5]</code></pre><p><strong>提示：</strong></p><ul><li>给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li><li>每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li><li><code>-10^8 &lt;= val &lt;= 10^8</code></li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul><h4 id="代码1-12"><a href="#代码1-12" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:    TreeNode* insertIntoBST(TreeNode* root, int val)    {        if (!root)        {            return new TreeNode(val);        }        if (val &lt; root-&gt;val)        {            root-&gt;left = insertIntoBST(root-&gt;left, val);        }        else if (val &gt; root-&gt;val)        {            root-&gt;right = insertIntoBST(root-&gt;right, val);        }        return root;    }};</code></pre><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. 二叉搜索树中的搜索</a></h3><p>Difficulty: <strong>简单</strong></p><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，</p><pre><code>给定二叉搜索树:        4       / \      2   7     / \    1   3和值: 2</code></pre><p>你应该返回如下子树:</p><pre><code>      2          / \       1   3</code></pre><p>在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>。</p><h4 id="代码1-13"><a href="#代码1-13" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    TreeNode* searchBST(TreeNode* root, int val)    {        if (!root)        {            return nullptr;        }        if (root-&gt;val == val)        {            return root;        }        else if (val &lt; root-&gt;val)        {            return searchBST(root-&gt;left, val);        }        else if (val &gt; root-&gt;val)        {            return searchBST(root-&gt;right, val);        }        return root;    }};</code></pre><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><pre><code>输入:    2   / \  1   3输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code>输入:    5   / \  1   4     / \    3   6输出: false解释: 输入为: [5,1,4,null,null,3,6]。     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre><h4 id="代码1-14"><a href="#代码1-14" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public:    bool isValidBST(TreeNode* root, TreeNode* min, TreeNode* max)    {        if (!root)        {            return true;        }        if (min &amp;&amp; root-&gt;val &lt;= min-&gt;val)        {            return false;        }        if (max &amp;&amp; root-&gt;val &gt;= max-&gt;val)        {            return false;        }        return isValidBST(root-&gt;left, min, root) &amp;&amp;                isValidBST(root-&gt;right, root, max);    }    bool isValidBST(TreeNode* root)    {        return isValidBST(root, nullptr, nullptr);    }};</code></pre><h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数</a></h3><p>Difficulty: <strong>简单</strong></p><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><pre><code>字符          数值I             1V             5X             10L             50C             100D             500M             1000</code></pre><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;III&quot;输出: 3</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;IV&quot;输出: 4</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;IX&quot;输出: 9</code></pre><p><strong>示例 4:</strong></p><pre><code>输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.</code></pre><p><strong>示例 5:</strong></p><pre><code>输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><p><strong>提示：</strong></p><ul><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li><li>IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li><li>关于罗马数字的详尽书写规则，可以参考 。</li></ul><h4 id="代码1-15"><a href="#代码1-15" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:    int romanToInt(string s)    {        std::string k[] = {&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;};        int v[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4 ,1};        int result = 0;        int s_sub = 0;        int k_sub = 0;        bool flag = true;        while (s_sub &lt; s.length())        {            flag = true;            int i = 0;            for (;i &lt; k[k_sub].length(); ++i)            {                if (s[s_sub + i] != k[k_sub][i])                {                    k_sub++;                    flag = false;                    break;                }            }            if (flag)            {                s_sub += i;                result += v[k_sub];            }        }        return result;    }};</code></pre><p>第一次写出的代码没有通过是因为使用了Map存储的kv然后使用iterator++遍历, 然而iterator遍历并不是按照初始化的顺序而是按照k的大小</p><h4 id="代码2-样例"><a href="#代码2-样例" class="headerlink" title="代码2 - 样例"></a>代码2 - 样例</h4><pre><code class="c++">class Solution {public:    int romanToInt(string s)    {        int m[256];        m[&#39;I&#39;] = 1;        m[&#39;V&#39;] = 5;        m[&#39;X&#39;] = 10;        m[&#39;L&#39;] = 50;        m[&#39;C&#39;] = 100;        m[&#39;D&#39;] = 500;        m[&#39;M&#39;] = 1000;        int result=0;        for(int i = 0; i &lt; s.size(); i++)        {            if(m[s[i]]&gt;=m[s[i+1]])            {                result+=m[s[i]];            }            else            {                result-=m[s[i]];            }        }        return result;    }};</code></pre><p>根据的原理是 把一个小值放在大值的左边，就是做减法，否则为加法。</p><p>此外样例中的m数组设计的也是很巧妙, 只初始化自己要使用的部分, <strong>打破了我数组需要连续使用的思维定式</strong></p><h3 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. Z 字形变换</a></h3><p>Difficulty: <strong>中等</strong></p><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p><pre><code>L   C   I   RE T O E S I I GE   D   H   N</code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><pre><code>string convert(string s, int numRows);</code></pre><p><strong>示例 1:</strong></p><pre><code>输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot;</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot;解释:L     D     RE   O E   I IE C   I H   NT     S     G</code></pre><h4 id="代码1-16"><a href="#代码1-16" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:    string convert(string s, int numRows)    {        vector&lt;vector&lt;char&gt;&gt; vec(numRows, vector&lt;char&gt;(s.length(), &#39; &#39;));        int column = 0;        int ss = 0;        while (ss &lt; s.length())        {            for (int i = 0; ss &lt; s.length() &amp;&amp; i &lt; numRows; ++i)            {                vec[i][column] = s[ss++];            }            column++;            for (int i = numRows - 2; ss &lt; s.length() &amp;&amp; i &gt;= 1; --i)            {                vec[i][column] = s[ss++];                column++;            }        }        std::string result;        for (int i = 0; i &lt; numRows; ++i)        {            for (int j = 0; j &lt; s.length(); ++j)            {                if (vec[i][j] != &#39; &#39;)                {                    result += vec[i][j];                }            }        }        return result;    }};</code></pre><h3 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">654. 最大二叉树</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ol><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ol><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p><strong>示例 ：</strong></p><pre><code>输入：[3,2,1,6,0,5]输出：返回下面这棵树的根节点：      6    /   \   3     5    \    /      2  0          \        1</code></pre><p><strong>提示：</strong></p><ol><li>给定的数组的大小在 [1, 1000] 之间。</li></ol><h4 id="代码1-17"><a href="#代码1-17" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">class Solution {public:    int GetMaxSub(vector&lt;int&gt;&amp; nums, int left, int right)    {        int result = left;        for (int i = left + 1; i &lt; right; ++i)        {            if (nums[i] &gt; nums[result])            {                result = i;            }        }        return result;    }    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums)    {        int max_sub = GetMaxSub(nums, 0, nums.size());        TreeNode* root = new TreeNode(nums[max_sub]);        ConstructMaximumBinaryTree(nums, 0, max_sub, nums.size(), root);        return root;    }    void ConstructMaximumBinaryTree(vector&lt;int&gt;&amp; nums, int left, int mid, int right, TreeNode* root)    {        if (left &lt; mid)        {            int l_max = GetMaxSub(nums, left, mid);            root-&gt;left = new TreeNode(nums[l_max]);            ConstructMaximumBinaryTree(nums, left, l_max, mid, root-&gt;left);        }        if (mid + 1 &lt; right)        {            int r_max = GetMaxSub(nums, mid + 1, right);            root-&gt;right = new TreeNode(nums[r_max]);            ConstructMaximumBinaryTree(nums, mid + 1, r_max, right, root-&gt;right);        }    }};</code></pre><p>自己的第一个思路就是通过ConstructMaximumBinaryTree给传入的root节点构造左子树和右子树</p><p>然后递归的给root的左子树和右子树构造子树</p><p>每次传入left mid right将数组切分为两段 左段构造root的左子树 右段构造root的右子树</p><h4 id="代码2-4"><a href="#代码2-4" class="headerlink" title="代码2"></a>代码2</h4><pre><code class="c++">class Solution {public:    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums)    {        return constructMaximumBinaryTree(nums, 0, nums.size());    }    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums, int left, int right)    {        if (left + 1 &gt; right)        {            return nullptr;        }        int max_sub = left;        for (int i = left + 1; i &lt; right; ++i)        {            if (nums[i] &gt; nums[max_sub])            {                max_sub = i;            }        }        TreeNode* node = new TreeNode(nums[max_sub]);        node-&gt;left = constructMaximumBinaryTree(nums, left, max_sub);        node-&gt;right = constructMaximumBinaryTree(nums, max_sub + 1, right);        return node;    }};</code></pre><p>题解的答案更加的简洁每次的constructMaximumBinaryTree仅负责构造一个节点返回回去成为左节点或者右节点</p><p>同时给构造出的节点赋值左节点和右节点.</p><p>相对我的代码构造左节点和右节点 这里淡化了左右节点的区别. 通过传入的参数即可知道是左右节点然后赋值给left right</p><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt=""></p><p><strong>示例:</strong></p><pre><code>输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</code></pre><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><pre><code class="c++">​class Solution {public:    vector&lt;string&gt; letterCombinations(string digits)    {        vector&lt;string&gt; result;        if (digits.empty())        {        }        else        {            solve(digits, 0, &quot;&quot;, result);        }        return result;    }    void solve(const string&amp; digits, int sub, string temp, vector&lt;string&gt;&amp; result)    {        if (sub == digits.size())        {            result.push_back(temp);        }        else        {            char begin = (digits[sub] - &#39;2&#39;) * 3 + &#39;a&#39;;            switch (digits[sub])            {                case &#39;2&#39;:                case &#39;3&#39;:                case &#39;4&#39;:                case &#39;5&#39;:                case &#39;6&#39;:                {                    for (int i = 0; i &lt; 3; ++i)                    {                        char a = begin + i;                        solve(digits, sub + 1, temp + a, result);                    }                    break;                }                case &#39;7&#39;:                {                    for (int i = 0; i &lt; 4; ++i)                    {                        char a = begin + i;                        solve(digits, sub + 1, temp + a, result);                    }                    break;                }                case &#39;8&#39;:                {                    begin += 1;                    for (int i = 0; i &lt; 3; ++i)                    {                        char a = begin + i;                        solve(digits, sub + 1, temp + a, result);                    }                    break;                }                case &#39;9&#39;:                {                    begin += 1;                    for (int i = 0; i &lt; 4; ++i)                    {                        char a = begin + i;                        solve(digits, sub + 1, temp + a, result);                    }                    break;                }            }        }    }};</code></pre><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个链表，删除链表的倒数第 _n _个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><h4 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h4><pre><code class="c++">​/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public:    ListNode* removeNthFromEnd(ListNode* head, int n)    {        if (!head)        {            return nullptr;        }        ListNode* node = head;        ListNode* temp = node;        ListNode* last_temp = nullptr;        int now_sub = 0;        while (node-&gt;next)        {            if (now_sub == n - 1)            {                last_temp = temp;                temp = temp-&gt;next;                node = node-&gt;next;            }            else            {                node = node-&gt;next;                now_sub++;            }        }        if (temp == head)        {            head = head-&gt;next;        }        else        {            last_temp-&gt;next = temp-&gt;next;        }        return head;    }};</code></pre><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h3><p>Difficulty: <strong>简单</strong></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""></p><pre><code>输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：l1 = [], l2 = []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：l1 = [], l2 = [0]输出：[0]</code></pre><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h4 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h4><pre><code class="c++">​/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)    {        if (!l1)        {            return l2;        }        if (!l2)        {            return l1;        }        ListNode* head = nullptr;        if (l1-&gt;val &lt; l2-&gt;val)        {            head = l1;            l1 = l1-&gt;next;        }        else        {            head = l2;            l2 = l2-&gt;next;        }        ListNode* temp = head;        while (l1 || l2)        {            if (!l1)            {                temp-&gt;next = l2;                break;            }            else if (!l2)            {                temp-&gt;next = l1;                break;            }            else            {                if (l1-&gt;val &lt; l2-&gt;val)                {                    temp-&gt;next = l1;                    l1 = l1-&gt;next;                }                else                {                    temp-&gt;next = l2;                    l2 = l2-&gt;next;                }                temp = temp-&gt;next;            }        }        return head;    }};</code></pre><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt=""></p><pre><code>输入：head = [1,2,3,4]输出：[2,1,4,3]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：head = []输出：[]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：head = [1]输出：[1]</code></pre><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h4 id="代码1-18"><a href="#代码1-18" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public:    ListNode* swapPairs(ListNode* node)    {        if (!node)        {            return nullptr;        }        ListNode* temp = node-&gt;next;        if (!temp)        {            return node;        }        ListNode* back = temp-&gt;next;        temp-&gt;next = node;        node-&gt;next = swapPairs(back);        return temp;    }};</code></pre><h3 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h3><p>Difficulty: <strong>简单</strong></p><p>给定一个排序数组，你需要在 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><pre><code>给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>示例 2:</strong></p><pre><code>给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><h4 id="代码1-19"><a href="#代码1-19" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">​class Solution {public:    int removeDuplicates(vector&lt;int&gt;&amp; nums)    {        if (nums.empty())        {            return 0;        }        int t = 1;        int num = nums[0];        for (int i = 1; i &lt; nums.size(); ++i)        {            if (nums[i] == num)            {                continue;            }            num = nums[i];            nums[t++] = nums[i];        }        return t;    }};</code></pre><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h3><p>Difficulty: <strong>中等</strong></p><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><pre><code>前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]</code></pre><p>返回如下的二叉树：</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><h4 id="代码1-20"><a href="#代码1-20" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="c++">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder)    {        return build(preorder, 0, preorder.size(),         inorder, 0, inorder.size());    }    TreeNode* build(vector&lt;int&gt;&amp; preorder, int preb, int pree,     vector&lt;int&gt;&amp; inorder, int inb, int ine)    {        if (preb == pree)        {            return nullptr;        }        TreeNode* root = new TreeNode(preorder[preb]);        int in_root;        for (in_root = inb; in_root &lt; ine; ++in_root)        {            if (preorder[preb] == inorder[in_root])            {                break;            }        }        int num = in_root - inb;        root-&gt;left = build(preorder, preb + 1, preb + 1 + num, inorder, inb, in_root);        root-&gt;right = build(preorder, preb + 1 + num, pree, inorder, in_root + 1, ine);        return root;    }};</code></pre><h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></h3><p>Difficulty: <strong>中等</strong></p><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><pre><code>中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3]</code></pre><p>返回如下的二叉树：</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><h4 id="代码1-21"><a href="#代码1-21" class="headerlink" title="代码1"></a>代码1</h4><pre><code class="C++">​/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder)    {        return build(inorder, 0, inorder.size(), postorder, 0, postorder.size());    }    TreeNode* build(vector&lt;int&gt;&amp; inorder, int inb, int ine, vector&lt;int&gt;&amp; postorder,     int pob, int poe)    {        if (inb == ine)        {            return nullptr;        }        TreeNode* root = new TreeNode(postorder[poe - 1]);        int in_root;        for (in_root = inb; in_root &lt; ine; ++in_root)        {            if (inorder[in_root] == postorder[poe - 1])            {                break;            }        }        int num = in_root - inb;        root-&gt;left = build(inorder, inb, in_root, postorder, pob, pob + num);        root-&gt;right = build(inorder, in_root + 1, ine, postorder, pob + num, poe - 1);        return root;    }};</code></pre><h3 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/" target="_blank" rel="noopener">652. 寻找重复的子树</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p><p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p><p><strong>示例 1：</strong></p><pre><code>        1       / \      2   3     /   / \    4   2   4       /      4</code></pre><p>下面是两个重复的子树：</p><pre><code>      2     /    4</code></pre><p>和</p><pre><code>    4</code></pre><p>因此，你需要以列表的形式返回上述重复子树的根结点。</p><h4 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1"></a>Solution1</h4><pre><code class="c++">​/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public:    vector&lt;TreeNode*&gt; result_;    map&lt;string, int&gt; node_map_;    vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root)    {        solve(root);        return result_;    }    string solve(TreeNode* root)    {        if (!root)        {            return &quot;#&quot;;        }        string left = solve(root-&gt;left);        string right = solve(root-&gt;right);        string sum = left + &quot;,&quot; + right + &quot;,&quot; + to_string(root-&gt;val);        if (node_map_.find(sum) == node_map_.end())        {            node_map_.insert({sum, 1});        }        else        {            if (node_map_[sum] == 1)            {                result_.push_back(root);            }            node_map_[sum]++;        }        return sum;    }};</code></pre><h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><pre><code>输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：coins = [2], amount = 3输出：-1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：coins = [1], amount = 0输出：0</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：coins = [1], amount = 1输出：1</code></pre><p><strong>示例 5：</strong></p><pre><code>输入：coins = [1], amount = 2输出：2</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li><li><code>0 &lt;= amount &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li></ul><h4 id="Solution-dp自顶向下"><a href="#Solution-dp自顶向下" class="headerlink" title="Solution - dp自顶向下"></a>Solution - dp自顶向下</h4><pre><code class="c++">​class Solution {public:    vector&lt;int&gt; table;    // map&lt;int, int&gt; table;    int dp(vector&lt;int&gt;&amp; coins, int amount)    {        if (amount == 0)        {            return 0;        }        else if (amount &lt; 0)        {            return -1;        }        else if (table[amount] != 0)        {            return table[amount];        }        int result = INT_MAX;        for (int i = 0; i &lt; coins.size(); ++i)        {            int temp = dp(coins, amount - coins[i]);            if (temp &lt; 0)            {                continue;            }            result = min(temp + 1, result);        }        result = (result == INT_MAX ? -1 : result);        table[amount] = result;        return result;    }    int coinChange(vector&lt;int&gt;&amp; coins, int amount)    {        if (amount &lt; 1)         {            return 0;        }        table.resize(amount + 1);        return dp(coins, amount);    }};</code></pre><h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h3><p>Difficulty: <strong>困难</strong></p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code>所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;)</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;)</code></pre><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h4 id="Solution-回溯"><a href="#Solution-回溯" class="headerlink" title="Solution 回溯"></a>Solution 回溯</h4><pre><code class="c++">class Solution {public:    int min_time = INT_MAX;    int minDistance(string word1, string word2)    {        minDistance(word1, word2, 0, 0, 0);        return min_time;    }    void minDistance(string word1, string word2, int ws1, int ws2, int time)    {        if (time &gt;= min_time)        {            return;        }        if (ws2 == word2.length() || ws1 == word1.length())        {            for (int i = 0; i &lt; min(ws1, ws2); ++i)            {                if (word1[i] != word2[i])                {                    return;                }            }            time += word1.length() &gt; word2.length() ? word1.length() - word2.length() :  word2.length() - word1.length();            if (time &lt; min_time)            {                min_time = time;            }        }        else        {            if (word1[ws1] == word2[ws2])            {                minDistance(word1, word2, ws1 + 1, ws2 + 1, time);            }            else            {                char back = word1[ws1];                word1[ws1] = word2[ws2];                minDistance(word1, word2, ws1 + 1, ws2 + 1, time + 1);                word1[ws1] = back;                string back_str = word1;                word1.erase(ws1, 1);                minDistance(word1, word2, ws1, ws2, time + 1);                word1 = back_str;                word1.insert(ws1, 1, word2[ws2]);                minDistance(word1, word2, ws1 + 1, ws2 + 1, time + 1);            }        }    }};</code></pre><h4 id="Solution-DP备忘录"><a href="#Solution-DP备忘录" class="headerlink" title="Solution DP备忘录"></a>Solution DP备忘录</h4><pre><code class="c++">​class Solution {public:    map&lt;string, int&gt; bwl;    int minDistance(string word1, string word2)    {        return minDistance(word1, word2, word1.length() - 1, word2.length() - 1);    }    int minDistance(const string&amp; word1, const string&amp; word2, int ws1, int ws2)    {        if (ws1 == -1) return ws2 + 1;        if (ws2 == -1) return ws1 + 1;        string key = to_string(ws1) + &quot;#&quot; + to_string(ws2);        if (bwl.find(key) != bwl.end())        {            return bwl[key];        }        if (word1[ws1] == word2[ws2])        {            bwl[key] = minDistance(word1, word2, ws1 - 1, ws2 - 1);        }        else        {            bwl[key] = min({                minDistance(word1, word2, ws1, ws2 - 1), // 插入                minDistance(word1, word2, ws1 - 1, ws2 - 1), // 替换                minDistance(word1, word2, ws1 - 1, ws2) // 删除            }) + 1;        }        return bwl[key];    }};</code></pre><h4 id="Solution-DP-Table"><a href="#Solution-DP-Table" class="headerlink" title="Solution DP Table"></a>Solution DP Table</h4><pre><code class="c++">class Solution {public:    int minDistance(string word1, string word2)    {        int dp[word1.length() + 1][word2.length() + 1];        dp[0][0] = 0;        for (int i = 1; i &lt;= word2.length(); ++i)        {            dp[0][i]  = i;        }        for (int i = 1; i &lt;= word1.length(); ++i)        {            dp[i][0] = i;        }        for (int ws1 = 1; ws1 &lt;= word1.length(); ++ws1)        {            for (int ws2 = 1; ws2 &lt;= word2.length(); ++ws2)            {                if (word1[ws1 - 1] == word2[ws2 - 1])                {                    dp[ws1][ws2] = dp[ws1 - 1][ws2 - 1];                }                else                {                    dp[ws1][ws2] = min({                        dp[ws1 - 1][ws2 - 1],                        dp[ws1][ws2 - 1],                        dp[ws1 - 1][ws2]                    }) + 1;                }            }        }        return dp[word1.length()][word2.length()];    }};</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用回溯法的代码超时了, 而且回溯解法里面对字符串进行了实打实的修改</p><p>从回溯法转向DP备忘录优化了一个参数 使用返回值返回答案而不是单独的time参数. DP备忘录由于使用了递归所以使用的空间大, 效率也低 </p><p>观察DP备忘录<br><code>dp[ws1][ws2]</code>只跟<code>dp[ws1-1][ws2-1]</code>, <code>dp[ws1][ws2-1]</code>和<code>dp[ws1-1][ws2]</code>有关进而自然的转向DP Table</p><p>Dp Table这里数组一般都需要多开一行+一列 对应代码里面的<code>length()+1</code>, 否则下标0含有两层意思 一是空串时长度为0 二是非空串是含有0这个有效下标</p><p>所以将非空串的下标改为从1开始</p><h3 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. 俄罗斯套娃信封问题</a></h3><p>Difficulty: <strong>困难</strong></p><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 <code>(w, h)</code> 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p><strong>说明:</strong><br>不允许旋转信封。</p><p><strong>示例:</strong></p><pre><code>输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]输出: 3 解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes)    {        if (envelopes.empty())        {            return 0;        }        sort(envelopes.begin(), envelopes.end(), [](const auto&amp; lhs, const auto&amp; rhs){            if (lhs[0] != rhs[0])            {                return lhs[0] &lt; rhs[0];            }            else            {                return lhs[1] &gt; rhs[1];            }        });        int nums[envelopes.size()];        for (int i = 0; i &lt; envelopes.size(); ++i)        {            nums[i] = envelopes[i][1];        }        int dp[envelopes.size()];        int result = 1;        for (int i = 0; i &lt; envelopes.size(); ++i)        {            dp[i] = 1;            for (int j = 0; j &lt; i; ++j)            {                if (nums[j] &lt; nums[i] &amp;&amp; dp[j] &gt;= dp[i])                {                    dp[i] = dp[j] + 1;                    if (dp[i] &gt; result)                    {                        result = dp[i];                    }                }            }        }        return result;    }};</code></pre><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a></h3><p>Difficulty: <strong>中等</strong></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1,0,3,2,3]输出：4</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-10&lt;sup&gt;4&lt;/sup&gt; &lt;= nums[i] &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li></ul><p><strong>进阶：</strong></p><ul><li>你可以设计时间复杂度为 <code>O(n&lt;sup&gt;2&lt;/sup&gt;)</code> 的解决方案吗？</li><li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li></ul><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums)    {        int dp[nums.size()];        dp[0] = 1;        for (int i = 1; i &lt; nums.size(); ++i)        {            dp[i] = 1;            for (int j = 0; j &lt; i; ++j)            {                if (nums[j] &lt; nums[i] &amp;&amp; dp[j] &gt;= dp[i])                {                    dp[i] = dp[j] + 1;                }            }        }        int result = 0;        for (int i = 0; i &lt; nums.size(); ++i)        {            if (dp[i] &gt; result)            {                result = dp[i];            }        }        return result;    }};</code></pre><h3 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. 两个字符串的删除操作</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定两个单词 _word1 _和 _word2_，找到使得 _word1 _和 _word2 _相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p><p><strong>示例：</strong></p><pre><code>输入: &quot;sea&quot;, &quot;eat&quot;输出: 2解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot;</code></pre><p><strong>提示：</strong></p><ol><li>给定单词的长度不超过500。</li><li>给定单词中的字符只含有小写字母。</li></ol><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    int minDistance(string word1, string word2)    {           int ws1 = word1.size();        int ws2 = word2.size();        int dp[ws1 + 1][ws2 + 1];        for (int i = 0; i &lt;= ws1; ++i)        {            dp[i][0] = i;        }        for (int i = 0; i &lt;= ws2; ++i)        {            dp[0][i] = i;        }        for (int i = 1; i &lt;= ws1; ++i)        {            for (int j = 1; j &lt;= ws2; ++j)            {                if (word1[i - 1] == word2[j - 1])                {                    dp[i][j] = dp[i - 1][j - 1];                }                else                {                    dp[i][j] = min(                        dp[i - 1][j],                        dp[i][j - 1]                    ) + 1;                }            }        }        return dp[ws1][ws2];    }};</code></pre><h3 id="712-两个字符串的最小ASCII删除和"><a href="#712-两个字符串的最小ASCII删除和" class="headerlink" title="712. 两个字符串的最小ASCII删除和"></a><a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/" target="_blank" rel="noopener">712. 两个字符串的最小ASCII删除和</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定两个字符串<code>s1, s2</code>，找到使两个字符串相等所需删除字符的ASCII值的最小和。</p><p><strong>示例 1:</strong></p><pre><code>输入: s1 = &quot;sea&quot;, s2 = &quot;eat&quot;输出: 231解释: 在 &quot;sea&quot; 中删除 &quot;s&quot; 并将 &quot;s&quot; 的值(115)加入总和。在 &quot;eat&quot; 中删除 &quot;t&quot; 并将 116 加入总和。结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: s1 = &quot;delete&quot;, s2 = &quot;leet&quot;输出: 403解释: 在 &quot;delete&quot; 中删除 &quot;dee&quot; 字符串变成 &quot;let&quot;，将 100[d]+101[e]+101[e] 加入总和。在 &quot;leet&quot; 中删除 &quot;e&quot; 将 101[e] 加入总和。结束时，两个字符串都等于 &quot;let&quot;，结果即为 100+101+101+101 = 403 。如果改为将两个字符串转换为 &quot;lee&quot; 或 &quot;eet&quot;，我们会得到 433 或 417 的结果，比答案更大。</code></pre><p><strong>注意:</strong></p><ul><li><code>0 &lt; s1.length, s2.length &lt;= 1000</code>。</li><li>所有字符串中的字符ASCII值在<code>[97, 122]</code>之间。</li></ul><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="c++">​class Solution {public:    int minimumDeleteSum(string s1, string s2)    {        int ws1 = s1.size();        int ws2 = s2.size();        int dp[ws1 + 1][ws2 + 1];        dp[0][0] = 0;        for (int i = 1; i &lt;= ws1; ++i)        {            dp[i][0] = dp[i - 1][0] + s1[i - 1];        }        for (int i = 1; i &lt;= ws2; ++i)        {            dp[0][i] = dp[0][i - 1] + s2[i - 1];        }        for (int i = 1; i &lt;= ws1; ++i)        {            for (int j = 1; j &lt;= ws2; ++j)            {                if (s1[i - 1] == s2[j - 1])                {                    dp[i][j] = dp[i - 1][j - 1];                }                else                {                    dp[i][j] = min(                        dp[i][j - 1] + s2[j - 1],                        dp[i - 1][j] + s1[i - 1]                    );                }            }        }        return dp[ws1][ws2];    }};</code></pre><h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">103. 二叉树的锯齿形层序遍历</a></h3><p>Difficulty: <strong>中等</strong></p><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>返回锯齿形层序遍历如下：</p><pre><code>[  [3],  [20,9],  [15,7]]</code></pre><h4 id="Solution-无reverse"><a href="#Solution-无reverse" class="headerlink" title="Solution - 无reverse"></a>Solution - 无reverse</h4><pre><code class="c++">​/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public:    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root)     {        if (!root)        {            return {};        }        deque&lt;TreeNode*&gt; nodes_last;        deque&lt;TreeNode*&gt; nodes_next;        nodes_last.push_back(root);        bool r_to_l = false;        vector&lt;vector&lt;int&gt;&gt; result;        while (!nodes_last.empty())        {            vector&lt;int&gt; temp;            temp.reserve(nodes_last.size());            if (r_to_l)            {                while (!nodes_last.empty())                {                    TreeNode* node = nodes_last.back();                    nodes_last.pop_back();                    if (node-&gt;right)                    {                        nodes_next.push_front(node-&gt;right);                    }                    if (node-&gt;left)                    {                        nodes_next.push_front(node-&gt;left);                    }                    temp.push_back(node-&gt;val);                }            }            else            {                while (!nodes_last.empty())                {                    TreeNode* node = nodes_last.front();                    nodes_last.pop_front();                    if (node-&gt;left)                    {                        nodes_next.push_back(node-&gt;left);                    }                    if (node-&gt;right)                    {                        nodes_next.push_back(node-&gt;right);                    }                    temp.push_back(node-&gt;val);                }            }            result.push_back(move(temp));            r_to_l = !r_to_l;            nodes_next.swap(nodes_last);        }        return result;    }};</code></pre><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></h3><p>Difficulty: <strong>困难</strong></p><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt=""></p><pre><code>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </code></pre><p><strong>示例 2：</strong></p><pre><code>输入：height = [4,2,0,3,2,5]输出：9</code></pre><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>0 &lt;= n &lt;= 3 * 10&lt;sup&gt;4&lt;/sup&gt;</code></li><li><code>0 &lt;= height[i] &lt;= 10&lt;sup&gt;5&lt;/sup&gt;</code></li></ul><h4 id="Solution-暴力法"><a href="#Solution-暴力法" class="headerlink" title="Solution - 暴力法"></a>Solution - 暴力法</h4><pre><code class="c++">​class Solution {public:    int trap(vector&lt;int&gt;&amp; height)     {        int n = 0;        int sum_rain = 0;        while (true)        {            int sum_wall_n = 0;            n++;            int left_wall = INT_MAX;            int right_wall = INT_MIN;            for (int i = 0; i &lt; height.size(); ++i)            {                if (height[i] &gt;= n)                {                    sum_wall_n++;                    left_wall = min(i, left_wall);                    right_wall = max(i, right_wall);                }            }            if (sum_wall_n &gt;= 2)            {                int rain = right_wall - left_wall - 1 - (sum_wall_n - 2);                sum_rain += rain;            }            else            {                break;            }        }        return sum_rain;    }};</code></pre><p>一层一层判断, 当前层可存储雨水等于 当前层最左侧墙和当前层最右侧墙之间的数量 减去之间墙的数量 得到空位的数量 也就是雨水</p><p>时间复杂度O(n^2) 空间复杂度O(1). </p><p>另外一种暴力方法是每次计算当前位置最多积多少水, 上面的暴力方法是一层一层计算 这里是一列一列计算. 需要从当前位置分别向左和右遍历找到两边的最高墙<br>较矮的一边减去当前墙高度即为当前位置最多积累的雨水. 时间和空间复杂度同上</p><h4 id="Solution-动态规划-提前遍历出每个位置处的左边最高和右边最高"><a href="#Solution-动态规划-提前遍历出每个位置处的左边最高和右边最高" class="headerlink" title="Solution - 动态规划 提前遍历出每个位置处的左边最高和右边最高"></a>Solution - 动态规划 提前遍历出每个位置处的左边最高和右边最高</h4><pre><code class="c++">class Solution {public:    int trap(vector&lt;int&gt;&amp; height)     {        if (height.empty())        {            return 0;        }        const int HEI_SIZE = height.size();        vector&lt;int&gt; left_max;        vector&lt;int&gt; right_max;        left_max.resize(HEI_SIZE);        right_max.resize(HEI_SIZE);        left_max[0] = height[0];        right_max[HEI_SIZE - 1] = height[HEI_SIZE - 1];        for (int i = 1; i &lt; HEI_SIZE; ++i)        {            left_max[i] = max(left_max[i - 1], height[i]);        }        for (int i = HEI_SIZE - 2; i &gt;= 0; --i)        {            right_max[i] = max(right_max[i + 1], height[i]);        }        int sum_rain_ret = 0;        for (int i = 1; i &lt; HEI_SIZE; ++i)        {            int rain = min(left_max[i], right_max[i]) - height[i];            sum_rain_ret += max(rain, 0);        }        return sum_rain_ret;    }};</code></pre><h4 id="Solution-递减栈"><a href="#Solution-递减栈" class="headerlink" title="Solution - 递减栈"></a>Solution - 递减栈</h4><pre><code class="c++">class Solution {public:    int trap(vector&lt;int&gt;&amp; height)     {        if (height.empty())        {            return 0;        }        int sum_rain_ret = 0;        stack&lt;int&gt; height_stack;        for (int i = 0; i &lt; height.size(); ++i)        {            while (!height_stack.empty() &amp;&amp; height[i] &gt;= height[height_stack.top()])            {                int last_wall = height_stack.top(); // last_wall的高度 小于 i的高度 也小于 llast_wall的高度                height_stack.pop();                if (height_stack.empty())                {                    break;                }                int llast_wall = height_stack.top(); // 这里不进行pop()是因为                 // llast_wall的高度 小于 lllast_wall llast_wall 可能小于i的高度 这之间依然可能积水                int distance = i - llast_wall - 1; // 间距                int rain = min(height[llast_wall], height[i]) - height[last_wall];                sum_rain_ret += rain * distance;            }            height_stack.push(i);        }        return sum_rain_ret;    }};</code></pre><p>代码比较难理解 结合<code>[4,2,0,3,2,5]</code>输入走一遍就好理解了 <code>ans=9</code></p><h4 id="Solution-双指针"><a href="#Solution-双指针" class="headerlink" title="Solution - 双指针"></a>Solution - 双指针</h4><pre><code class="c++">class Solution {public:    int trap(vector&lt;int&gt;&amp; height)     {        if (height.empty())        {            return 0;        }        int left_max_sub = 0;        int right_max_sub = height.size() - 1;        int left = left_max_sub + 1;        int right = right_max_sub - 1;        int sum_rain_ret = 0;        while (left &lt;= right)        {            if (height[left_max_sub] &lt; height[right_max_sub])            {                if (height[left] &lt; height[left_max_sub])                {                    sum_rain_ret += height[left_max_sub] - height[left];                }                else                {                    left_max_sub = left;                }                left++;            }            else            {                if (height[right] &lt; height[right_max_sub])                {                    sum_rain_ret += height[right_max_sub] - height[right];                }                else                {                    right_max_sub = right;                }                right--;            }        }        return sum_rain_ret;    }};</code></pre><p>left_max_sub一定是left左边最高的墙, 但是right_max_sub不一定是left右边最高的墙. 也就是说右边的墙高度 大于等于 right_max_sub</p><p>所以当left_max_sub的墙的高度小于right_max_sub的时候 上面的问题就不存在了, 因为取决于更矮的墙</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和STL</title>
      <link href="/2021/02/%E7%AE%97%E6%B3%9590-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2021/02/%E7%AE%97%E6%B3%9590-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL/api.png" alt=""></p><p>对stl库string等定义的变量 使用sizeof并不会得到真实的大小, sizeof只会返回相关类中成员的大小</p><p>stl等库中使用指针指向真实的数据, sizeof的时候只记录了指针的大小 并不记录指针指向空间的大小</p><table><thead><tr><th>顺序容器</th><th>按序访问</th></tr></thead><tbody><tr><td>array</td><td>静态的连续数组</td></tr><tr><td>vector</td><td>动态的连续数组</td></tr><tr><td>deque</td><td>双端队列</td></tr><tr><td>forward_list</td><td>单链表</td></tr><tr><td>list</td><td>双链表</td></tr></tbody></table><table><thead><tr><th>关联容器</th><th>能实现快速查找O(logn)</th></tr></thead><tbody><tr><td>set</td><td>唯一key的集合, 按照key排序</td></tr><tr><td>map</td><td>k v集合, 按照k排序, k是唯一的</td></tr><tr><td>multiset</td><td>key的集合 按照key排序</td></tr><tr><td>multimap</td><td>k v的集合, 按照key排序</td></tr></tbody></table><table><thead><tr><th>无序关联容器</th><th>快速查找均摊O(1)最坏O(n)的无序(哈希)数据结构</th></tr></thead><tbody><tr><td>unordered_set</td><td>唯一key的集合, 按照key生成散列</td></tr><tr><td>unordered_map</td><td>唯一key, k v的集合, 按照key生成散列</td></tr><tr><td>unordered_multiset</td><td>key的集合, 按照key生成散列</td></tr><tr><td>unordered_multimap</td><td>k v的集合, 按照key生成散列</td></tr></tbody></table><table><thead><tr><th>容器适配器</th><th>提供顺序容器的不同接口</th></tr></thead><tbody><tr><td>stack</td><td>适配一个容器提供栈 vector deque list满足要求 默认是deque</td></tr><tr><td>queue</td><td>适配一个容器提供队列 deque list 默认是deque</td></tr><tr><td>priority_queue</td><td>适配一个容器提供优先级队列 vector deque 默认是 vector</td></tr></tbody></table><h1 id="Sequence-containers-顺序容器"><a href="#Sequence-containers-顺序容器" class="headerlink" title="Sequence containers 顺序容器"></a>Sequence containers 顺序容器</h1><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>内部数组, 连续存储</p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>内部为多个等长的连续数组, 数组之间不一定连续. 通过一个记录数组顺序的串起这些等长的连续数组(保存各个数组的首地址)</p><h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h2><p>单链表</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>双链表</p><h1 id="Associative-containers-关联容器"><a href="#Associative-containers-关联容器" class="headerlink" title="Associative containers 关联容器"></a>Associative containers 关联容器</h1><p>内部会自动进行排序 底层红黑树 key不允许重复 提供O(logN)的查找</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>值就是key 值就是元素</p><p>不能通过迭代器修改set的值, 修改set的值会导致删除和新建 指针会失效</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>key和value分开 key+value作为一个元素</p><h1 id="Unordered-associative-containers-无序关联容器"><a href="#Unordered-associative-containers-无序关联容器" class="headerlink" title="Unordered associative containers 无序关联容器"></a>Unordered associative containers 无序关联容器</h1><p>内部不会自动进行排序 底层散列表 提供平均O(1)最坏O(N)的查找</p><h1 id="Container-adaptors-容器适配器"><a href="#Container-adaptors-容器适配器" class="headerlink" title="Container adaptors 容器适配器"></a>Container adaptors 容器适配器</h1><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>默认使用deque实现</p><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>默认使用deque实现</p><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>默认使用vector实现</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器访问URL到显示</title>
      <link href="/2021/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEURL%E5%88%B0%E6%98%BE%E7%A4%BA/"/>
      <url>/2021/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEURL%E5%88%B0%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/base/ip-wireshark.png" alt=""></p><p>浏览器访问虚拟机创建的nginx默认网页</p><p>浏览器根据输入的URL中的IP 进行三次握手建立TCP连接 然后浏览器发送GET请求 服务器回复GET请求 获取各种文件</p><p>一般服务器对<code>GET /</code>默认返回index.html页面 <code>https://www.baidu.com/index.html</code>自己加上index后同样可以访问 但是<code>https://www.qq.com/index.html</code>却不行 所以还是跟服务器处理逻辑有关</p><p>返回了html页面后浏览器解析其中的内容, 请求css, js, 图片资源等文件 然后进行渲染显示出网页</p><p>文件传输完毕后TCP四次挥手关闭连接</p><p>如果使用的是域名访问, 则需要访问DNS服务器解析域名获得IP地址, 这样HTTP请求头部还会包含一些特殊的头部如HOST等</p><p>HTTP访问的默认端口均为80端口</p><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><p>https进行域名解析后, ip+443端口连接服务器</p><p>测试时访问的连接为<code>https://m.baidu.com/?pu=sz%401321_480</code> 百度精简版页面, 修改了host防止负载均衡等策略ip不对应</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/base/https-wireshark.png" alt=""></p><p>504 505 506 三个包进行TCP三次握手与<code>110.242.68.9:443</code>建立连接</p><p>507 客户端发送Client Hello 发送随机的key1和自己支持的加密方法</p><p>508 ACK应答</p><p>509 510 511 服务端发送Server Hello 发送随机的key2和选定的加密方法</p><p>512 服务端发送证书</p><p>513 ACK应答</p><p>514 服务器发送Server Key Exchange</p><p>515 服务器发送Server Hello Done</p><p>516 ACK应答</p><p>518 客户端发送Client Key Exchange, Change Clipher Spec, Finished</p><p>519 客户端发送经过加密的GET请求(Wireshark进行了解密)</p><p>520 521 进行ACK应答</p><p>522 523 524 服务端发送New Session Ticket, Change Clipher Spec, Finished</p><p>556 服务器回复GET请求</p><p>客户端向服务器发送请求(随机数key1 和支持的加密算法)</p><p>服务器回复数字证书(随机数key2 选择的双方支持算法 证书)</p><p>客户端验证数字证书可靠性, 使用CA的公钥解密加密后的证书. 验证证书的合法性</p><p>客户端生成随机数key3, 根据key1, key2, key3生成会话秘钥, 用服务器发送的证书加密key3发送给服务器</p><p>服务器解密key3同样根据key1, key2, key3生成会话秘钥</p><p>后续就通过会话密钥进行加密数据和解密数据</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用</title>
      <link href="/2021/01/Linux-docker/"/>
      <url>/2021/01/Linux-docker/</url>
      
        <content type="html"><![CDATA[<h1 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h1><p>创建容器</p><pre><code class="shell">yum install docker# https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 配置镜像加速docker pull mysql # 拉取镜像docker run -itd --name mysql-live -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456789 mysql # 创建容器docker ps # 查看容器状态</code></pre><p>配置远程账号</p><pre><code class="shell">docker exec -it mysql-live bash # 进入容器mysql -uroot -p123456789CREATE USER &#39;lsmg&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456789&#39;; # 创建远程用户GRANT ALL PRIVILEGES ON *.* TO &#39;lsmg&#39;@&#39;%&#39;;flush privileges;</code></pre><h1 id="导出导入文件"><a href="#导出导入文件" class="headerlink" title="导出导入文件"></a>导出导入文件</h1><p>从容器导出文件</p><pre><code class="shell"># 导出mysql容器的sql导出文件docker cp mysql-live:/live_user.sql /root</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.*_case</title>
      <link href="/2021/01/CPP-cast/"/>
      <url>/2021/01/CPP-cast/</url>
      
        <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used" target="_blank" rel="noopener">https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used</a>?</p><h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><ol><li>普通类型转换 int-&gt;float</li><li>pointer to void<em>, void</em> to pointer</li><li>向上类型转换不是必须的, 但是向下转换只要不是虚拟继承就能使用</li></ol><h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p>只用来处理多态下的指针和引用</p><pre><code class="c++">class Animal{public:    virtual void PrintName()    {        std::cout &lt;&lt; &quot;Animal\r\n&quot;;    }};class Dog : public Animal{public:    void PrintName() override    {        std::cout &lt;&lt; &quot;Dog\r\n&quot;;    }};class Cat : public Animal{public:    void PrintName() override    {        std::cout &lt;&lt; &quot;Cat\r\n&quot;;    }};void TestCast(){    // Animal* animal = new Animal(); // not dog not cat    // Animal* animal = new Dog(); // Dog not cat    Animal* animal = new Cat(); // not dog Cat    Dog* dog = dynamic_cast&lt;Dog*&gt;(animal);    Cat* cat = dynamic_cast&lt;Cat*&gt;(animal);    if (dog)    {        dog-&gt;PrintName();    }    else    {        std::cout &lt;&lt; &quot;not dog\r\n&quot;;    }    if (cat)    {        cat-&gt;PrintName();    }    else    {        std::cout &lt;&lt; &quot;not cat\r\n&quot;;    }}</code></pre><h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p>可以用来对变量移除和添加const, 其他的cast都无法做到 (static_cast可以添加const但是不能去除)</p><p>将const变量移除const是未定义的, 将<code>非const的变量</code>的<code>const引用</code>是安全的</p><pre><code class="c++">int a = 1;int* ap1 = &amp;a;const int* ap2 = static_cast&lt;const int*&gt;(ap1); // OKint* ap3 = static_cast&lt;int*&gt;(ap2); // invalid static_cast from type &#39;const int*&#39; to type &#39;int*&#39;int* ap4 = const_cast&lt;int*&gt;(ap2); // OK</code></pre><ul><li>ex1.将const成员函数的this指针去除const来修改成员变量<pre><code class="c++">// https://www.geeksforgeeks.org/const_cast-in-c-type-casting-operators/#include &lt;iostream&gt; using namespace std; </code></pre></li></ul><p>class student<br>{<br>private:<br>    int roll;<br>public:<br>    // constructor<br>    student(int r):roll(r) {} </p><pre><code>// A const function that changes roll with the help of const_cast void fun() const{     ( const_cast &lt;student*&gt; (this) )-&gt;roll = 5; } int getRoll() { return roll; } </code></pre><p>}; </p><p>int main(void)<br>{<br>    student s(3);<br>    cout &lt;&lt; “Old roll number: “ &lt;&lt; s.getRoll() &lt;&lt; endl; </p><pre><code>s.fun(); cout &lt;&lt; &quot;New roll number: &quot; &lt;&lt; s.getRoll() &lt;&lt; endl; return 0; </code></pre><p>} </p><p>//$ Old roll number: 3<br>//$ New roll number: 5</p><pre><code>- ex2.去除参数的const, 来调用非const参数的函数```c++#include &lt;iostream&gt; using namespace std; int fun(int* ptr) {     return (*ptr + 10); } int main(void) {     const int val = 10;     const int *ptr = &amp;val;     int *ptr1 = const_cast &lt;int *&gt;(ptr);     cout &lt;&lt; fun(ptr1);     return 0; }//$ 20</code></pre><h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><pre><code class="c++">typedef unsigned short uint16;// Read Bytes returns that 2 bytes got read. bool ByteBuffer::ReadUInt16(uint16&amp; val){  return ReadBytes(reinterpret_cast&lt;char*&gt;(&amp;val), 2);}int b = 1;char* bp1 = &amp;b; //  cannot convert &#39;int*&#39; to &#39;char*&#39; in initializationchar* bp2 = static_cast&lt;char*&gt;(&amp;b); // invalid static_cast from type &#39;int*&#39; to type &#39;char*&#39;char* bp3 = reinterpret_cast&lt;char*&gt;(&amp;b); // ok</code></pre>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-调试常用命令</title>
      <link href="/2021/01/Linux-%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/01/Linux-%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h2><p>查看实时信息</p><pre><code>yum install sysstat -y[root@fish ~]# iostatLinux 4.18.0-193.6.3.el8_2.x86_64    01/09/2021     _x86_64_    (4 CPU)avg-cpu:  %user   %nice %system %iowait  %steal   %idle           0.06    0.02    0.08    0.01    0.00   99.84Device             tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtnsda               0.00         1.68         0.00    3520393       3015sdb               0.16         0.81         2.68    1702968    5612922dm-0              0.17         0.79         2.78    1656682    5811573dm-1              0.00         0.00         0.01       4404      10828dm-2              0.00         0.00         0.00       1193       2209</code></pre><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>一般用于查看磁盘挂载等信息</p><pre><code>[root@fish ~]# df -hFilesystem           Size  Used Avail Use% Mounted ondevtmpfs             1.8G     0  1.8G   0% /devtmpfs                1.8G   84K  1.8G   1% /dev/shmtmpfs                1.8G   40M  1.8G   3% /runtmpfs                1.8G     0  1.8G   0% /sys/fs/cgroup/dev/mapper/cl-root   19G   13G  6.5G  67% //dev/sda             112G   34G   79G  30% /nas1/dev/mapper/cl-home  4.0G   61M  4.0G   2% /home/dev/sdb1            2.0G  211M  1.6G  12% /boottmpfs                368M     0  368M   0% /run/user/0</code></pre><h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>estimate file space usage</p><p>估计文件空间使用量 默认察看当前目录</p><pre><code>[root@fish ~]# du -h8.0K    ./book244K    ./.halo/logs72K    ./.halo/db36K    ./.halo/templates/themes/anatole/source/plugins/prism/css152K    ./.halo/templates/themes/anatole/source/plugins/prism/js188K    ./.halo/templates/themes/anatole/source/plugins/prism900K    ./.halo/templates/themes/anatole/source/plugins/gallery/fonts32K    ./.halo/templates/themes/anatole/source/plugins/gallery/css/images104K    ./.halo/templates/themes/anatole/source/plugins/gallery/css56K    ./.halo/templates/themes/anatole/source/plugins/gallery/js/ie180K    ./.halo/templates/themes/anatole/source/plugins/gallery/js1.2M    ./.halo/templates/themes/anatole/source/plugins/gallery1.4M    ./.halo/templates/themes/anatole/source/plugins72K    ./.halo/templates/themes/anatole/source/images1.1M    ./.halo/templates/themes/anatole/source/fonts80K    ./.halo/templates/themes/anatole/source/css356K    ./.halo/templates/themes/anatole/source/js2.9M    ./.halo/templates/themes/anatole/source24K    ./.halo/templates/themes/anatole/module3.1M    ./.halo/templates/themes/anatole</code></pre><h1 id="进程线程状态"><a href="#进程线程状态" class="headerlink" title="进程线程状态"></a>进程线程状态</h1><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>Linux下的任务管理器</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux/top.png" alt=""></p><pre><code class="shell">1 察看多核心CPU各个核心的情况P 按照CPU使用率排行T 按照CPU使用时间排行M 按照物理内存使用率排行top -p xx 察看指定pid的信息</code></pre><h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h2><p>更加现代的top 有颜色 支持鼠标 杀进程极其方便</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux/htop.png" alt=""></p><pre><code class="shell">sudo yum install epel-releasesudo yum install htop</code></pre><h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><p>跟踪进程运行时使用的系统调用和信号</p><pre><code class="shell">-t          每行前加上输出信息-tt         the time printed will include the microseconds.-ttt        开头部分将打印为自该纪元以来的秒数。 the time printed will include the microseconds-T          显示系统调用所需时间-o          输出文件-p          指定pid-f -F       跟踪fork和vfork</code></pre><p>strace -T -tt -p $(lsof -i tcp:4000 -t) -o /root/live.log</p><pre><code>17:27:51.212449 accept(5, {sa_family=AF_INET6, sin6_port=htons(1596), inet_pton(AF_INET6, &quot;::ffff:10.4.168.250&quot;, &amp;sin6_addr), sin6_flowinfo=htonl(0), sin6_scope_id=0}, [46-&gt;28]) = 7 &lt;0.000046&gt;17:27:51.212686 write(1, &quot;[INFO ][ TcpServer.cpp:56 ]: cre&quot;..., 95) = 95 &lt;0.000048&gt;17:27:51.212842 epoll_ctl(3, EPOLL_CTL_ADD, 7, {EPOLLIN, {u32=17383160, u64=17383160}}) = 0 &lt;0.000058&gt;17:27:51.213006 epoll_wait(3, [{EPOLLIN, {u32=17383160, u64=17383160}}], 50, 20) = 1 &lt;0.000028&gt;17:27:51.213131 recvfrom(7, &quot;GET /lsmg HTTP/1.1\r\nHost: live.l&quot;..., 4096, 0, NULL, NULL) = 358 &lt;0.000031&gt;17:27:51.213295 write(1, &quot;[INFO ][ main.cpp:67 ]: connecti&quot;..., 105) = 105 &lt;0.000038&gt;17:27:51.213461 write(1, &quot;[INFO ][ RtmpServerConnection.cp&quot;..., 144) = 144 &lt;0.000040&gt;17:27:51.213648 sendto(7, &quot;HTTP/1.1 200 OK\r\nServer: FISH_LI&quot;..., 703, 0, NULL, 0) = 703 &lt;0.000091&gt;17:27:51.213886 sendto(7, &quot;35d\r\n\0\0\0&lt;\10\0\3N\1-!\0\0\0\0\257\1!\fT-\3754\21\10\35\343&quot;..., 868, 0, NULL, 0) = 868 &lt;0.000030&gt;17:27:51.214032 epoll_wait(3, [{EPOLLIN, {u32=17360872, u64=17360872}}], 50, 20) = 1 &lt;0.005512&gt;17:27:51.219659 recvfrom(6, &quot;D\0\0\n\0}\354\t&#39;\1\0\0S\0\0}\343A\232\3534LG\377\363 \0\0\3\0\1,&quot;..., 4096, 0, NULL, NULL) = 4096 &lt;0.000057&gt;17:27:51.219857 epoll_wait(3, [{EPOLLIN, {u32=17360872, u64=17360872}}], 50, 20) = 1 &lt;0.000028&gt;17:27:51.219978 recvfrom(6, &quot;\266S\231C\363J\342(\304\274]\3361\354:~\37r\363\332&#39;\366\30\276\261\344\1\312\242\230R\t&quot;..., 4096, 0, NULL, NULL) = 4096 &lt;0.000029&gt;17:27:51.220117 epoll_wait(3, [{EPOLLIN, {u32=17360872, u64=17360872}}], 50, 20) = 1 &lt;0.000026&gt;17:27:51.220237 recvfrom(6, &quot;\0014O2hll\300&quot;, 8, 0, NULL, NULL) = 8 &lt;0.000026&gt;17:27:51.220371 epoll_wait(3, [{EPOLLIN, {u32=17360872, u64=17360872}}], 50, 20) = 1 &lt;0.000025&gt;17:27:51.220504 recvfrom(6, &quot;h\304\23\227&#39;c\341\355\263\330n\245\0021\3048\\\331n\226y\313\370Bu\371\242=\233\250\316\226&quot;..., 4096, 0, NULL, NULL) = 4096 &lt;0.000029&gt;17:27:51.220641 epoll_wait(3, [{EPOLLIN, {u32=17360872, u64=17360872}}], 50, 20) = 1 &lt;0.000025&gt;17:27:51.220762 recvfrom(6, &quot;\207&quot;, 1, 0, NULL, NULL) = 1 &lt;0.000026&gt;17:27:51.220895 epoll_wait(3, [{EPOLLIN, {u32=17360872, u64=17360872}}], 50, 20) = 1 &lt;0.000025&gt;17:27:51.221010 recvfrom(6, &quot;\324\304\260-\337\316\3261\311\260F\256\233\377\302\327\236\366\2249\3\361\273\r0H|\3415C]I&quot;..., 4096, 0, NULL, NULL) = 4096 &lt;0.000027&gt;</code></pre><h2 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h2><pre><code>[root@fish ~]# pstack $(lsof -i tcp:4000 -t)#0  0x00007f8b40e5b17b in epoll_wait (epfd=3, events=0x108dfb0, maxevents=50, timeout=20) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30#1  0x0000000000446668 in Epoll::LoopOnce (this=0x108df80, timeout=20, active_channels=0x7ffcbd1242f8) at /tmp/tmp.p1UxXqj1vP/network/multiplexing/Epoll.cpp:18#2  0x0000000000443d9c in EventLoop::Loop (this=0x7ffcbd1242f0) at /tmp/tmp.p1UxXqj1vP/network/EventLoop.cpp:31#3  0x0000000000438d48 in main (argc=3, argv=0x7ffcbd1244d8) at /tmp/tmp.p1UxXqj1vP/main.cpp:106</code></pre><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p><code>-i</code> 指定网卡</p><p><code>-nn</code> 不解析ip和port 显示原本的内容</p><p><code>-S</code>  绝对值显示偏移量</p><p><code>-vv</code> 显示详细的抓包数据</p><p><code>-vvv</code> 更详细的抓包数据</p><p><code>-w</code>  将结果保存到文件 可以通过wireshark观看</p><pre><code>tcpdump -i lo -nn &#39;port 9999&#39;15:02:37.187039 IP 127.0.0.1.56032 &gt; 127.0.0.1.9999: Flags [S], seq 2043028701, win 43690, options [mss 65495,sackOK,TS val 3620041058 ecr 0,nop,wscale 7], length 015:02:37.187060 IP 127.0.0.1.9999 &gt; 127.0.0.1.56032: Flags [S.], seq 2734721436, ack 2043028702, win 43690, options [mss 65495,sackOK,TS val 3620041058 ecr 3620041058,nop,wscale 7], length 015:02:37.187074 IP 127.0.0.1.56032 &gt; 127.0.0.1.9999: Flags [.], ack 1, win 342, options [nop,nop,TS val 3620041058 ecr 3620041058], length 015:02:37.187148 IP 127.0.0.1.56032 &gt; 127.0.0.1.9999: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 3620041058 ecr 3620041058], length 015:02:37.187560 IP 127.0.0.1.9999 &gt; 127.0.0.1.56032: Flags [.], ack 2, win 342, options [nop,nop,TS val 3620041059 ecr 3620041058], length 015:02:42.187421 IP 127.0.0.1.9999 &gt; 127.0.0.1.56032: Flags [F.], seq 1, ack 2, win 342, options [nop,nop,TS val 3620046058 ecr 3620041058], length 015:02:42.187448 IP 127.0.0.1.56032 &gt; 127.0.0.1.9999: Flags [.], ack 2, win 342, options [nop,nop,TS val 3620046058 ecr 3620046058], length 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pthread&amp;thread</title>
      <link href="/2021/01/CPP-pthread&amp;thread/"/>
      <url>/2021/01/CPP-pthread&amp;thread/</url>
      
        <content type="html"><![CDATA[<h1 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h1><h2 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h2><pre><code class="c++">void* Func(void* arg){    return nullptr;}void PthreadLinux(){    pthread_t thread1; // 存储线程标识    pthread_attr_t thread1_attr;    pthread_attr_init(&amp;thread1_attr);    pthread_create(&amp;thread1, &amp;thread1_attr, Func, nullptr); // 使用指定属性初始化线程    // pthread_create(&amp;thread1, nullptr, Func, nullptr); 使用默认属性初始化线程    printf(&quot;thread1-%d\n&quot;, thread1); // 1    pthread_join(1, nullptr);}</code></pre><h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><pre><code class="c++">void* Func(void* arg){    return nullptr;}class Foo{public:    void Bar(){printf(&quot;bar\n&quot;);};};void PthreadCpp(){    std::thread thread1(Func, nullptr);    thread1.join();    Foo foo;    std::thread thread2(std::bind(&amp;Foo::Bar, &amp;foo));    thread2.join();    std::thread thread3([&amp;foo](){        foo.Bar();    });    thread3.join();}</code></pre><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><h2 id="pthread-1"><a href="#pthread-1" class="headerlink" title="pthread"></a>pthread</h2><pre><code class="c++">pthread_mutexattr_t mutex_attr;pthread_mutex_init(&amp;mutex, &amp;mutex_attr);pthread_mutex_lock(&amp;mutex);pthread_mutex_unlock(&amp;mutex);pthread_mutex_destroy(&amp;mutex);</code></pre><h2 id="thread-1"><a href="#thread-1" class="headerlink" title="thread"></a>thread</h2><pre><code class="c++">void Foo(){    {        std::mutex mutex1;        std::lock_guard&lt;std::mutex&gt; lock_guard(mutex1);    }}</code></pre><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><h2 id="pthread-2"><a href="#pthread-2" class="headerlink" title="pthread"></a>pthread</h2><h2 id="thread-2"><a href="#thread-2" class="headerlink" title="thread"></a>thread</h2><pre><code class="c++">std::mutex condition_mutex;std::condition_variable var;void ConditionCpp(int id){    std::unique_lock&lt;std::mutex&gt; unique_lock(condition_mutex);    var.wait(unique_lock);    sleep(2);    printf(&quot;ConditionCpp id : %d\n&quot;, id);    unique_lock.unlock();    var.notify_one();}void ConditionCpp1(){    std::vector&lt;std::thread&gt; threads;    threads.reserve(5);    for (int i = 0; i &lt; 5; ++i)    {        threads.emplace_back([i]()        {            ConditionCpp(i);        });    }    var.notify_one();    int i = 0;    while (i &lt; 5)    {        for (auto&amp; thread : threads)        {            if (thread.joinable())            {                thread.join();                i++;            }        }    }}// ConditionCpp id : 0// ConditionCpp id : 1// ConditionCpp id : 2// ConditionCpp id : 3// ConditionCpp id : 4// Process finished with exit code 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本编写</title>
      <link href="/2021/01/Linux-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
      <url>/2021/01/Linux-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="第一行-解释器"><a href="#第一行-解释器" class="headerlink" title="第一行 - 解释器"></a>第一行 - 解释器</h1><ol><li><code>#!/bin/bash</code> 这个通常见于脚本的第一行, <code>#!</code>算是个约定了 说明脚本需要什么解释器</li><li><code>/bin/sh xx.sh</code> 这种是执行的时候指定, 脚本第一行的那个就失效了</li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>规范</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><p>shell变量类型</p><ul><li>局部变量</li><li>环境变量</li><li>shell变量-shell内置特殊变量</li></ul><p>变量定义 注意 不能随便加空格 下面的等号两侧不能加空格</p><pre><code class="shell"># 直接赋值xxx=&quot;lsmg&quot;xxx = &quot;lsmg&quot; # 错误xxx=&quot;Jigokubana&quot; # 随意修改# 语句赋值for skill in Ada Coffe Action Javado    echo &quot;I am good at ${skill}Script&quot;done# 使用变量echo $xxxecho ${xxx} # {} 用于标记边界echo &quot;my name is ${xxx}&quot;# constreadonly xxx=&quot;lsmg&quot; # 删除变量unset xxx; 不能用于删除只读变量</code></pre><h1 id="单引号-双引号-反引号"><a href="#单引号-双引号-反引号" class="headerlink" title="单引号 双引号 反引号"></a>单引号 双引号 反引号</h1><p>单引号将剥夺其中的所有字符的特殊含义</p><p>双引号中的<code>$</code>（参数替换）和`（命令替换）有特殊含义</p><p>反引号与$()功能相同会执行其中的命令</p><pre><code class="shell">aaa=&quot;aaa&quot;b1=&quot;$aaa&quot;b2=`$aaa` # 会先进行取变量值 $aaa -&gt; aaab3=&#39;$aaa&#39;echo $b1 # aaaecho $b2 # aaa: command not found echo $b3 # $aaa</code></pre><h1 id="数学和运算类"><a href="#数学和运算类" class="headerlink" title="数学和运算类"></a>数学和运算类</h1><pre><code class="shell">val1=$(expr $val1 + 1) # 自增1if [ $val1 -ge $val2 ] # 大小比较用 eq ge gt le lt ne</code></pre><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><p>读入参数的最佳命令 <code>read -p &quot;input val1: &quot; val1</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直播服务器</title>
      <link href="/2020/12/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-%E7%9B%B4%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/12/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-%E7%9B%B4%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h1><p><strong>使用C++17标准 Windows和Centos平台均使用gcc8.3编译通过正常使用</strong></p><p><strong>仅v1.0.0 版本支持Windows</strong></p><p><strong>运行后在两个推流者四个观看者情况下 占用内存6Mb CPU使用极低</strong></p><p><strong>支持IPV4和IPV6</strong></p><p>服务器端代码量 4000余行</p><p>HttpFlv拉流的播放器目前测试通过PotPlayer, VLC, flv.js</p><p>RTMP推流播放器仅测试过Obs</p><p>网络部分学习自 <a href="https://github.com/chenshuo/muduo" target="_blank" rel="noopener">https://github.com/chenshuo/muduo</a></p><p>跨平台支持学习自 <a href="https://github.com/balloonwj/flamingo" target="_blank" rel="noopener">https://github.com/balloonwj/flamingo</a></p><p>HTTP包装 RTMP解析 FLV解析 参考自网络相关文档</p><h1 id="项目规划"><a href="#项目规划" class="headerlink" title="项目规划"></a>项目规划</h1><p>开发轻量级Linux端的支持Rtmp推流HttpFlv拉流的服务端</p><p>项目不打算开发UI方面的功能, 视频将使用第三方的支持HttpFlv拉流的播放器来播放(如PotPlayer, flv.js)</p><h2 id="开发进度"><a href="#开发进度" class="headerlink" title="开发进度"></a>开发进度</h2><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>支持多个RTMP推流者推流(已完成)</p><p>支持多个HTTP-FLV拉流者拉取对应的流观看(已完成)</p><p>推流者身份鉴定 Mysql查询账号密码(已完成)</p><p>多线程支持(开发完成)</p><p>完善的日志库(开发完成)</p><h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><p><strong>安装Mysql库</strong></p><pre><code class="shell">yum install mysql-devel</code></pre><p><strong>配置main.cpp文件</strong></p><pre><code class="c++">// 修改数据库配置 main.cppif (!user_mapper_.Initialize(            &quot;127.0.0.1&quot;, &quot;lsmg&quot;, &quot;123456789&quot;, &quot;live&quot;)){    exit(-1);}// 可将main.cpp user_mapper_相关代码注释 修改OnAuthenticate函数 不使用Mysql配置</code></pre><p><strong>编译执行文件</strong><br>下载源代码后在Windows平台或者Linux平台编译</p><pre><code class="shell">git clone https://github.com/HiganFish/LiveBroadcast.gitcd LiveBroadcast/mkdir build &amp;&amp; cd buildcmake ..make -j4</code></pre><p>生成运行文件<code>LiveBroadcastServer</code></p><p><strong>运行服务器</strong></p><pre><code class="shell">./LiveBroadcastServer 4000 4100 # 4000 Rtmp推流端口 4100 HTTP-FLV拉流端口</code></pre><p><strong>Obs推流</strong></p><pre><code class="shell"># 设置-&gt;推流-&gt;服务器rtmp://[::1]:4000/test-push  # 注意 rtmp和http链接的对应关系 默认是相同的路径为同一个房间rtmp://127.0.0.1:4000/test-push # 可以在main.cpp中修改映射关系</code></pre><p><strong>HTTP-FLV拉流</strong></p><pre><code class="shell">http://[::1]:4000/test-push # 注意 rtmp和http链接的对应关系 默认是相同的路径为同一个房间http://127.0.0.1:4000/test-push # 可以在main.cpp中修改映射关系</code></pre><h1 id="项目所需技术"><a href="#项目所需技术" class="headerlink" title="项目所需技术"></a>项目所需技术</h1><h2 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h2><h3 id="FLV"><a href="#FLV" class="headerlink" title="FLV"></a>FLV</h3><p>FLV文件由一个FileHeader起头 后面为若干个FileTag 直到文件结束前四个字节<br>最后四个字节是上一个FileTag的大小减去4</p><p>FLV文件格式</p><pre><code>class FileHeader{    char flv[3]; // FLV    uint8_t version; // 1    uint8_t type_flags; // 5    uint32_t header_length; // 9};class FileTag{    uint32_t previous_tag_size; // 不含previous_tag_size  sizeof 上一个Tag - 4    uint8_t tag_type; // 音频 8 视频 9 scripts 18    uint8_t data_size[3]; // AudioTag VideoTag 的数据长度 从stream_id后开始算起    uint8_t timestamp[3];    uint8_t timestamp_extend;    uint8_t stream_id[3]; // 0    char* data;};</code></pre><p>前三个Tag可以认为有特殊作用 所以单独说一下</p><p>以后的所有Tag均为音视频数据</p><pre><code>FileHeader file_header; // 每次开始都要发送一次FileTag info_tag; // 每次开始都要发送一次FileTag sps_pps_tag; // 每次开始都要发送一次 第一个视频tag存储编码信息FileTag audio_tag; // 每次开始都要发送一次 第一个音频tag存储编码信息FileTag data[N]; // 真正的数据部分</code></pre><p>每次有<code>观看者客户端</code>连接的时候 都要发送一次<code>file_header</code>,<code>info_tag</code>和<code>sps_pps_tag</code> 以及<code>audio_tag</code>之后便是数据部分</p><h3 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h3><h4 id="RTMP握手协议"><a href="#RTMP握手协议" class="headerlink" title="RTMP握手协议"></a>RTMP握手协议</h4><p>Obs客户端首先会发送C1 服务器端直接将C1作为S1发送回去, Obs会发送C2 服务端继续发送C1作为S2 握手成功</p><p>商定窗口大小</p><pre><code>--&gt;connect&lt;-- Window Acknowledgement Size 5000000[02 00 00 00 00 00 04 05 00 00 00 00 00 4c 4b 40]&lt;-- Set Peer Bandwidth 5000000,Dynamic|Set Chunk Size 4096|_result(&#39;NetConnection.Connect.Success&#39;)[02 00 00 00 00 00 05 06 00 00 00 00 00 4c 4b 40 02][02 00 00 00 00 00 04 01 00 00 00 00 00 00 10 00][03 00 00 00 00 00 be 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 3f f0 00 00 00 00 00 00 03 00 06 66 6d 73 56 65 72 02 00 0d 46 4d 53 2f 33 2c 30 2c 31 2c 31 32 33 00 0c 63 61 70 61 62 69 6c 69 74 69 65 73 00 40 3f 00 00 00 00 00 00 00 00 09 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 1d 4e 65 74 43 6f 6e 6e 65 63 74 69 6f 6e 2e 43 6f 6e 6e 65 63 74 2e 53 75 63 63 65 73 73 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 15 43 6f 6e 6e 65 63 74 69 6f 6e 20 73 75 63 63 65 65 64 65 64 2e 00 0e 6f 62 6a 65 63 74 45 6e 63 6f 64 69 6e 67 00 00 00 00 00 00 00 00 00 00 00 09]</code></pre><p>建立流</p><pre><code>--&gt;releaseStream 此包中包含Obs设置的推流密钥 可用于获取后身份鉴定FCPublishcreateStream&lt;-- _result()[03 00 00 00 00 00 1d 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 40 10 00 00 00 00 00 00 05 00 3f f0 00 00 00 00 00 00]--&gt;publish&lt;-- onStatus(&#39;NetStream.Publish.Start&#39;)[05 00 00 00 00 00 69 14 01 00 00 00 02 00 08 6f 6e 53 74 61 74 75 73 00 00 00 00 00 00 00 00 00 05 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 17 4e 65 74 53 74 72 65 61 6d 2e 50 75 62 6c 69 73 68 2e 53 74 61 72 74 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 10 53 74 61 72 74 20 70 75 62 6c 69 73 68 69 6e 67 00 00 09]</code></pre><p>至此连接建立完毕, Obs开始推流</p><h4 id="RTMP推流协议部分"><a href="#RTMP推流协议部分" class="headerlink" title="RTMP推流协议部分"></a>RTMP推流协议部分</h4><p>RTMP的消息单元称为Message单个Message太大被拆分为多块 包装在Message Chunk中发送</p><p>所以服务器端需要从TCP流中获取Message Chunk组装出Message 再从Message中获取到音视频数据</p><h5 id="Message-Chunk"><a href="#Message-Chunk" class="headerlink" title="Message Chunk"></a>Message Chunk</h5><p><code>Message Chunk</code> = <code>Message Chunk Header</code> + <code>Chunk Data</code></p><p><code>Message Chunk Header</code> = <code>Basic Header</code> + <code>Message Header</code> + <code>extern timestamp</code></p><p>如以下例子</p><pre><code>0000   04 00 00 00 00 00 31 09 01 00 00 00 17 00 00 000010   00 01 64 00 28 ff e1 00 1d 67 64 00 28 ac d9 400020   78 02 27 e5 9a 80 80 80 a0 00 00 03 00 20 00 000030   07 91 e3 06 32 c0 01 00 04 68 ef bc b0</code></pre><p><strong>Basic Header</strong> </p><pre><code>04 = 00  00 0100// fmt = 0 csid = 4</code></pre><p>1字节 初期只关注csid为4的数据部分, 因为csid为4时对应音视频数据</p><p><strong>Message Header</strong></p><p>fmt = 0 11字节</p><pre><code>00 00 00 // timestamp00 00 31 // msglength09 // typeid 9视频01 00 00 00 // 小端存储  message stream id</code></pre><p>fmt = 1 7字节</p><pre><code>00 00 00 // timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳00 00 31 // msglength09 // typeid 9视频// 不含 message stream id 此时块与之前的块取相同的消息流ID</code></pre><p>fmt = 2 3字节</p><pre><code>00 00 00 // timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳// 不含 msglength 与前一个相同// 09 不含typeid 9视频// 不含 message stream id 此时块与之前的块取相同的消息流ID</code></pre><p>fmt = 3 0字节</p><pre><code>不含头 一个消息被分成多个的时候 使用这个类型</code></pre><p>至于<code>Chunk Data</code>就是Flv的data部分</p><p>Obs发送<code>@SetDataFrame()</code>其中Data为info_tag的data部分<br>Obs发送<code>Audio Data</code>其中Data为audio_tag的data部分  音频数据包<br>Obs发送<code>Video Data</code>其中Data为sps_pps_tag的data部分  视频数据包</p><p>之后便是正常画面声音的Flv数据发送.</p><h1 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h1><pre><code>├── CMakeLists.txt├── main.cpp├── mapper 包装mysql 提供用户验证│   ├── UserMapper.cpp│   └── UserMapper.h├── mysql   包装基础mysql api│   ├── DbMysql.cpp│   ├── DbMysql.h│   ├── Field.cpp│   ├── Field.h│   ├── QueryResult.cpp│   └── QueryResult.h├── network 网络相关│   ├── Acceptor.cpp│   ├── Acceptor.h│   ├── Callback.h│   ├── Channel.cpp│   ├── Channel.h│   ├── Connector.cpp│   ├── Connector.h│   ├── EventLoop.cpp│   ├── EventLoop.h│   ├── EventLoopThread.cpp│   ├── EventLoopThread.h│   ├── EventLoopThreadPool.cpp│   ├── EventLoopThreadPool.h│   ├── InetAddress.cpp│   ├── InetAddress.h│   ├── multiplexing 多路复用│   │   ├── Epoll.cpp│   │   ├── Epoll.h│   │   ├── MultiplexingBase.cpp│   │   ├── MultiplexingBase.h│   │   ├── Select.cpp│   │   └── Select.h│   ├── protocol Rtmp和HttpFlv连接管理│   │   ├── RtmpClientConnection.cpp│   │   ├── RtmpClientConnection.h│   │   ├── RtmpServerConnection.cpp│   │   └── RtmpServerConnection.h│   ├── Socket.cpp│   ├── Socket.h│   ├── SocketOps.cpp│   ├── SocketOps.h│   ├── TcpClient.cpp│   ├── TcpClient.h│   ├── TcpConnection.cpp│   ├── TcpConnection.h│   ├── TcpServer.cpp│   └── TcpServer.h├── README.md├── test 测试文件│   ├── CMakeLists.txt│   ├── Connector│   │   └── ConnectorTest.cpp│   ├── DbMysql│   │   └── DbMysqlTest.cpp│   ├── EventLoopThread│   │   └── EventLoopThreadTest.cpp│   ├── Logger│   │   └── LoggerTest.cpp│   ├── Main│   │   ├── 2.data.back│   │   └── MainTest.cpp│   ├── TcpServer│   │   └── TcpServerTest.cpp│   ├── Thread│   │   └── ThreadTest.cpp│   └── UserMapper│       ├── live_user.sql│       └── UserMapperTest.cpp├── thread 线程库包装│   ├── Condition.cpp│   ├── Condition.h│   ├── CurrentThread.cpp│   ├── CurrentThread.h│   ├── Mutex.cpp│   ├── Mutex.h│   ├── Thread.cpp│   ├── Thread.h│   ├── ThreadPool.cpp│   └── ThreadPool.h└── utils├── Buffer.cpp├── Buffer.h├── codec Rtmp和Flv的编解码器│   ├── FlvCodec.cpp│   ├── FlvCodec.h│   ├── FlvManager.cpp│   ├── FlvManager.h│   ├── RtmpCodec.cpp│   ├── RtmpCodec.h│   ├── RtmpManager.cpp│   ├── RtmpManager.h│   └── test│       ├── FlvManagerTest.cpp│       └── RtmpManagerTest.cpp├── File.cpp├── File.h├── Format.cpp├── Format.h├── Logger.cpp├── Logger.h├── Timestamp.cpp└── Timestamp.h</code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目制作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>由muduo tie引出的 delete this</title>
      <link href="/2020/11/%E9%87%87%E5%9D%91%E8%AE%B0-delete%20this/"/>
      <url>/2020/11/%E9%87%87%E5%9D%91%E8%AE%B0-delete%20this/</url>
      
        <content type="html"><![CDATA[<p>在半个多月以前 看完了深度探索C++对象模型, 然而只是粗略的过了一遍. 并没有结合具体的例子去深刻的理解下</p><p>如果delete this 不会遇到 那这样呢?</p><pre><code class="c++">#include &lt;cstdio&gt;void Delete();class Foo{public:    Foo()    {        bar_ = 111111;    }    ~Foo()    {        printf(&quot;~Foo()\n&quot;);    }    void Bar1()    {        printf(&quot;Bar1()\n&quot;);    }    void Bar()    {        Delete();        printf(&quot;bar: %d\n&quot;, bar_);        Bar1();    }    int bar_;};Foo* foo = nullptr;bool del = false;void Delete(){    if (!del)    {        del = true;        delete foo;    }}int main(){    foo = new Foo;    foo-&gt;Bar();    printf(&quot;\n&quot;);    foo-&gt;Bar();    return 0;}  </code></pre><p>程序安然的结束了, 但是发现 成员变量bar的值已经被初始化了, 由于delete释放了内存.</p><pre><code>~Foo()bar: 0Bar1()bar: 0Bar1()</code></pre><p>同时delete是两步操作</p><ol><li>调用对象的析构函数 (析构函数中调用 会导致递归)</li><li>释放相关空间</li></ol><p><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this" target="_blank" rel="noopener">官方解释</a></p><p><strong>成员变量指针类型</strong></p><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;functional&gt;class Foo{public:    void Bar1()    {        if (bar_)        {            bar_();        }    }    void Bar2()    {        bar_();    }    std::function&lt;void()&gt; bar_;};Foo* foo = nullptr;void PrintfBar(){    printf(&quot;Bar\n&quot;);}int main(){    foo = new Foo;    foo-&gt;bar_ = PrintfBar;    foo-&gt;Bar1(); // Bar    foo-&gt;Bar2(); // Bar    delete foo;    foo-&gt;Bar1(); // Segmentation fault (core dumped)    foo-&gt;Bar2();    return 0;}</code></pre><p>测试后所有对指针型成员变量的 解引用操作都会导致<code>Segmentation fault (core dumped)</code> 所以下面的代码也有了解释</p><p>一个困扰我很久的BUG 即为程序会在HandleEvent触发<code>Segmentation fault (core dumped)</code>的原因找到了</p><pre><code class="c++">void Channel::HandleEvent(){    /**     * lock增加TcpConnectionPtr的引用计数 防止从TcpServer中erase后 直接销毁TcpConnection     *     * 否则如果不增加引用计数 当TcpConnection被销毁后, 所管理的Channel也将会被销毁     * 在这之后 不能再使用TcpConnection和Channel的任何 成员函数和成员变量     *     * 有点类似于在一个 new出来的对象的成员函数中 delete自己     * 详见 https://stackoverflow.com/questions/7039597/what-will-happen-if-you-do-delete-this-in-a-member-function     *     * 经过查阅后自己对深度探索C++对象模型 有了更深得理解     */    std::shared_ptr&lt;void&gt; guard = tie_.lock();    if (!guard)    {        LOG_WARN(&quot;connection: %s is closed&quot;, connection_name.c_str());    }    if (event_ &amp; XEPOLLIN)    {        if (readable_callback_)        {            readable_callback_();        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 采坑记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 采坑记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP框架底层原理实现</title>
      <link href="/2020/11/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-HTTP%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2020/11/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-HTTP%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>后端组使用各种框架</p><ul><li>Java的Springboot</li><li>Python的Django</li></ul><p>框架的底层原理是什么? 当然涉及原理性的东西太多了, 我这里指的是为什么客户端的几次简单点击 最终会转化成了后端的函数调用?</p><p>Springboot针对某一个URL能Get Post等等设置对应的方法. 还能得到指定的参数?</p><p>客户端的几下简单的点击就能够将数据传送到后端 从后端拿回数据然后进行显示</p><p>后端也只要在相关的函数后处理接收到的数据</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>要解释上面的问题需要用到计算机学院几门专业课的只是 &lt;操作系统&gt; &lt;计算机组成原理 跳过&gt; &lt;计算机网络&gt;</p><p>基础知识我要不要学? HTTP协议? DNS怎么发挥的作用?</p><p>GET POST 有什么区别? 为什么GET有参数长度限制(自己本以为是RFC规定 然而是浏览器规定的而且是URL长度限制而不是参数限制) 而POST没有参数长度限制<br>新了解到了</p><p>无法访问网页怎么办? 可以根据浏览器访问流程进行排查</p><p>校园网断网跳转怎么实现的? DNS污染又是什么? <em>返回错误的IP</em></p><p>favicon? 如何实现的自动加载 <em>GET /favicon.ico HTTP/1.1</em></p><p>抓包的原理</p><h1 id="浏览器访问流程"><a href="#浏览器访问流程" class="headerlink" title="浏览器访问流程"></a>浏览器访问流程</h1><p>当你输入一个网址, 按下回车后 首先会向DNS服务器发送DNS请求将域名转换成IP. <em>DNS污染</em></p><p>然后向 IP+端口号 <strong>建立连接 强调!</strong> 发送HTTP请求 (HTTP默认是80端口) 接收HTTP回应 进行解析HTML 然后请求相关的JS文件等</p><p>然而收发HTTP并不是 操作系统提供的基础API的功能 那是怎么来的?</p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>协议是什么?</p><p>文本协议</p><pre><code>GET  HTTP/1.1Host: 10.2.5.251Connection: keep-aliveDNT: 1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8GET / HTTP/1.1Host: www.baidu.comConnection: keep-aliveDNT: 1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8Cookie: BIDUPSID=275AD930CBDC20F9C9E074230710B72E; PSTM=1602485007; BAIDUID=93E8E77E51A5F22CA01131559BA8666A:FG=1; BD_UPN=12314753; BDUSS=BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BDUSS_BFESS=BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BAIDUID_BFESS=F500721F63FBCA4EDC7DA170AE314FEE:FG=1; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; COOKIE_SESSION=332523_0_8_0_3_6_1_0_7_4_42_0_332523_0_6_0_1604291277_0_1604291271%7C8%230_0_1604291271%7C1; sug=3; sugstore=0; ORIGIN=0; bdime=0; ZD_ENTRY=googlePOST http://202.119.196.6:8080/Self/login/verify HTTP/1.1Connection: keep-aliveCache-Control: max-age=0Origin: http://202.119.196.6:8080Upgrade-Insecure-Requests: 1DNT: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://202.119.196.6:8080/Self/login/?302=LIAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8Host: 202.119.196.6:8080Accept-Encoding: gzip, deflate, brContent-Length: 60Cookie: JSESSIONID=E56420ED06E0ABE922C5A904DBB9C944foo=&amp;bar=&amp;checkcode=1234&amp;account=08180000&amp;password=md5&amp;code=HTTP/1.1 200 OKDate: Sat, 31 Dec 2005 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 122&lt;html&gt;&lt;head&gt;&lt;title&gt;Wrox Homepage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- body goes here --&gt;HTTP/1.1 200 OK Date: Sat&lt;/body&gt;&lt;/html&gt;</code></pre><p>根据这个格式<em>描述一下格式</em> 请求方法 请求路径 HTTP版本</p><p>HEADER部分 需要什么HEADER加入什么</p><p>BODY部分 放入数据</p><p>所根据的这个格式 这个规定就叫做协议 HTTP的规定就是HTTP协议</p><p>所以说你在手机上查询电费也好 电脑上浏览网页也罢 前端调用后端也是如此 只要是HTTP的API 都会将数据按照这个格式进行打包</p><ol><li><strong>建立连接后</strong>   Fiddler监听拦截的数据, 你知道了这个包的数据都有什么 然后自己建立连接发送同样的包 效果是一样的</li><li>发送打包的数据 </li><li>接收服务器返回的结果</li><li>所以可以抓包后模拟请求这就这么来的</li></ol><h1 id="从TCP看HTTP"><a href="#从TCP看HTTP" class="headerlink" title="从TCP看HTTP"></a>从TCP看HTTP</h1><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%83%E5%B1%82%E5%92%8C%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE.png" alt=""></p><p><em>将根据这张图说一说, 经常让了解的 七层和四层协议.  (网络访问(链接)层)</em></p><p>上边面说的建立连接建立的实际是TCP连接</p><p>TCP连接是通过 IP和端口号建立的 正好使用的上面的IP和端口号</p><p>TCP连接干什么?  连接就是传输数据 这就涉及到了读写操作  全双工</p><p>两个套接字之间的通信 客户端持有一个套接字 服务器持有一个套接字 然后客户端的数据发送和服务器端的数据接收就是转化为了针对套接字的读写</p><p>套接字你可以理解为 两个电话互相通话</p><p>套接字的建立和管理都比较复杂, 但是流程极为固定 干脆将这些代码包装起来 对外界提供一个简单的函数即可 内部帮你管理建立TCP连接</p><p>客户端指的就是你的浏览器也好, 你的应用也好 套接字这个核心的东西被包装了起来</p><p>所以输入网址也好, 使用form标签也罢. 最终都是根据HTTP协议包装你想要发送或者接受的数据. 建立TCP连接 然后将包装好的数据发送到套接字 对方从套接字接受 (流, 流水 按顺序流入)</p><p><em>nc 命令 演示演示?</em></p><p>所以你可以没有域名 照样可以使用HTTP协议 照样访问网页.</p><p>因为HTTP交互的核心就是 根据HTTP协议包装数据 经由TCP连接收发数据 TCP连接使用的是 IP和端口号 而非域名</p><p>域名就没有用了吗? 除了便于记忆? <em>域名 区分作用</em></p><h1 id="HTTP框架"><a href="#HTTP框架" class="headerlink" title="HTTP框架"></a>HTTP框架</h1><p>上面说了HTTP交互细节. 本质就是的收发</p><pre><code>GET /api?a=1&amp;b=2 HTTP/1.1Host: 10.2.5.251Connection: keep-aliveDNT: 1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8HTTP/1.1 200 OKDate: Sat, 31 Dec 2005 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 122＜html＞＜head＞＜title＞Wrox Homepage＜/title＞＜/head＞＜body＞＜!-- body goes here --＞＜/body＞＜/html＞</code></pre><p>服务器端从套接字 接收到数据后 大家没有见过上面的东西吧</p><p>那就是框架接受之后 把它们作为字符串存了起来 然后按照HTTP的固定协议格式 将内容解析</p><p>必须解析的一般有 Get /api?a=1&amp;b=2  然后得知了这是一个GET请求 请求的URL是 /api 有两个参数 叫什么 值是多少</p><p>然后根据你服务器代码设定的找到一个对应的函数, 框架调用这个函数 传入参数 你就可以处理相应的逻辑了.</p><h1 id="库和框架"><a href="#库和框架" class="headerlink" title="库和框架?"></a>库和框架?</h1><p>库是帮你提供某些功能的包装, 单个库一般并不能开发完整的应用, 只是作为一部分功能函数. curl库 线程库</p><p>框架可以理解为库的升级版, 你使用一个框架提供的函数 就能开发完整的应用, 大多数框架还能方便的引入其他的库来供自己使用.</p><h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx?"></a>nginx?</h1><p>nginx大家用过没有?</p><p>一般逻辑都是设置一个域名 然后指向一个端口 是不是?</p><p>域名这个东西就藏在了HTTPRequest的 header里 他同样从TCP连接接收数据 解析 便知道了域名 然后根据配置转发即可</p><h1 id="要不要学基础知识"><a href="#要不要学基础知识" class="headerlink" title="要不要学基础知识?"></a>要不要学基础知识?</h1><p>端口 计算机网络 组装nas计网</p><p>网线到内核 操作系统和计算机组成原理</p><h1 id="自学能力"><a href="#自学能力" class="headerlink" title="自学能力"></a>自学能力</h1><p>我大一来的工作室 来的时候是远爷带我学的JavaWeb. </p><p>随便找了本Java书给划一下看哪里</p><p>给我指明了一个框架, 然后呢? 去学呗</p><p>百度-&gt;谷歌中文-&gt;谷歌英文 <a href="https://translate.google.cn/" target="_blank" rel="noopener">https://translate.google.cn/</a></p><p>知乎 百度 谷歌 Github StackOverflow 等等</p><p>遇到问题先百度</p><ul><li>视频?</li><li>看书?</li><li>文档?</li></ul><p>大二转LinuxC++ 全部都是从零开始 没有人带我</p><h1 id="大学生"><a href="#大学生" class="headerlink" title="大学生"></a>大学生</h1><p>垃圾xxxA4 我就是不想学.</p><p>写博客?</p><p>人外有人天外有天</p><p>让自己一天比一天更加优秀 提升自己</p><p>平衡自己时间  爆肝程序<br>社交 我用大二上的社交换到了Linux入门 我退出了xxxx</p><p>大三上减肥(身高), 参加活动, 锻炼身体, 找对象? 规律作息</p><p>穿搭</p><p>多多质疑 乳酸菌饮料?</p><p>不要被轻易带节奏 12:55秒 <a href="https://www.bilibili.com/video/BV1jV411o7VV" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1jV411o7VV</a></p>]]></content>
      
      
      <categories>
          
          <category> 分享会 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>远程连接宿舍电脑</title>
      <link href="/2020/10/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%AE%BF%E8%88%8D%E7%94%B5%E8%84%91/"/>
      <url>/2020/10/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%AE%BF%E8%88%8D%E7%94%B5%E8%84%91/</url>
      
        <content type="html"><![CDATA[<p>学校机房电脑配置低? 卡慢?</p><p>学习机房电脑没有自己电脑环境用着顺手?</p><p>你还在担心使用机房电脑后需要拷贝代码到U盘或者QQ吗?</p><p><del>机房电脑玩大型游戏?</del></p><p>使用远程连接吧!</p><h1 id="向日葵等"><a href="#向日葵等" class="headerlink" title="向日葵等"></a>向日葵等</h1><p>优点: 不需要公网IP就能使用, 安装使用非常方便<br>缺点: 由于数据交互经过了向日葵的服务器导致延迟较高?</p><h1 id="Win10自带远程连接"><a href="#Win10自带远程连接" class="headerlink" title="Win10自带远程连接"></a>Win10自带远程连接</h1><p>优点: 内网使用延迟极低, 就像直接操作远在其他地方的笔记本一样<br>缺点: 需要内网使用, 配置较为繁琐.</p><p>针对内网这一问题, 学校机房, 学校stuwifi, 宿舍网线都是同一内网(得益于三网通一, 没想到这货还有这样的好处), 所以最大的问题解决了.</p><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>必须确保电脑为专业版  最好是正版专业版盗版可能会有账户配置等问题 自行查阅.</p><p>任务栏左下角Win10图标右击, 打开设置 –&gt; 更新和安全 –&gt; 选择激活  确保显示的为专业版<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%93%E4%B8%9A%E7%89%88.png" alt=""></p><p>可惜大部分笔记本都是家庭版, 我这里只推荐一种方法家庭版升级专业版. 其他方法自行百度尝试</p><p>去淘宝购买<strong>家庭版升级专业版Win10密钥</strong>注意不是简单的专业版就行了必须写着<strong>升级</strong>, 详细咨询客服吧</p><p>大概15软妹币左右即可拥有正版Win10专业版, 而且不需要重装系统C盘不会动.</p><p>购买密钥后 在更新和安全的激活那里选择<strong>更改产品密钥</strong> 输入确认即可.</p><h2 id="自己电脑开启远程连接"><a href="#自己电脑开启远程连接" class="headerlink" title="自己电脑开启远程连接"></a>自己电脑开启远程连接</h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.png" alt=""></p><p>桌面我的电脑(此电脑) 右击选择属性-&gt;远程设置-&gt;勾选图示三个对勾.</p><h2 id="确认电脑IP"><a href="#确认电脑IP" class="headerlink" title="确认电脑IP"></a>确认电脑IP</h2><p>cmd输入ipconfig记录好自己的IPV4地址和IPV6地址 IPV6不要记录临时地址</p><p>IPV6地址永远不会变,  且<strong>无论电脑是否登录都能使用</strong>, 但是机房电脑没有IPV6</p><p>IPV4地址可能会改变, 需要<strong>10.2.5.251电脑登录后</strong>才能使用 推荐设置静态IPV4地址或者每次使用记录下IPV4</p><h2 id="机房电脑设置"><a href="#机房电脑设置" class="headerlink" title="机房电脑设置"></a>机房电脑设置</h2><p>机房电脑任务栏左下角的Win10图标右侧的搜索(放大镜标志) –&gt; 输入<strong>远程</strong>二字-&gt;选择弹出来的<strong>远程桌面连接</strong>-&gt;输入<strong>IPV4</strong>地址</p><p>确保宿舍电脑联网的情况下 点击连接就提示让你输入账号密码.  账号和密码是你Win10账户的账号和密码. 输入账号密码就连接成功了.</p><h2 id="其他建议选项"><a href="#其他建议选项" class="headerlink" title="其他建议选项"></a>其他建议选项</h2><ol><li>宿舍建议直插网线, 宿舍电脑使用Wifi可能有延迟感觉</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分享会 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UNP记录</title>
      <link href="/2020/10/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-UNP/"/>
      <url>/2020/10/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-UNP/</url>
      
        <content type="html"><![CDATA[<p>由于已经在Linux高性能服务器开发中详细说明过绝大部分系统函数</p><p>Linux高性能服务器开发的重叠部分, 我会将新的点补充到原博客中, 这里仅作部分简单的说明</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>通过定义<code>包裹函数</code>可以缩短程序. 在muduo框架中就存在包裹函数 将系统函数进行包装</p><p>函数中进行错误处理, 这样外部使用<code>包裹函数</code>包装好的系统函数的时候可以简化错误处理</p><p><strong>daytimecpclient-domain.cpp</strong><br>第一个样例程序稍作修改 可以解析域名  inet_addr没有请求网络 速度快 而gethostbyname会请求域名<br>服务器速度可能慢</p><pre><code class="c++">sockaddr_in server_addr{};if ((server_addr.sin_addr.s_addr = inet_addr(argv[1])) == INADDR_NONE){    struct hostent* hostptr = gethostbyname(argv[1]);    if (!hostptr)    {        printf(&quot;invalid input %s\n&quot;, argv[1]);        exit(1);    }    server_addr.sin_addr.s_addr = *((unsigned long*)hostptr-&gt;h_addr);}</code></pre><p>迭代服务器: 对于每个客户连接都执行迭代一次<br>并发服务器: 同时处理多个客户连接</p><h1 id="第二章-传输层"><a href="#第二章-传输层" class="headerlink" title="第二章 传输层"></a>第二章 传输层</h1><p>客户端 主动调用close之后 发送了FIN包</p><p>服务端 接收到FIN包后read返回0</p><p>服务器 read返回0之后调用close函数 发送FIN包</p><p>客户端 接收服务器的FIN包</p><p><strong>@@35 P TCP状态转换图@@</strong></p><p><strong>@@36 P TCP状态转换和Socket函数间的联系@@</strong></p><p>多宿主计算机  可能插有多块网卡</p><p>通过bind到INADDR_ANY来监听多个接口的同一个端口</p><h1 id="第三章-套接字编程简介"><a href="#第三章-套接字编程简介" class="headerlink" title="第三章 套接字编程简介"></a>第三章 套接字编程简介</h1><p>大多数套接字函数 都需要一个指向<code>套接字地址结构</code>的指针作为参数. 每个协议簇都定义了他自己的<code>套接字地址结构</code>. 这些结构的名字均<code>以sockaddr_开头</code></p><p><strong>@@61 P 不同套接字地址结构的比较@@</strong></p><h1 id="第四章-基本TCP套接字编程"><a href="#第四章-基本TCP套接字编程" class="headerlink" title="第四章 基本TCP套接字编程"></a>第四章 基本TCP套接字编程</h1><p><strong>connect函数</strong></p><p>ETIMEDOUT: 客户端没有收到SYN的回应 尝试几次后如果依然没有收到回应则返回错误</p><p>ECONNREFUSED: 服务器在指定端口上没有进程等待与之连接导致收到了RST回复  之后立即返回错误</p><p>connect失败之后 此套接字无法继续使用 需要close当前套接字后重新调用socket</p><p><strong>bind函数</strong></p><p>如果调用listen或者connect前没有调用bind则操作系统会分配一个临时端口. 对于客户端来说可以接受临时端口, 然而服务器一般都是需要指定端口 供外接连接. </p><p>如果指定的端口为0 则认为没有指定端口 会分配临时端口. 如果地址指定为0(INADDR_ANY) 则系统选择IP地址</p><p>RPC服务器可以使用临时端口, 但必须将临时端口注册到端口映射器, 这样客户端才能得到对应的临时端口, 之后进行连接</p><p>可以使用getsockname获取到系统临时分配的地址和端口</p><p><strong>listen函数</strong></p><p>socket函数创建的套接字默认被认为是主动套接字(准备调用connect) 使用listen函数将一个<code>未连接</code>的套接字转换成一个被动套接字</p><p>内核为一个监听的系统套接字维护两个队列</p><ul><li>未完成队列 已经收到了SYN但还未完成三次握手</li><li>已完成队列 已经进行了三次握手<code>等待accept从队列中取走</code> 已建立的连接 如果<code>此队列为空, accept阻塞</code></li></ul><p>未完成队列+已完成队列的总长度 即为listen函数的第二个参数backlog</p><p>connect函数调用 -&gt; 服务器收到了SYN包 -&gt; 在未完成队列创建相关内容 -&gt; 创建完毕后返回SYN和ACK -&gt; 客户端返回ACK -&gt; 从未完成队列移动到已完成队列队尾</p><p><a href="https://blog.csdn.net/yangbodong22011/article/details/60399728" target="_blank" rel="noopener">https://blog.csdn.net/yangbodong22011/article/details/60399728</a></p><p>实际用Centos(内核为4.18版本)测试后, 实际情况为上方博客的情况. 即backlog是已完成队列大小, 而且会存在+1</p><p>看到这里后想到之前遇到的一个BUG, 注册入<code>epollfd</code>中的<code>listenfd</code>没有设置成<code>ENONBLOCK</code>, <code>epoll_wait不会返回, 进而去调用accept</code>, 然而客户端<code>connect</code>函数返回显示已经建立连接.  –也就是connect返回说明连接建立, 发生在accpet函数调用前.</p><p>当客户端发送FIN后服务器read类函数返回0</p><p><strong>@@91 P exec函数之间的关系@@</strong></p><p><strong>accept函数</strong><br>accpet函数的第一个参数必须是 被动套接字 即调用过listen, 否则返回EINVAL错误</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>正常启动 正常终止时程序的表现与TCP协议的关系</p><p>慢系统调用: 适用于那些可能永远阻塞的系统调用, accpet(没有新连接就一直阻塞), read(读取不到一直阻塞)等等.</p><p>EINTR: 当阻塞于某个慢系统调用的进程, 捕获某个信号且相应信号处理函数返回时, 慢系统调用<code>可能</code>返回一个EINTR错误</p><p>诸如read, write, select等来说可以忽略EINTR, 如下方这个常见的代码片段. <strong>但是connect则不行, 否则立即返回错误??</strong></p><pre><code class="c++">ssize_t result = read(fd, buffer, sizeof buffer);if (errno == EINTR){  continue;}</code></pre><p>如果同时有N个SIGCHLD信号到达, 信号处理函数极可能执行不够N次.</p><ul><li>UNIX信号没有排队概念</li><li>问题导致的结果不确定, 即不确定调用多少次</li></ul><pre><code class="c++">void sigchld_handler(int signo){  pid_t pid;  int stat;  while ((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0)  {    process  }  return;}</code></pre><p>使用waitpid来获取所有已终止进程状态, 并且指定了<code>WNOHANG</code>防止不必要的阻塞.</p><p>而wait则不能在这里替换waitpid, 因为wait只能阻塞</p><p><strong>第五章 正常启动 正常终止 accept返回前终止 服务器进程终止 服务主机崩溃 主机崩溃后重启 主机关机</strong></p><h1 id="第六章-I-O-复用-select和poll函数"><a href="#第六章-I-O-复用-select和poll函数" class="headerlink" title="第六章 I/O 复用 select和poll函数"></a>第六章 I/O 复用 select和poll函数</h1><p>进程需要一种预先告知内核的能力, 使得内核一旦发现进程指定的一个或多个I/O条件就绪, 他就通知进程. –IO复用</p><p>UNIX可用的五种IO模型</p><ul><li>阻塞式I/O</li><li>非阻塞式I/O</li><li>I/O复用</li><li>信号驱动式I/O(SIGIO)</li><li>异步I/O(POSIX的aio_系列函数)</li></ul><p>前四种都是同步IO, 因为他们在真正的IO阶段read,readfrom等导致了阻塞<br>只有异步IO模型才是异步IO</p><p><strong>@@低水位标记 ?@@</strong></p><h2 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h2><p>尽管timeval允许指定一个微秒级的分辨率, 但是真实的分辨率吗…… 部分实现的粗糙一些. 并且还有<code>调度延迟(定时器结束后, 内核还需要花时间调度相应进程运行)</code></p><p>struct fd_set 一个集合,可以存储多个文件描述符<br>内部是一个32位整数的数组, 数组第一个元素对应0<del>31描述符 一个二进制位代表一个描述符<br>数组第二个元素对应32</del>63 以此类推</p><p>可读条件</p><ul><li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li><li>socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0</li><li>监听socket上有新的连接请求</li><li>socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1</li></ul><p>可写条件</p><ul><li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, <strong>且套接字已经连接, 或套接字不需要连接UDP</strong></li><li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li><li>socket使用非阻塞connect 连接成功或失败后</li><li>socket上有未处理的错误 套接字的写操作不阻塞 并返回-1</li></ul><p>异常条件</p><ul><li>发送带外数据</li></ul><p>当select返回可读事件后 如果不进行处理 则下次select调用会继续返回</p><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><ol><li>close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列</li><li>close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕</li></ol><h1 id="第七章-套接字选项"><a href="#第七章-套接字选项" class="headerlink" title="第七章 套接字选项"></a>第七章 套接字选项</h1><h1 id="第八章-基本UDP套接字编程-未看"><a href="#第八章-基本UDP套接字编程-未看" class="headerlink" title="第八章 基本UDP套接字编程 (未看)"></a>第八章 基本UDP套接字编程 (未看)</h1><h1 id="第十一章-名字和地址转换"><a href="#第十一章-名字和地址转换" class="headerlink" title="第十一章 名字和地址转换"></a>第十一章 名字和地址转换</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度探索C++对象模型</title>
      <link href="/2020/09/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95135-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/09/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95135-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-关于对象"><a href="#第一章-关于对象" class="headerlink" title="第一章 关于对象"></a>第一章 关于对象</h1><p>加上封装之后的成本增加了吗?</p><p>并没有增加成本, C++在布局以及存取时间上主要的额外负担是由virtual引起的</p><ul><li>virtual func机制 用来支持一个有效率的执行期绑定</li><li>virtual base class 用来实现多次出现在继承体系中的base class, 有一个单一而被共享的实例</li></ul><p>C++ 有两种成员变量<code>static</code>和<code>nonstatic</code><br>三种成员函数<code>static</code>, <code>nonstatic</code>和<code>virtual</code></p><h1 id="第三章Data语义学"><a href="#第三章Data语义学" class="headerlink" title="第三章Data语义学"></a>第三章Data语义学</h1><pre><code class="c++">class Foo{};Foo foo;</code></pre><p><code>sizeof foo = ?</code>答案是1， 这是为了防止不同的对象却有相同的地址</p><p>同时class也存在<code>字节对齐</code>现象</p><p>在针对虚拟继承问题的时候</p><pre><code>D对象的内存结构  从低地址开始D对象数据部分  《- D类对象指针 dptr 指向这里 可以从vptr指向的表中获取A对象数据部分的偏移量 offsetC对象数据部分B对象数据部分A对象数据部分  《- dptr + offset 则实现了 子类指针向父类指针的转化</code></pre><p>A 派生出 B C。 B C派生出D  如何保证在BC对象中都有A对象， 而在D对象中只有一个A对象？</p><p>一种方法是 </p><p>先安排派生类的部分 再后接基类的部分， 这样派生类D的对象指针就是指向自己数据部分的指针</p><p>如果想要实现子类向父类转换呢？</p><p>在vtpr指向的表中的 -1 位置放置偏移量， 由于D类对象的指针是内存开始位置 如果要转换成A类指针</p><p>则从D类对象的vptr指向的表中获取A类数据部分的偏移量 这样就实现了子类向父类转换</p><pre><code class="c++">class Foo{public:    int x;    int y;    int z;};int main(){    printf(&quot;&amp;Foo::x = %p\n&quot;, &amp;Foo::x);  // 0x0    printf(&quot;&amp;Foo::y = %p\n&quot;, &amp;Foo::y); // 0x4    printf(&quot;&amp;Foo::z = %p\n&quot;, &amp;Foo::z); // 0x8    return 0;}</code></pre><p>如果x， y， z定义为protected或者private则会报错。public得到的是其在类内的偏移地址</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><p>name-mangling</p><p>不要将mangling之后的结果显示给用户看，这样用户会疑惑哪里来的这个函数（大体来说 我们采纳了他的建议）</p><p>static member func 并不是比 nonstatic member func效率高 后者也会转换成类似前者的调用。 </p><p>static member func的主要特征就是他没有<code>this指针</code> </p><ul><li>所以它不能存取nonstatic member </li><li>不能被声明为const 因为const成员函数最终转化成了 const修饰的this指针</li><li>不需要通过对象来调用， 因为他不需要this指针</li></ul><p>C++中多态表示以一个public base class的指针（或reference）寻址出一个derived class object。这样就实现了多态的函数调用机制</p><p>三目运算符搭配逗号运算符</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>vptr的初始化发生在 base class constructor调用之后，程序员提供的代码之前</p><p>不要再vurtual base class中声明数据</p><p>vptr会随着构造函数从基类到子类的一层层调用被改变<br>同样 析构函数会逆操作 这个指针</p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>一般情况下 程序的构造函数我们都知道他在那里调用。 然而，析构函数呢？答案是析构函数会在函数结束的时候被调用（针对局部对象）。所以析构函数的调用代码会被穿插入每一个return 前（对象被构造后的return 被构造前的则没有必要） 尽管某些return不会被调用</p><p>new运算符只有一个步骤？ 不不不 会被扩充为 1. 先分配内存 2. 设定初值</p><p>delete运算符 则会进行检测 delete nullptr 则不会有任何效果</p><p>针对对象使用new则会在分配内存后通过调用构造函数设定初始值， 而delete则会在检测nullptr后调用析构函数然后将内存归还</p><p>NRV优化</p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><p>template， exception handling（EH）， runtime type identification（RTTI， EH的副作用？）</p><p>模板类的错误发现 会直到被实例化的时候才会被发现 延迟了错误的发现时机</p><p>目前的编译器，面对一个template声明，在它被一组实际参数实例化之前，只能施行有限的错误检查。template中那些与语法无关的错误，程序员可能认为十分明显，编译器却让他通过了，只有在特定实例被定义之后，运行时。才会产生错误。</p><p>dynamic_cast 运算符可以在执行期间决定真正的类型。 如果downcast是安全的这个运算符会传回适当转换过的指针。如果是不安全的则返回0<br>dynamic_cast同样可以对引用进行操作，成功后返回转换后的引用，失败后只能抛出异常（因为没有办法像指针那样指定nullptr表示错误）</p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EPOLLET丢失新连接事件</title>
      <link href="/2020/08/%E9%87%87%E5%9D%91%E8%AE%B0-EPOLLET%E4%B8%A2%E5%A4%B1%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6/"/>
      <url>/2020/08/%E9%87%87%E5%9D%91%E8%AE%B0-EPOLLET%E4%B8%A2%E5%A4%B1%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>谨以此文献给我, 两次踩坑.</p><p>第一次是根据muduo写我的mongo</p><p>第二次则是后来我又根据muduo写higan. <del>框架名字不是重点</del></p><h1 id="症状描述"><a href="#症状描述" class="headerlink" title="症状描述"></a>症状描述</h1><ol><li>最首先的症状就是使用ab压测的时候, 压测会在快结束的时候卡住 而且压测过程中也会出现卡顿<pre><code>PS C:\Users\XXX&gt; ab -n 1000 -c 94 -k  http://10.4.160.96:1022/helloThis is ApacheBench, Version 2.3 &lt;$Revision: 1874286 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/</code></pre></li></ol><p>Benchmarking 10.4.160.96 (be patient)<br>Completed 100 requests<br>Completed 200 requests<br>Completed 300 requests<br>Completed 400 requests<br>Completed 500 requests<br>Completed 600 requests<br>Completed 700 requests<br>Completed 800 requests<br>Completed 900 requests<br>apr_pollset_poll: The timeout specified has expired (70007)<br>Total of 996 requests completed</p><pre><code>2. 这时候已经建立的连接不受影响 却无法建立新的连接 debug的时候发现会出现建立已经关闭的连接3. 上面的问题发生与不发生 跟我是否开多线程有关, 如果我不建立额外的EventLoopThread就不会出现这个问题# 第一波排查 线程之间互相影响因为问题出现与否 与我是否设置多线程有关, 我就开始排查线程之间的影响.重点放在了muduo的RunInLoop函数. 因为这个函数我一直不是明白怎么回事.最终根据muduo的设计思想 一个EventLoop对应一个Thread.结合RunInLoop就可以达到谁的事件谁处理的效果举个例子, 连接中断后, 子线程返回相应的事件 要去调用TcpServer的RemoveConnection将自己移除, 如果不使用RunInLoop当有多个子线程 同时触发同样的事件 同时去对map进行删除操作 必然需要加锁. 况且连接连接的时候也要对map进行插入操作.使用RunInLoop判断后得知是子线程在调用RunInLoop而非对应的线程, 就将任务存储到了相关的EventLoop中. 而EventLoop中存储的任务只有其所属的Thread才能处理.所以实现了统一所有子线程的移除连接操作到了主线程中, 而连接的建立也是主线程操作, 最终避免了加锁.然后那个swap命令处理任务度列减少加锁的时间也很赞最终我加上了几处重要的RunInLoop, 不过并没有解决问题.............# 第二波排查 到底返回了多少事件?我在Acceptor等多个可读事件回调的位置加了计数器, 这时候最先发现的就是连接建立数量不对.上边996个完成请求缺了4个, 并且正好连接建立了90个连接, 而非设置的并发94, 也是少了4个.我先怀疑是否是ab压测的处理, 我试了下muduo多线程下94个连接 higan单线程94连接,多线程90连接, 排除了ab的问题少的链接去了哪里? 我使用netstat命令发现 正好是四个CLOSE_WAIT 我去看了下ab的包正好是114字节 说明了少的四个链接的位置而且这四个端口号正好是从本该是第91个连接的端口号开始的.</code></pre><p>[root@fish ~]# netstat -an | grep 1022<br>tcp        4      0 0.0.0.0:1022            0.0.0.0:*               LISTEN<br>tcp      114      0 10.4.160.96:1022        10.4.160.95:8785        CLOSE_WAIT<br>tcp      114      0 10.4.160.96:1022        10.4.160.95:8787        CLOSE_WAIT<br>tcp      114      0 10.4.160.96:1022        10.4.160.95:8786        CLOSE_WAIT<br>tcp      114      0 10.4.160.96:1022        10.4.160.95:8784        CLOSE_WAIT </p><pre><code>其实netstat不对劲早就发现了, 然而并不理解netstat命令 没有重视问题.使用Man命令察看了 第二列是Recv-Q 对于CLOSE_WAIT来说是未接收的字节数 对于LISTEN则是未接收的连接数# 第三波排查 为什么这四个连接没有被接受首先我发现了我这行代码写的有问题, 而我的epoll_events_是一个vector 后面的代码有扩容逻辑 难道是因为max_event太小导致的ET模式漏掉事件?并不是, 未被返回的事件是不会被忽略的 只有你从内核中将事件接收出来, 下次才不会提醒```c++// 源代码为 int event_num = epoll_wait(epollfd_, &amp;*epoll_events_.begin(), 一个常数, timeout);// 修改后为 int event_num = epoll_wait(epollfd_, &amp;*epoll_events_.begin(), static_cast&lt;int&gt;(epoll_events_.size()), timeout);</code></pre><p>只能继续排查了, 因为知道了Recv-Q的存在 直接搜索几个关键字 找到了这个网页</p><p><a href="https://www.cnblogs.com/cxt-janson/p/9273440.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxt-janson/p/9273440.html</a></p><p>最后我尝试将EPOLLET模式改为EPOLLLT正常了!!!!!!</p><h1 id="仍存在的问题"><a href="#仍存在的问题" class="headerlink" title="仍存在的问题"></a>仍存在的问题</h1><p>为什么只有我在启用多线程的时候才会发生丢失连接的现象? 这个问题目前还没找到.</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>我最先排查的重点是线程之间的影响, 我对于muduo的多线程处理机制还是不熟悉, 自以为是了某些地方. </p><p>连接建立的数量不对的时候虽然发现了Recv-Q以及CLOSE_WAIT 但由于对Tcp连接状态的理解以及netstat命令的不熟悉, 导致走了弯路.</p>]]></content>
      
      
      <categories>
          
          <category> 采坑记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 采坑记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法四</title>
      <link href="/2020/07/%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%9B%9B/"/>
      <url>/2020/07/%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<p>来之不易的暑期留校, 一半献给算法.</p><h1 id="第二章-排序"><a href="#第二章-排序" class="headerlink" title="第二章 排序"></a>第二章 排序</h1><p>选择排序</p><ul><li>运行时间和输入的数据无关, 仅和数量有关.<br>不会利用输入的初始状态</li><li>数据移动是最少的<br>我们将研究的其他任何算法 都不具备这个特性…..</li></ul><p>插入排序</p><ul><li>适合小规模数组</li><li>对于部分有序的数组, 处理起来很有效</li><li>倒置的数量很少时, 插入排序很可能比其他算法还要快</li></ul><p>希尔排序</p><ul><li>插入排序对于大规模乱序数组很慢, 因为它只会交换相邻元素, 因此为了改进插入排序的局部性,提出了希尔排序</li><li>希尔排序交换不相邻的元素以对数组的局部性进行排序, 最终用插入排序调整局部有序的数组</li></ul><p>归并排序</p><ul><li>原地归并排序</li><li>自顶向下 递归实现 分治思想</li><li>自底向上 从归并微型数组到整体归并</li></ul><p>快速排序</p><ul><li>分治排序算法</li></ul><p>堆排序</p><ul><li>只能说妙啊.. 这本书先讲的优先队列如何实现, 然后紧接着就用sink方法完成了堆排序</li></ul><p><strong>稳定性</strong></p><p>某地在某时下雨 时间和地点存在对应关系.<br>按照时间排序后, 再按照地点排序 单个地点的时间排序就很可能被打乱</p><p>稳定, 则时间排序没有被打乱. 不稳定, 很可能时间排序被打乱</p><table><thead><tr><th>算法</th><th>是否稳定</th><th>是否为原地排序</th><th>时间复杂度</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td>选择排序</td><td>否</td><td>是</td><td>N^2</td><td>1</td><td>最简单粗暴的方式, 交换次数最少</td></tr><tr><td>插入排序</td><td>是</td><td>是</td><td>介于N与N^2</td><td>1</td><td>很大程度取决输入元素的排列情况, 如果倒置元素很少则性能可能超过快排</td></tr><tr><td>希尔排序</td><td>否</td><td>是</td><td></td><td>1</td><td>插入排序的改良版, 改善了插入排序过于局限</td></tr><tr><td>快速排序</td><td>否</td><td>是</td><td>NlogN</td><td>lgN</td><td>分治, 运行效率由概率保证</td></tr><tr><td>归并排序</td><td>是</td><td>否</td><td>NlogN</td><td>N</td><td>自顶向下(递归 分治)和自底向上(从局部到整体) 两种方法</td></tr><tr><td>堆排序</td><td>否</td><td>是</td><td>NlogN</td><td>1</td><td>学完后突然想到了如果在很多的数字中找到最大的多少个数这种问题</td></tr></tbody></table><p><strong>2.4 优先队列</strong></p><p>需要支持两种操作, 删除最大元素和插入元素  - 优先级队列</p><ol><li>数组实现(无序) - 插入快 删除慢</li></ol><p>Insert方法 直接将元素插入尾部, 类似栈的push方法</p><p>DelMax方法 使用一个内部循环找出最大的元素和边界元素交换 然后删除边界元素, 删除的时候类似pop方法</p><ol start="2"><li>数组实现(有序) - 插入慢 删除快</li></ol><p>Insert方法 中进行排序, 插入新的元素的时候将较大元素向右移动一格位置, 然后插入新的元素</p><p>DelMax方法 直接删除右侧元素, 类似栈的pop方法</p><ol start="3"><li>链表表示法</li></ol><p>无序序列是解决问题的惰性方法, 仅在必要的时候才会采取行动 找出最大元素</p><p>有序序列是解决问题的积极方法, 尽可能的未雨绸缪, 使得找出最大元素高效</p><ol start="4"><li><code>二叉堆</code>表示法 - 插入和删除都为线性对数级别</li></ol><p>Insert方法 将新元素添加到数组末端, 增加了堆的大小 将新元素<code>上浮</code>到合适的位置</p><p>DelMax方法 删除顶部元素 将数组的最后一个元素放到顶部 将其<code>下沉</code>到合适的位置 减小了堆的大小 将</p><p><strong>堆</strong></p><p>二叉堆: 每个元素都要保证小于等于(大于等于)另外两个特定位置的元素. 其根节点是最小(最大)元素</p><ol><li>二叉堆的指针表示法</li></ol><p>需要使用三个指针, 指向父节点和两个子节点</p><ol start="2"><li>使用数组</li></ol><p>完全二叉树可以使用数组表示 不使用数组的0位置元素 从1开始 k的子节点分别在2k和2k+1</p><p><strong>堆的有序化</strong></p><p>以最大堆为例</p><ol><li>由下至上的堆有序化 <code>上浮</code></li></ol><p>堆的有序状态因为 某个节点比他的父节点更大 被打破.</p><p>需要与父节点交换, 不断向上直到遇到一个更大的父节点 或者到了顶部</p><ol start="2"><li>由上至下的堆有序化 <code>下浮</code></li></ol><p>堆的有序状态因为 某个父节点比 他的两个子节点或其中之一子节点 小 被打破.</p><p>将父节点与子节点中较大的一个进行交换直到它的子节点都比它小 获得到了底部</p><h1 id="第三章-查找"><a href="#第三章-查找" class="headerlink" title="第三章 查找"></a>第三章 查找</h1><p>符号表: 最主要的目的是是将<code>one key</code>和<code>one value</code>联系起来, 是一种存储键值对的数据结构, 支持插入和查找</p><table><thead><tr><th>使用的数据结构</th><th>实现</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>链表(顺序查找)</td><td>SequentialSearchST</td><td>适用于小型问题</td><td>对于大型表很慢</td></tr><tr><td>有序数组(二分)</td><td>BinarySearchST</td><td>最优的查找和空间需求, 能够进行有序性相关的操作</td><td>插入操作很慢</td></tr><tr><td>二叉查找树</td><td>BST</td><td>实现简单, 能够进行有序性相关的操作</td><td>没有性能上界的保证, 链接需要额外的空间</td></tr><tr><td>平衡二叉树</td><td>RedBlackBST</td><td>最优的查找和插入效率, 能够进行有序性相关的操作</td><td>链接需要额外的空间</td></tr><tr><td>散列表</td><td>SeparateChainHashST LinearProbingHashST</td><td>能够快速的查找和插入常见的数据类型</td><td>需要计算散列, 无法进行有序性相关操作, 链接和空节点需要额外的空间</td></tr></tbody></table><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>介绍红黑树之前书中先介绍了2-3树先说明2-3树的基本理想操作和优点. 然后说出其缺点(编码实现和维护较复杂), 引出了红黑树</p><p>红黑树中的红: 红色链接将两个2-结点连接起来构成一个3-结点, 且这条连接是左斜的两个节点之一是另一个节点的左子节点. 同时不存在一个节点同时有两条红色链接<br>红黑树中的黑: 普通的结点</p><p>将红黑树中的红色链接画平行, 这样所有的空节点到根节点的路径都是相同的</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/algorithm4/red-black-tree.png" alt=""></p><p>红黑树需要通过左旋转和右旋转以及颜色转换保证插入后不会存在右斜红色链接和同时有两个红色链接的连接</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VIM使用</title>
      <link href="/2020/07/Linux-VIM/"/>
      <url>/2020/07/Linux-VIM/</url>
      
        <content type="html"><![CDATA[<h1 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h1><h2 id="文件打开"><a href="#文件打开" class="headerlink" title="文件打开"></a>文件打开</h2><pre><code class="shell">vim x x x # 打开所有文件:open file # 进入vim后打开文件:e file # 关闭当前文件 打开新文件:ls # 查看缓存    :ls    1 %a   &quot;boot.sh&quot;                      line 3    2      &quot;login.sh&quot;                     line 0</code></pre><h2 id="多文件操作"><a href="#多文件操作" class="headerlink" title="多文件操作"></a>多文件操作</h2><pre><code class="shell">:split :sp  # 打开新的水平窗口:vsplit :vsp  # 打开新的垂直窗口ctrl + ww # 依次向后切换ctrl + w + 方向键 h/j/k/l # 向前下上后切换窗口:n # 编辑下一个文档:N # 编辑上一个文档</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><pre><code class="shell">:/http # 查找http 并高亮所有:noh # 取消高亮n # 查找下一个N # 查找上一个:%s/xxx/yyy/g # 将所有xxx替换为yyy# :[range]s/xxx/yyy/[c,e,g,i]# range 1,7 第一行到第七行 1,$ 第一行到结尾 % 全文# xxx 待替换字符# yyy 替换为的字符# c 每次替换前都询问 e 不显示错误 g 全部替换 i 不区分大小写</code></pre><h1 id="spf13"><a href="#spf13" class="headerlink" title="spf13"></a>spf13</h1><p><a href="https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html" target="_blank" rel="noopener">https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html</a> vim分屏</p><h2 id="乱码解决"><a href="#乱码解决" class="headerlink" title="乱码解决"></a>乱码解决</h2><p>中文乱码</p><p>修改locale.conf确实解决了 但我想要的是阿里云那种显示英文中文却不是乱码</p><p>最终<code>vim /etc/vconsole.conf</code>将cn改为us就解决了….</p><p>中间也尝试安装语言包, 记得是已经安装 最终是修改上面那个之后就好了</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><pre><code class="shell">R           进入替换模式e           光标后移一个单词 连续的符号也算一个单词 &lt;&lt;E           光标后移一个单词 无视符号b           光标前移一个单词 连续的符号也算一个单词 &lt;&lt;B           光标前移一个单词 无视符号yy或Y       复制整行          p           光标之后粘贴P大写           光标之前粘贴## 2020年7月30日10:14:18ctrl+r      重做撤销内容u           撤销^           本行第一个非空格字符$           本行最后一个非空格字符G           文件尾gg          文件头## 2020年10月27日08:51:36V选中行后SHIFT + . 缩进SHIFT + , 取消缩进:1,10&gt; 1~10行缩进:1,10&lt; 1~10行取消缩进</code></pre><h2 id="注释-NERDCommenter"><a href="#注释-NERDCommenter" class="headerlink" title="注释 NERDCommenter"></a>注释 NERDCommenter</h2><pre><code>,c&lt;space&gt;   当前行注释和切换注释,cs         块注释当前选中或当前行v           小写v进入多字符选择模式V           大写V进入多行选择</code></pre><h2 id="文件导航工具-NERDTree"><a href="#文件导航工具-NERDTree" class="headerlink" title="文件导航工具 NERDTree"></a>文件导航工具 NERDTree</h2><pre><code class="shell">ctrl + e    打开文件导航o           打开文件, 目录, 标签go          打开文件, 目录, 标签, 但光标仍位于导航栏R           刷新根目录下所有文件r           刷新当前目录下文件## 2020年7月30日16:22:01--------------------------------------t           在新tab中打开选中节点书签T           同上 但焦点仍在当前tabgt, gT      在tab之间切换:tabc       关闭当前tab:tabo       关闭其他tab:tabs       查看所有打开的tab-----------------------------------------i           在新的split中打开选择文件 两个部分水平切割gi          同上 焦点仍位于导航栏s           在新的split中打开选择文件 垂直切割gs          同上 焦点仍位于导航栏ctrl+w w    顺序切换, 两个窗口的时候非常方便ctrl+w hjkl 对应左 下 上 有ctrl+w c    关闭当前splitctrl+w o    关闭其他split-----------------------------------------tab         补全菜单向下移动space       补全为当前单词 附带一个空格</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spf-13 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp笔记</title>
      <link href="/2020/06/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-csapp/"/>
      <url>/2020/06/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-csapp/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h1><p><img src="http://lsmg-img.oss-cn-beijing.aliyuncs.com/csapp/1-3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png" alt=""></p><p>预处理-&gt;编译-&gt;汇编-&gt;链接</p><pre><code class="c++">// hello.cpp#include &lt;cstdio&gt;#define PI 3.14int main(){    // 1111    //    printf(&quot;%f\n&quot;, PI);    printf(&quot;hello, world!\n&quot;);    return 0;}</code></pre><p>预处理<br>宏替换和注释消失 但是空行还在<br><code>g++ -E hello.cpp -o hello.i</code><br><code>tail -9 hello.i</code></p><pre><code class="c++"># 5 &quot;hello.cpp&quot;int main(){    printf(&quot;%f\n&quot;, 3.14);    printf(&quot;hello, world!\n&quot;);    return 0;}</code></pre><p>编译 生成汇编<br><code>g++ -S hello.i</code></p><pre><code class="s">        .file   &quot;hello.cpp&quot;        .text        .section        .rodata.LC1:        .string &quot;%f\n&quot;.LC2:        .string &quot;hello, world!&quot;        .text        .globl  main        .type   main, @functionmain:.LFB0:        .cfi_startproc        pushq   %rbp        .cfi_def_cfa_offset 16        .cfi_offset 6, -16        movq    %rsp, %rbp        .cfi_def_cfa_register 6        subq    $16, %rsp        movq    .LC0(%rip), %rax        movq    %rax, -8(%rbp)        movsd   -8(%rbp), %xmm0        leaq    .LC1(%rip), %rdi        movl    $1, %eax        call    printf@PLT        leaq    .LC2(%rip), %rdi        call    puts@PLT        movl    $0, %eax        leave        .cfi_def_cfa 7, 8        ret        .cfi_endproc.LFE0:        .size   main, .-main        .section        .rodata        .align 8.LC0:        .long   1374389535        .long   1074339512        .ident  &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;        .section        .note.GNU-stack,&quot;&quot;,@progbits</code></pre><p>汇编 生成 可重定位二进制目标程序<br>gcc编译器 -c参数 起到的作用是编译和汇编 -S参数 仅仅是编译</p><p><code>g++ -c hello.s</code></p><p>链接 生成执行文件</p><p><code>g++ hello.o -o hello</code></p><p>在不同进程间切换 交错执行的执行-上下文切换<br>操作系统保持进程运行所需的所有状态信息 这种状态-上下文</p><p>线程共享代码和全局数据</p><h1 id="第一部分-程序结构和执行"><a href="#第一部分-程序结构和执行" class="headerlink" title="第一部分 程序结构和执行"></a>第一部分 程序结构和执行</h1><h2 id="第二章-信息存储"><a href="#第二章-信息存储" class="headerlink" title="第二章 信息存储"></a>第二章 信息存储</h2><p>孤立地讲,单个位不是非常有用. 然而, 当把位组合在一起, 再加上某种解释,即赋予不同可能位组合不同的含义, 我们就能表示任何有限集合的元素.</p><h2 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h2><p>编写高效的程序</p><ul><li>选择一组适当的算法和数据结构</li><li>编写出编译器能够有效优化以转变为高效的可执行程序的源代码</li><li>大项目的并行计算</li></ul><p>整数运算使用乘法的结合律和交换律, 当溢出的时候, 结果依然是一致的.<br>但是浮点数使用结合律和交换律的时候, 在溢出时, 结果却不是一致的.</p><p>整数的表示虽然只能编码一个相对较小的数值范围, 但是这种标识是精确地<br>浮点数能编码一个较大的数值范围, 但是这种表示只是近似的.</p><h1 id="第二部分-在系统上运行程序"><a href="#第二部分-在系统上运行程序" class="headerlink" title="第二部分 在系统上运行程序"></a>第二部分 在系统上运行程序</h1><h1 id="第三部分-程序间的交流和通信"><a href="#第三部分-程序间的交流和通信" class="headerlink" title="第三部分 程序间的交流和通信"></a>第三部分 程序间的交流和通信</h1><h2 id="第十章-系统级I-O"><a href="#第十章-系统级I-O" class="headerlink" title="第十章 系统级I/O"></a>第十章 系统级I/O</h2><p>现在有一个读操作，当前文件的位置是K，然后读取了n个字节。如果k+n &gt;= 文件大小m 则会触发end-of-file（EOF）的条件，应用程序会检测到这个条件。在文件的结束尾部没有明确的EOF符号</p><p>目录是包含一组链接（link）的文件，每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。</p><p>每个目录至少含有两个条目，<code>.</code>是到该目录自身的链接，<code>..</code>是到目录层次结构中父目录的链接。</p><p>可以通过open函数打开一个已经存在的文件，<code>或者创建一个新的文件</code></p><h2 id="第十一章-网络编程"><a href="#第十一章-网络编程" class="headerlink" title="第十一章 网络编程"></a>第十一章 网络编程</h2><p>从网络上接收到的数据经过网络适配器 IO总线 内存总线复制到内存, 通常使用的DMA传送. 反过来就是内存到网络的方式</p><p>我们的实例抓住了互联网络思想的精髓, 封装是关键</p><p>应改为IP地址, 确切地说是Ipv4地址定义一个特殊的类型, 不过标准成立后已经太迟了. 不过看着ipv6的地址表示, 获取标准成功了? 提供了一个看起来特殊的类型</p><pre><code class="c++">typedef uint32_t in_addr_t;struct in_addr{in_addr_t s_addr;};struct in6_addr{union{uint8_t    __u6_addr8[16];uint16_t __u6_addr16[8];uint32_t __u6_addr32[4];} __in6_u;};</code></pre><p>socket函数返回的套接字被操作系统默认为是主动实体(客户端), 通过listen告知操作系统这是被动实体(服务器)</p><p><strong>getaddrinfo函数</strong></p><pre><code class="c++">#include &lt;netdb.h&gt;struct addrinfo{    int              ai_flags; // hints     int              ai_family; // hints AF_INET 限制返回ipv4 AF_INET6限制返回ipv6 不指定则二者都有    int              ai_socktype; // hints    int              ai_protocol; // hints    socklen_t        ai_addrlen;    struct sockaddr *ai_addr;    char            *ai_canonname; // 只有设置了AI_CANONNAME 这里将保存host的官方名字    struct addrinfo *ai_next; // 链表};// node: 可以是域名 点分十进制ip nullptr //      AI_PASSIVE 告知返回的套接字地址可能用于listen套接字 此时应该设置为nullptr// service: 端口号, 服务名http  //      AI_NUMERICSERV 强制此参数为端口号// addrinfo 设置后可以控制返回的result// AI_ADDRINFO 只有当本机设置了ipv4才查询ipv4地址 ipv6亦然int getaddrinfo(const char *node, const char *service,                       const struct addrinfo *hints,                       struct addrinfo **result);void freeaddrinfo(struct addrinfo *res);const char *gai_strerror(int errcode);</code></pre><p>调用<code>getaddrinfo</code>生成result链表后, 遍历链表直到socket和bind调用成功(socket和connect调用成功)</p><p><strong>getnameinfo函数</strong></p><pre><code class="c++">// host 存储主机名 IP地址// serv 存储端口号 服务名// NI_NUMERICHOST 直接返回IP地址 不解析,  NI_NUMERICSERV 字节返回端口号 不解析服务名int getnameinfo(const struct sockaddr *addr, socklen_t addrlen,                       char *host, socklen_t hostlen,                       char *serv, socklen_t servlen, int flags);</code></pre><p>EOF并不存在对应的字符, 其是由内核检测到的一种条件</p><h2 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h2><p>现代操作系统提供了三种基本的构造并发程序的方法</p><ol><li>进程</li><li>线程</li><li>I/O多路复用</li></ol><p>每个线程有自己的线程上下文, 线程id 栈 栈指针 程序计数器(存放下一条指令) 通用目的寄存器和条件码(CPU根据运算结果由硬件设置, 标识正负或者溢出等)</p><p>在任何一个时间点上线程是可结合的(joinable)或者是可分离的(detached). 必须二选一来收回线程资源<br>前者可以能够被其他线程收回和杀死, 后者则不可被其他线程回收或杀死, 它占用的资源在其终止时由系统自动释放</p><p>pthread_detach 分离线程, 可以通过pthread_self来分离自己</p><p>pthread_join 结合线程 只能等待一个指定的线程终止, 没有办法让其等待任意一个线程终止</p><p>为了理解程序中一个变量是否是共享的有一些基本问题要解答</p><ol><li>线程的基础内存模型是什么</li><li>根据这个模型, <code>变量实例</code>如何映射到内存的</li><li>有多少线程引用这些<code>实例</code></li></ol><h3 id="线程内存模型"><a href="#线程内存模型" class="headerlink" title="线程内存模型"></a>线程内存模型</h3><p>每个线程有自己独立的线程上下文包括线程id, 栈, 栈指针, 程序计数器, 通用目的寄存器和条件码 信号屏蔽字 线程优先级</p><p>线程之间共享剩余部分, 包括整个用户虚拟地址空间(由只读文本(代码), 读/写数据(全局变量, 本地静态变量), 堆, 共享库代码和数据区域)</p><p>共享相同的打开文件集合</p><p>线程之间栈相互独立, 基本自己访问自己的栈. 然而如果一个线程得到了另一个线程的栈指针 就可以读写这个栈的任何部分</p><p><strong>进度图</strong></p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码大全</title>
      <link href="/2020/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
      <url>/2020/05/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>距离上次什么时候写博客已经记不清了, 看了眼GitHub备份记录 已经25天了. 这25天我咕了吗? 咕是不可能咕的. 这段时间我终于做出了第一个UE4比较完善的联机游戏.<br>学习了更多的muduo自己的mongo也更加完善. 只看书写博客不写代码可不行.</p><p>技术类书籍慢慢开始看了, mongo写的时间不短了.  代码大全听说是神书? 来粗读看看吧</p><h1 id="第-部分"><a href="#第-部分" class="headerlink" title="第?部分"></a>第?部分</h1><h2 id="第六章-可以工作的类"><a href="#第六章-可以工作的类" class="headerlink" title="第六章 可以工作的类"></a>第六章 可以工作的类</h2><p>使用ADT 可以实现隐藏细节, 改动不会影响到整个程序.</p><p>这点感受还是有些的. 前两天自己写VPN(目前项目暂停了)的时候, 有个Buffer类, Buffer类的核心是libevent的evbuff, 我直接使用Get方法Get到这个evbuff的指针, 然后在外部进行操作.<br>起初这样只是图简单吧, 也想到了这样会写出烂代码. 后面改动核心evbuff的时候, 发现太麻烦了, 最终改成了几个简单的接口 Append Clear等, 对外隐藏了内部是什么缓冲结构</p><p>has a  —- 组合 包含<br>is a —- 集成 epoll(select) is a mutiplexing</p><p>只有一个实例的类是值得怀疑的, 同样只有一个派生类的基类也是值得怀疑的</p><p>拷贝对象优先使用深拷贝</p><p>创建类的原因</p><ul><li>为现实世界中的对象建模</li><li>为抽象的对象建模 形状类是抽象的 不过圆 正方形等都是真实存在的</li><li>降低复杂度 一个类创建结束后, 你就可以忘掉其中的细节 使用接口即可</li><li>隔离复杂度</li><li>隐藏实现细节 限制变动的影响范围 隐藏全局数据</li><li>让参数传递更加舒畅 成员变量 </li><li>复用代码</li></ul><h2 id="第七章-高质量的子程序"><a href="#第七章-高质量的子程序" class="headerlink" title="第七章 高质量的子程序"></a>第七章 高质量的子程序</h2><p>创建子程序的正当理由</p><ul><li>降低复杂度<br>一个子程序编写完毕后, 应该可以忘记其中的细节</li><li>引入中间,易懂的抽象<br>避免代码重复  从大块的代码中抽取子程序</li><li>隐藏顺序 如果某两行代码有特定的执行顺序, 可以考虑抽取出来. 感觉这里可以推广到Mutex lock后忘记unlock 或者 Buffer中读取数据后 忘记移动指针?</li><li>提高可移植性 这点看项目了</li></ul><p>似乎过于简单没有必要写成子程序, 当然也要看情况了</p><ul><li>这里我感觉最深的还是 两行或者三行经常调用的程序, 如果重复写多次 最终告知你需要修改的时候 那可真是灾难性的消息. 实例的话: 增加参数校验等等</li></ul><p>准确的使用对仗词</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>add</td><td>remove</td></tr><tr><td>begin</td><td>end</td></tr><tr><td>create</td><td>destory</td></tr><tr><td>next</td><td>previous</td></tr><tr><td>start</td><td>stop</td></tr></tbody></table><p>如何使用子程序参数</p><ul><li>按照输入-修改-输出的顺序排列参数</li><li>如果几个子程序都是用了类似的一些参数, 应该让这些参数的排列顺序一致</li><li>使用所有的参数, 删去未使用到的参数</li><li>不要把子程序的参数用做工作变量</li></ul><p>设置函数的返回值</p><ul><li>检查所有可能的返回路径, 在函数开头设置默认返回 一个不错的选择(muduo中见到了)</li><li>老生常谈的不要返回局部对象的引用或者指针</li></ul><p>少使用宏吧 inline和typedef 不香吗, 不是肉包子也是好吃的素包子了</p><h2 id="第八章-防御式编程"><a href="#第八章-防御式编程" class="headerlink" title="第八章 防御式编程"></a>第八章 防御式编程</h2><p><del>防御式编程并不是说让你在编程时保持 “防备批评或攻击” 的态度</del></p><p>子程序不应该因为传入错误数据而被破坏</p><ul><li>检查所有源自外部数据的值</li><li>检查子程序所有输入参数的值</li><li>决定如何处理错误的输入数据</li></ul><p>使用错误处理代码来处理与其发生的状况, 使用断言来处理绝不应该发生的状况</p><p>错误处理技术 其他感觉… 用不到吧 现在不记录了</p><ul><li>返回中立值 最简单的方法, 继续执行操作并简单的返回一个没有危害的数值. 数值计算-返回0 字符串返回空串 指针返回空指针</li><li>日志打印</li><li>关闭程序</li></ul><p>隔离程序<br>两块相对独立的代码块 在交互函数见进行参数校验 过滤掉一个模块传来的非法参数</p><p>辅助调试的代码…..<br>我现在就遇到一个bug 还不知道怎么修改 与多线程有关的问题 排查真难-2020年5月18日13:11:43<br>2020年6月18日23:50:44 排查掉了 今天看到了这段话 补充上吧</p><p>决定产品最终发布的时候应该保留多少防御内容<br>防御内容越多消耗的性能越多</p><h2 id="第九章-伪代码的编程过程"><a href="#第九章-伪代码的编程过程" class="headerlink" title="第九章 伪代码的编程过程"></a>第九章 伪代码的编程过程</h2><p>原则</p><ul><li>用类似英语的句子来准确描述特定的操作</li><li>便面使用目标编程语言中的特定语法元素</li><li>在本意的层面上编写伪代码. 用伪代码描述解决问题的方法意图, 而不是去写如何用目标语言实现这个方法</li><li>在一个足够低的层次上编写伪代码, 以便近乎自动的生成代码, 如果层次过高则会隐藏细节问题</li></ul><ol><li>定义子程序要解决的问题</li></ol><ul><li>子程序将要隐藏的信息</li><li>传给子程序的各项输入, 得到的输出</li><li>调用子程序前确保相关前条件成立. 输入数据的范围正确 流已经初始化 文件已经打开或关闭</li><li>在子程序将控制权交回调用方程序之前, 确保其后条件成立. 多线程问题居多</li></ul><ol start="2"><li>为子程序命名</li><li>决定如何测试子程序</li><li>在标准库中搜寻可用的功能</li><li>考虑错误处理和效率问题</li></ol><h1 id="第三部分-变量variables"><a href="#第三部分-变量variables" class="headerlink" title="第三部分 变量variables"></a>第三部分 变量variables</h1><h2 id="第十章-使用变量的一般事项"><a href="#第十章-使用变量的一般事项" class="headerlink" title="第十章 使用变量的一般事项"></a>第十章 使用变量的一般事项</h2><p>这本书还教你做人…  分数不可能很高 因为有的概念是杜撰的!!<br>(请读第33章 个人性格 诚实一节)</p><p>位图<br>B-树<br>堆<br>栈<br>文字量<br>查找表<br>引用完整性<br>树<br>共用体<br>变体</p><ul><li>在声明的时候就进行初始化</li><li>在理想的情况下, 在靠近第一次使用变量的位置声明和定义变量</li><li>多多使用const 吧</li><li>注意计数器和累加器. 这里很久前遇到一个坑 无符号自减可能会下溢</li><li>构造函数中进行初始化</li><li>检查是否需要重新初始化</li><li>检查输入的合法性</li><li>初始化指针建议初始化为 0, 一旦你看到为0的指针越界就知道是没有赋值</li></ul><h2 id="第十一章-变量名的力量"><a href="#第十一章-变量名的力量" class="headerlink" title="第十一章 变量名的力量"></a>第十一章 变量名的力量</h2><ol><li>为循环下标 临时变量命名</li><li>bool变量<br>done-&gt;事情已经完成<br>error-&gt;有错误发生<br>found-&gt;找到<br>success/ok -&gt;某操作已经成功 不是很具体<br>Is前缀可以用在模糊不清的词前, 不过这样也会导致最终表达模糊不清</li><li>标识全局变量 使用 <code>g_</code> 前缀</li><li>标识类型声明 <code>T</code> 前缀</li><li>避免在名字中使用1 2 后缀file_1 file_2</li></ol><h2 id="第十二章-基本数据类型"><a href="#第十二章-基本数据类型" class="headerlink" title="第十二章 基本数据类型"></a>第十二章 基本数据类型</h2><ol><li>避免使用神秘数值 突然出现某个数值 这样一方面不便于修改所有值 一方面防止忘记数值含义</li><li>除零 的发生</li><li>防止溢出 这里最常见的就是循环体中了 更尤其是unsigned变量自减的时候</li><li>防范数组越界</li><li>C风格字符串的长度声明为 <code>CONSTANT+1</code>, CONSTANT是长度. 防止到时候你分不清长度是该+1还是-1还是就是本身</li></ol><p><code>if(chosen_color = 1)</code>和<code>if(chose_color = Color_Red)</code>后者枚举的使用更清楚.<br>枚举示例</p><pre><code class="c++">enum Color{  COLOR_RED,  COLOR_BLUE}</code></pre><p>单点控制(single-pointcontrol)让程序真正软了起来, 将一个量保存在变量中. 程序中使用变量名替换这个量</p><h2 id="第十三章-不常见的数据类型"><a href="#第十三章-不常见的数据类型" class="headerlink" title="第十三章 不常见的数据类型"></a>第十三章 不常见的数据类型</h2><p>p318</p><p>引用必须总是引用一个对象, 而指针则可以指向空值.<br>引用所指向的对象在改引用初始化后不能改变</p><p>全局变量应该加以说明</p><p>全局数据隐藏到类中, 使用static</p><p>不应该吧所有数据放在一个大对象中到处传递</p><p>不要实用全局变量存放中间结果</p><h1 id="第四部分语句"><a href="#第四部分语句" class="headerlink" title="第四部分语句"></a>第四部分语句</h1><h2 id="第十四章-组织直线型代码"><a href="#第十四章-组织直线型代码" class="headerlink" title="第十四章 组织直线型代码"></a>第十四章 组织直线型代码</h2><ul><li>设法组织代码, 使依赖关系变得非常明显<pre><code class="c++">data = ReadData();result = CalculateResultsFromData(data);PrintResult(result);</code></pre>这段代码看起来很舒服, 逻辑清理, 命名到位. 明显的表明了函数间的依赖关系</li></ul><pre><code class="c++">revenue.ComputeMonthly();revenue.ComputeQuarterly();revenue.ComputeAnnual();</code></pre><p>这段代码, 前后依赖关系没有表现出来. 实际上计算季度收入需要先计算月收入 计算年收入需要季度收入</p><ul><li>使子程序名能凸显依赖关系</li><li>使用子程序参数明确显示依赖关系</li></ul><p>几个函数连续使用相同的参数, 说明之间极可能存在依赖关系.<br>几个函数使用不同的参数, 说明之间极可能不存在依赖关系</p><ul><li>对逻辑不清晰的代码 进行注释说明</li><li>使用断言或者错误来处理错误的调用顺序</li></ul><h2 id="第十五章-使用条件语句"><a href="#第十五章-使用条件语句" class="headerlink" title="第十五章 使用条件语句"></a>第十五章 使用条件语句</h2><p>if 语句</p><ul><li>首先写正常的代码路径, 再处理不常见的情况. 使得正确情况的执行路径在代码中是清晰的.</li><li>确保对于等量的分支是正确的(最好不要用&gt;替换&gt;= &lt;替换&lt;=) 防止off-by-one偏差一的错误. 这点emm</li><li>把正常情况的处理放在if后面 不要放在else后面 (看了眼示例代码, 对于嵌套if非常重要)</li><li><del>通用汽车公司做的分析发现 有五到八成的if语句都需要配有else语句</del></li><li>确保考虑到所有的情况, 一串if elseif之后应该加上一个else检查其他情况, 防止有未考虑到的情况</li></ul><p>case语句</p><ul><li>default语句只用来检查真正的默认情况, 而不是用来处理你认为的最后一种情况. 否则<br>你将失去case语句的标号(label)所提供的自动说明功能, 也丧失了default子句检错的能力</li><li>利用default语句来检错</li><li>case语句后没有break应该注释说明</li></ul><h2 id="第十六章-控制循环"><a href="#第十六章-控制循环" class="headerlink" title="第十六章 控制循环"></a>第十六章 控制循环</h2><ul><li>不要滥用循环下标<br>最好不要在循环体外 使用 依赖于循环下标最终取值的代码 可能会因为循环异常退出或者循环结束, 得到的下标并不是你想要的下标. 应该使用合适的变量用来标记在循环中是否遇到了你想要的情况</li><li>考虑在while循环中使用break而不是布尔标记</li><li>不要使用浮点数作为边界</li><li>使用有意义的下标变量名, 防止下标串话.</li><li>不要在循环中修改下标值</li></ul><p>下面的代码就是下标串话, 本来第二个循环应该使用j. 这种bug可能不是很容易排查出来, i和j乍一看很像.</p><pre><code class="c++">int  i, j;for (i = 0; i &lt; xxx; ++i){  xxxx  for (i = 0; j &lt;xxx; ++j)  {  }}</code></pre><p>低效的程序员会随意做一些试验, 直到他们找到了一种看上去能工作的组合. 如果某个循环没有按照想象工作,低效的程序员可能会把<code>&lt;</code>改为<code>&lt;=</code>. 如果还不行可能把下标<code>+1</code>或者<code>-1</code>. 这样最终可能碰出正确组合, 也有可能把原来的错误改成了另一个更微妙的错误. 即使这样随意的开发过程能够产生正确的程序, 这些程序员也不明白为什么这个程序是正确的.</p><h2 id="第十七章-不常见的控制结构"><a href="#第十七章-不常见的控制结构" class="headerlink" title="第十七章 不常见的控制结构"></a>第十七章 不常见的控制结构</h2><p>递归前两天正好用过, 如果用的恰当的话 感觉很不错</p><p>我也不想去用…… =, =</p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EPOLL本质</title>
      <link href="/2020/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-EPOLL%E6%9C%AC%E8%B4%A8/"/>
      <url>/2020/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-EPOLL%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>EPOLL本质是什么?  <del>本质当然是复读机</del></p><p>参考和图片来源<br><a href="https://zhuanlan.zhihu.com/p/64138532" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧！</a></p><p>一个socket对应一个端口号, 网络数据包中包含了端口, 内核可以通过端口号找到对应的socket</p><p><strong>select的不足</strong><br>select需要遍历两次socket列表, 第一次遍历用于将进程加入到所有socket的等待队列<br>第二次遍历是每次唤醒都需要将进程从每个socket等待队列移除<br>由于遍历开销大, 所以才规定了select最大的监视数量</p><p><strong>功能分离</strong><br><img src="https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_720w.jpg" alt=""><br>select将 <code>维护等待队列</code> 和 <code>阻塞进程</code>两个步骤合二为一, 每次select都需要这两部操作, 然而socket并不需要每次都修改<br>epoll将操作分开, 使用epoll_ctl维护等待队列, 使用epoll_wait阻塞进程</p><p><strong>就绪队列</strong><br>select不知道哪些socket接收到了数据, 只能一个个遍历.<br>如果内核维护一个”就绪队列” 引用存储事件就绪的socket, 进程唤醒后获取”就绪队列”就能够知道<br>哪些socket接收到数据</p><p><strong>epoll_create创建了什么?</strong><br>创建了一次eventpoll对象, epollfd正是他所代表的对象. 由于epollfd也是文件系统一员也存在等待队列</p><p>select将进程加入到每个socket的等待队列, 而epoll将进程加入到了eventpoll的等待队列 只加入了一次.</p><p><strong>epoll_ctl修改了什么</strong><br>epoll_ctl将 eventpoll添加到sockfd的等待队列中</p><p>当socket接收到数据后, 中断程序会操作eventpoll对象, 而不是直接操作进程(socket的等待队列中就是eventpoll)</p><p><strong>接收数据</strong><br>socket接收到数据后, 中断程序会给epollpoll的<code>就绪列表</code>添加socket的引用.</p><p>这样socket就不会直接影响进程, 而是通过改变eventpoll的<code>就绪列表</code>来改变进程状态</p><p><strong>epoll_wait</strong><br>当程序执行到epoll_wait后如果<code>就绪队列</code>已经有socket引用就会返回, 如果为空就阻塞进程</p><p><strong>阻塞和唤醒进程</strong><br>进程被添加到了eventpoll的等待队列中, socket接收到数据后, 中断程序一方面修改<code>就绪队列</code>一方面唤醒<br>eventpoll等待队列的进程, 由于<code>就绪队列</code> 进程便知道哪些socket发生变化</p><p><strong>实现细节</strong><br>eventpoll的数据结构是双向链表, 能够快速的插入和删除的数据结构</p><p>就绪队列的数据结构是红黑树, 方便添加删除检索避免重复添加.</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP状态机</title>
      <link href="/2020/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
      <url>/2020/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-TCP%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<ul><li>待补充 双向管道的建立和断开细节</li><li>异常三次握手</li><li>异常四次挥手</li></ul><p><a href="https://blog.csdn.net/q1007729991/article/details/69675752" target="_blank" rel="noopener">资料参考TCP 协议状态机</a></p><p><a href="https://blog.csdn.net/randyjiawenjie/article/details/6397477" target="_blank" rel="noopener">TCP有限状态机分析</a></p><p>Tcp状态图, 虚线代表客户端 实线代表服务器<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP/Socket%E7%90%86%E8%AE%BA/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt=""></p><p>正常的连接建立还是比较容易理解的</p><p>说一下从<code>CLOSE_WAIT</code>到<code>LAST_ACK</code><br>当被动关闭方<code>B</code>接收到<code>FIN</code>后知道对方<code>A</code>要关闭连接, <code>B</code>回复一个<code>ACK</code>给<code>A</code></p><ol><li>如果此时<code>B</code>没有额外要发送的数据就给<code>A</code>, 就发送<code>FIN</code>告知<code>A</code>自己也要关闭了, 然后<code>B</code>进入<code>LAST_ACK</code></li><li>如果此时<code>B</code>有额外信息要发送等发送完毕后. 这时<code>B</code>发送一个<code>FIN</code>告知<code>A</code>然后B进入<code>LAST_ACK</code></li></ol><p>再说一下从<code>FIN_WAIT_1</code>到<code>TIME_WAIT</code></p><ol><li>直接从<code>FIN_WAIT_1</code>到<code>TIME_WAIT</code>, 这个对应上面的第一种情况, 由于<code>B</code>没有额外信息发送直接发送了<code>FIN和ACK</code>, 这时<code>A</code>再发送一个<code>ACK</code>, 进入<code>TIME_WAIT</code></li><li>经过中转状态<code>FIN_WAIT2</code>对应上面第二种情况, 由于<code>B</code>有额外信息发送, 只发送了<code>ACK</code>, 这时<code>A</code>还可以接受数据, 直到<code>B</code>发来<code>FIN</code>然后<code>A</code>发送<code>ACK</code>进入<code>TIME_WAIT</code></li></ol><p>再说一下<code>TIME_WAIT</code>状态<br>主动关闭方<code>A</code>最后发送了<code>ACK</code>确认被动关闭方<code>B</code>的<code>FIN</code>.<br>但是如果这个<code>ACK</code>由于各种原因<code>B</code>没有收到, 所以<code>B</code>会再次发送<code>FIN</code>. 然后<code>A</code>会在<code>2MSL</code>时间内接受到这个<code>FYN</code>, 之后<code>A</code>再次回复一个<code>ACk</code>.计时器重置<code>2MSL</code>时间, 重复上面过程. 直到<code>2MSL</code>时间内<code>A</code>没有收到<code>FIN</code>,说明<code>B</code>已经收到了.则结束连接</p><p><code>2MSL</code>指的是两个<code>MSL</code>时间 单个指的是一个片段在网络中的最大存活时间,<br>A发送的<code>ACK</code>可能消耗一个, B重新发送的<code>FIN</code>可能也要消耗一个.最大两个</p><p>复位报文段</p><ul><li>客户端访问不存在的端口， 服务器会发送带RST标志的复位报文段</li><li>异常终止连接， 发送复位报文段</li><li>客户端或服务端向半打开状态(对方异常终止连接, 但是本方没有收到结束报文)的连接写入数据, 对方回复会一个复位报文段</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Send返回值引出的(非)阻塞IO</title>
      <link href="/2020/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Send%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E6%9E%90/"/>
      <url>/2020/03/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Send%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="现存疑问"><a href="#现存疑问" class="headerlink" title="现存疑问"></a>现存疑问</h1><ol><li>WNOWAIT和O_NONBLOCK 的关系?</li><li>当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?</li><li>对端接收缓冲区满了会发生什么?</li><li>暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?</li><li>send函数发送的字节数 超出了recv端的接受能力 会发生什么?</li></ol><p>最近这两天在实战一个http服务器的编写.</p><p>遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载</p><p>然后找了下为什么? 什么时候? send返回值会小于len;</p><h1 id="send"><a href="#send" class="headerlink" title="send"></a>send</h1><p><a href="https://stackoverflow.com/questions/14700906/socket-programming-send-return-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/14700906/socket-programming-send-return-value</a></p><pre><code>In practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送In non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if &gt; 0. If the socket send buffer is full, it returns -1 with errno = EWOULDBLOCK/EAGAIN.在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK/EAGAIN</code></pre><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect" target="_blank" rel="noopener">非阻塞模式下 send 和 recv 函数的返回值</a></p><p>这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改</p><pre><code class="c++">//推荐的方式二：在一个循环里面根据偏移量发送数据bool SendData(const char* buf , int buf_length){    //已发送的字节数目    int sent_bytes = 0;    int ret = 0;    while (true)    {        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, 0);        if (ret == -1)        {            if (errno == EAGIN)            {                //严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍                break;            }                         else if (errno == EINTR)            {                continue;            }            else            {                return false;            }        }        else if (ret == 0)        {            //认为对端关闭了连接            return false;        }        sent_bytes += ret;        if (sent_bytes == buf_length)        {            break;        }        //稍稍降低 CPU 的使用率        usleep(1);    }    return true;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux的使用</title>
      <link href="/2020/03/Linux-Linux%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/Linux-Linux%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cp -r</td><td>复制目录</td></tr><tr><td>cd -</td><td>切换到上一个工作目录</td></tr></tbody></table><table><thead><tr><th>查找</th><th>功能</th></tr></thead><tbody><tr><td>find ./ -name “core*”</td><td>xargs file</td></tr><tr><td>find ./ -name ‘*.o’</td><td>查找目标文件夹是否有obj文件</td></tr><tr><td>find ./ -name “*.o” | xargs rm -f</td><td>递归删除当前目录所有obj文件</td></tr></tbody></table><table><thead><tr><th>查看文件内容</th><th>功能</th><th>一般用法</th></tr></thead><tbody><tr><td>cat -n</td><td>显示的同时显示行号</td><td>使用管道 ls | cat -n</td></tr><tr><td>head -10 filename</td><td>查看前十行</td><td></td></tr><tr><td>tail -10 failname</td><td>查看后十行</td><td></td></tr><tr><td>diff file1 file2</td><td>查看文件差别</td><td></td></tr><tr><td>tail -f filename</td><td>动态显示文本的最新信息</td><td></td></tr></tbody></table><p>| 给文件增加别名 | 功能 |<br>| ln a b | 创建硬链接, 删除一个另一个仍能使用 |<br>| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |</p><p>命令行快捷键<br>Ctl-U   删除光标到行首的所有字符 <code>$ 1111 222  --&gt; $</code><br>Ctl-W   删除光标到前边最近一个空格之间的字符 <code>$ 1111 222 --&gt; $ 1111</code></p><h1 id="服务器双网卡配置"><a href="#服务器双网卡配置" class="headerlink" title="服务器双网卡配置"></a>服务器双网卡配置</h1><p>内网访问外网</p><p>外网接在了校园网上, 不过我的路由器不支持Ipv6, 有没有多余的lan口 只能接在服务器的lan口上</p><p>需要设置内网网卡开机启动 固定的Ip地址10.5.1.2 以及子网掩码255.255.255.0<br>然后路由器设置固定Ip地址10.5.1.3 子网掩码255.255.255.0 与内网网卡同网段</p><p>然后使用<code>firewall-cmd --add-masquerade --permanent</code></p><p>Masquerading is useful if the machine is a router and machines connected over an interface in another zone should be able to use the first connection.<br>通过另一个区域(zone)的接口 使用默认zone的接口上网</p><p><a href="https://www.server-world.info/en/note?os=CentOS_7&amp;p=firewalld&amp;f=2" target="_blank" rel="noopener">https://www.server-world.info/en/note?os=CentOS_7&amp;p=firewalld&amp;f=2</a><br>配置完才发现的神网址…. 好吧 写得非常清楚</p><h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><p><code>drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs</code><br>档案权限类型<br>连接数<br>档案拥有者<br>档案所属群组<br>档案容量<br>档案最后被修改时间<br>档名</p><p>文件类型和权限<br><code>drwxr-xr-x</code></p><p>第一位 d 表明档案类型是 目录</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>目录</td></tr><tr><td>-</td><td>文件</td></tr><tr><td>|</td><td>链接文件</td></tr><tr><td>b</td><td>设备文件中可供存储的周边设备, 可随机读取设备</td></tr><tr><td>c</td><td>序列号设备, 如键盘鼠标, 一次性读取设备</td></tr></tbody></table><p>后面每三位一组 为<code>rwx</code>的组合 分别代表 <code>读</code>, <code>写</code>, <code>执行</code><br>三组 第一组<code>文件拥有者权限</code> 第二组<code>群组中账号权限</code> 第三组<code>非本人且没有加入本群组的其他账号权限</code></p><p>第三部分表示这个文件的<code>拥有者账号</code><br>第四部分表示这个文件<code>所属群组</code></p><p>相关命令<br>-chgrp 改变文件所属群组<br>-chown 改变文件拥有者<br>-chmod 改变文件权限</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNP卷二读书记录</title>
      <link href="/2020/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-UNP%E5%8D%B7%E4%BA%8C/"/>
      <url>/2020/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-UNP%E5%8D%B7%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h1><h2 id="管道和有名管道FIFO"><a href="#管道和有名管道FIFO" class="headerlink" title="管道和有名管道FIFO"></a>管道和有名管道FIFO</h2><p><strong>popen pclose</strong></p><pre><code class="c++">#include &lt;stdio.h&gt;// 成功返回文件指针, 出错为NULLFILE* popen(const char *command, const char *type);FILE* fp = popen(command, &quot;r&quot;);// 成功为shell终止状态, 出错则为 -1int pclose(FILE *stream);pclose(fp);</code></pre><p>popen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道<br>返回的文件指针作用<br>通过type参数控制<br>type = “r” 创建者 通过文件指针读入command命令产生的标准输出<br>type = “w” 创建者 通过文件指针为command命令提供标准输入</p><p>pclose 关闭这个标准IO流</p><p><strong>FIFO 先进先出(first in, first out)</strong></p><p>又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应.<br>从而允许无亲缘关系的进程访问同一个FIFO</p><pre><code class="c++">#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;// 成功返回 0 失败返回 -1int mkfifo(const char *pathname, mode_t mode);const char FIFO1 = &quot;/tmp/fifo.1&quot;;mkfifo(FIFO1, 0666);// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数int writefd = open(FIFO1, O_WRONLY, 0); /* 在父进程中打开 父进程写 */int readfd = open(FIFO1, O_RDONLY, 0); /* 在子进程中打开 子进程读 */// 只有调用unlink才能从文件系统删除文件名字unlink(FIFO1);</code></pre><p>mkfifo 隐含已经指定 O_CREAT | O_EXCL<br>要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)</p><p>如果想要打开已经存在的FIFO可以使用open函数.<br>可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开</p><pre><code class="c++">// 子进程readfd = open(FIFO1, O_RDONLY, 0);writefd = open(FIFO2, O_WRONLY, 0);// 父进程writefd = open(FIFO1, O_WRONLY, 0);readfd = open(FIFO2, O_RDONLY, 0);// 父进程 这样会阻塞readfd = open(FIFO2, O_RDONLY, 0);writefd = open(FIFO1, O_WRONLY, 0);</code></pre><p>如果调换父进程的两行代码 程序就会进入死锁<br>因为如果当前没有任何进程<code>打开某个FIFO来写</code>, 打开这个<code>FIFO来读</code>的进程将会<code>阻塞</code></p><p>当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃</p><p>即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO<br>他们之间也不能通过FIFO从一个进程到另一个进程发送数据</p><p>拒绝服务型攻击Dos<br>如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求<br>导致服务器子进程数达到上限, 使得后续的fork失败</p><p><strong>其他</strong><br>从字节流中获取完整的单个信息</p><ul><li>带特殊终止序列<br>许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符</li><li>显式长度<br>将长度增加在请求中</li><li>每次连接一个记录<br>应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术</li></ul><p>标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联’</p><p><strong>限制</strong><br>系统加在管道和FIFO的唯一限制是</p><ul><li>OPEN_MAX<br>一个进程在任意时刻打开的最大描述符数量 &gt;=16</li><li>PIPE_BUF<br>可以原子性的写入一个管道或FIFO的最大数据量 &gt;= 512</li></ul><p><strong>习题练习</strong></p><ol><li>父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,<br>因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭,<br>他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)</li><li>从 不存在即创建, 存在-&gt;打开 变成 存在-&gt;打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前<br>被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败</li><li>出错信息写到了标准错误输出</li><li>可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除</li><li>死锁</li><li>读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),<br>写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)</li></ol><h2 id="POSIX消息队列"><a href="#POSIX消息队列" class="headerlink" title="POSIX消息队列"></a>POSIX消息队列</h2><p><strong>mqueue创建和删除</strong></p><pre><code class="c++">#include &lt;mqueue.h&gt;// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要// 权限位 和 指定某些属性 nullptr则使用默认属性// 成功返回消息队列 fd 失败 -1mqd_t mq_open(const char *name, int oflag, /*mode_t mode, struct mq_attr *attr*/);</code></pre><p>注意<br>消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数</p><pre><code class="c++">// 关闭消息队列 引用计数 -1int mq_close(mqd_t mqdes);</code></pre><p>类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除</p><p>当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close</p><p>如果要从系统中删除<code>mq_open</code>第一个参数<code>name</code> 必须调用下面的函数</p><pre><code class="c++">// 引用计数 -1int mq_unlink(const char *name);</code></pre><p>每个消息队列有一个保存着当前打开描述符数的引用计数器</p><p>当消息队列的引用计数仍大于0时, 其name就能删除<br>但是队列的析构会在<code>引用计数为0</code>的时候自动析构.</p><p>第一个demo敲完之后 一直是errno=13.<br>在<code>man mq_overview</code></p><pre><code>On Linux, message queues are created in a virtual filesystem.   (Other  implementa‐tions may also provide such a feature, but the details are likely to differ.)  Thisfilesystem can be mounted (by the superuser) using the following commands:# mkdir /dev/mqueue# mount -t mqueue none /dev/mqueueThe sticky bit is automatically enabled on the mount directory.</code></pre><p>而且 name参数的格式是<code>/somename</code> 这个是相对挂载目录的</p><p><strong>属性设置</strong></p><pre><code class="c++">struct mq_attr{    long mq_flags; /* 0, O_NONBLOCK */    long mq_maxmsg; /* max number */    long mq_msgsize; /* max size of a msg in bytes */    long mq_curmsgs; /* number of message currently on queue */}int mq_getattr(mqd_t mqdes, struct mq_attr *attr);// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK// 最大消息数和最大字节数 只能在创建队列的时候设置// 队列中房钱消息数 只能获取不能设置// 第三个参数 不为nullptr则返回之前的属性int mq_setattr(mqd_t mqdes, const struct mq_attr *attr, struct mq_attr *oattr);</code></pre><p><strong>发送接收信息</strong></p><pre><code class="c++">// prio 优先级 必须 &lt;= MQ_PRIO_MAXint mq_send(mqd_t mqdes, const char *ptr, size_t len, unsigned int prio);// len 必须 &gt;= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZEssize_t mq_receive(mqd_t mqdes, const char *ptr, size_t len, unsigned int *priop);</code></pre><p>如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0<br>接受的时候 mq_receive priop 设置为 nullptr</p><p><strong>消息队列的限制</strong></p><ul><li>mq_maxmsg 队列中最大消息数</li><li>mq_msgsize单个消息的最大字节</li><li>MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目</li><li>MQ_PRIO_MAX 最大优先级+1</li></ul><p><strong>异步事件通知</strong></p><ul><li>产生信号</li><li>创建一个线程执行一个指定的函数</li></ul><pre><code class="c++">// 为指定队列建立或者删除异步事件通知.// 成功返回 0 失败返回 -1int mq_notify(mqd_t mqdes, struct sigevent *nofification);struct sigval{    int sival_int;    void *sival_ptr;}struct sigevent{    int sigev_notify; // SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD    int sigev_signo; // signal number if SIGEV_SIGNAL    union sigval sigev_value; // passed to signal handler pr thread    // 下面两个用于 SIGEV_THREAD    void (*sigev_notify_function)(union sigval);    pthread_attr_t *sigev_notify_attributes;}</code></pre><ol><li><p>如果 notification != nullptr<br>当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知<br>我们说 该进程被注册为接收该队列的通知</p></li><li><p>如果 notification == nullptr<br>如果 该进程被注册为 接受所指定队列通知 则取消它</p></li><li><p>任何时刻只有一个进程可以被注册为 接收某个队列的通知</p></li><li><p>当一个消息到达某个空队列, 而且已经注册, 那么只有当<br>没有因为调用mq_reveive导致的阻塞 的时候才会发出通知</p></li><li><p>通知发出后 注册立即被撤销.. 需要重新注册???</p></li></ol><p>Unix信号产生后会复位成默认行为.<br>信号处理程序通常第一个调用signal函数, 用于重新建立处理程序<br>这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)<br>空窗时期再次产生同一信号 可能终止当前进程</p><p>初看起来, mq_notify可能也有这个问题.<br>不过在消息队列<code>为空前</code> <code>通知不会再次产生</code><br>所以不要在<code>读出消息后</code>重新注册<br>而应该在<code>读出消息前</code>重新注册</p><p><code>volatile sig_atomic_t mqflag = 0;</code><br>sig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。<br>volatile 标记可能会随时改变</p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试</title>
      <link href="/2020/03/Linux-GDB%E8%B0%83%E8%AF%95/"/>
      <url>/2020/03/Linux-GDB%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p><p>对多线程的支持<br>set follow-fork-mode [parent|child]<br>set detach-on-fork [on|off]</p><table><thead><tr><th>follow-fork-mode</th><th>detach-on-fork</th><th>说明</th></tr></thead><tbody><tr><td>parent</td><td>on</td><td>只调试主进程</td></tr><tr><td>child</td><td>on</td><td>只调试子进程</td></tr><tr><td>parent</td><td>off</td><td>同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置</td></tr><tr><td>child</td><td>off</td><td>同上 gdb跟踪子进程, 父进程阻塞</td></tr></tbody></table><p>进程间切换</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>info inferiors</td><td>查询正在调试的进程</td></tr><tr><td>inferior <code>&lt;number&gt;</code></td><td>切换进程</td></tr></tbody></table><p>栈相关</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>up/down</td><td>改变堆栈的显示深度</td></tr><tr><td>info stack</td><td>查看所有栈的信息</td></tr><tr><td>backtrace</td><td>缩写bt 同上</td></tr><tr><td>info frame</td><td>显示当前栈的详细信息</td></tr><tr><td>frame</td><td>缩写是f  显示当前栈的简单信息</td></tr><tr><td>frame n</td><td>切换到 第n层栈</td></tr></tbody></table><table><thead><tr><th>运行命令</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>run</td><td>r</td><td>运行程序</td></tr><tr><td>continue</td><td>c</td><td>继续执行到下有一个断点处</td></tr><tr><td>next</td><td>n</td><td>单步跟踪, 不进入函数</td></tr><tr><td>step</td><td>s</td><td>会进入函数</td></tr><tr><td>until</td><td></td><td>运行程序直到退出循环体</td></tr><tr><td>until + 行号</td><td></td><td>运行至某行</td></tr><tr><td>finish</td><td></td><td>运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息</td></tr><tr><td>call 函数(参数)</td><td></td><td>调试程序中的可见参数, 并传递参数</td></tr><tr><td>quit</td><td>q</td><td>退出</td></tr></tbody></table><table><thead><tr><th>设置断点</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>break n</td><td>b n</td><td>在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行)</td></tr><tr><td>b f if a&gt;b</td><td></td><td>在函数f 设置条件断点</td></tr><tr><td>b n if a&gt;b</td><td></td><td>在行号n 设置条件断点</td></tr><tr><td>break func</td><td>b func</td><td>在函数func()的入口处设置断点</td></tr><tr><td>delete 断点号n</td><td></td><td>删除第n个断点</td></tr><tr><td>disable 断点号n</td><td></td><td>暂停第n个断点</td></tr><tr><td>enable 断点号n</td><td></td><td>开始第n的断点</td></tr><tr><td>clear 行号n</td><td></td><td>清除第n行的断点</td></tr><tr><td>info b</td><td></td><td>显示断点设置情况</td></tr><tr><td>delete breakpoints</td><td></td><td>清除所有断点</td></tr></tbody></table><table><thead><tr><th>查看源代码</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>默认显示10行</td></tr><tr><td>list 行号</td><td></td><td>以行号为中心的前后十行代码</td></tr><tr><td>list 函数名</td><td></td><td>列出函数名所在函数的代码</td></tr><tr><td>list</td><td></td><td>不带参数, 接着上一次的list命令输出下边的内容</td></tr></tbody></table><table><thead><tr><th>打印表达式</th><th>功能</th></tr></thead><tbody><tr><td>print p</td><td></td></tr><tr><td>p a</td><td>显示a的值</td></tr><tr><td>p ++a</td><td>a的值</td></tr><tr><td>p func(22)</td><td>以整数22作为参数调用 后打印</td></tr><tr><td>p func(a)</td><td>将变量a作为参数</td></tr><tr><td>display 表达式</td><td>每次单步运行后就打印表达式的值</td></tr><tr><td>watch 表达式</td><td>设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序</td></tr><tr><td>whatis</td><td>查询变量或函数</td></tr><tr><td>info function</td><td>查询函数</td></tr><tr><td>info local</td><td>显示当前堆栈页的所有变量</td></tr></tbody></table><table><thead><tr><th>查询运行信息</th><th>功能</th></tr></thead><tbody><tr><td>where/bt</td><td>当前运行的堆栈列表</td></tr><tr><td>bt backtrace</td><td>显示当前的调用堆栈</td></tr><tr><td>set args [args]</td><td>指定程序运行参数</td></tr><tr><td>show args</td><td>查看程序参数</td></tr><tr><td>info program</td><td>查看程序是否运行, 进程号, 被暂停原因</td></tr></tbody></table><h1 id="安装DebugInfo"><a href="#安装DebugInfo" class="headerlink" title="安装DebugInfo"></a>安装DebugInfo</h1><pre><code>cat /etc/yum.repos.d/CentOS-Debug.repo[debug]name=CentOS-$releasever - DebugInfobaseurl=http://debuginfo.centos.org/$releasever/$basearch/gpgcheck=0enabled=1 # 重点是这个 protect=1priority=1安装 kernel-debuginfoyum --enablerepo=base-debug install -y kernel-debuginfo-$(uname -r)安装glibc, 提示缺少其他的也是如此安装debuginfo-install glibc</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux高性能服务器-理论部分</title>
      <link href="/2020/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9599-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/"/>
      <url>/2020/03/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9599-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.<br>半年后开始准备补上这四章</p><p>2020年7月16日12:37:33</p><p>大二暑假了, 准备把这本书没读完的部分 读完 整理下已读的部分<br>基础理论部分, 由于已经上完了计算机网络这门课, 另出了一篇博客. 这里就不详细写了<br>主要整理后面的内容分</p><h1 id="第一章-TCP-IP协议族"><a href="#第一章-TCP-IP协议族" class="headerlink" title="第一章 TCP/IP协议族"></a>第一章 TCP/IP协议族</h1><h2 id="TCP-IP协议族体系结构和主要协议"><a href="#TCP-IP协议族体系结构和主要协议" class="headerlink" title="TCP/IP协议族体系结构和主要协议"></a>TCP/IP协议族体系结构和主要协议</h2><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg" alt=""></p><p>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p><p><strong>应用层</strong><br>负责处理应用程序的逻辑</p><p><strong>表示层</strong><br>定义了数据的格式及加密</p><p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p><p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br>TCP协议(Transmission Control Protocol 传输控制协议)</p><ul><li>为应用层提供<code>可靠的, 面向连接, 基于流的服务</code></li><li>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.</li><li>TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器<br>```<br>0                   1                   2                   3<br>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</li></ul><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|          Source Port          |       Destination Port        |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|                        Sequence Number                        |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|                    Acknowledgment Number                      |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|  Data |           |U|A|P|R|S|F|                               |<br>| Offset| Reserved  |R|C|S|S|Y|I|            Window             |<br>|       |           |G|K|H|T|N|N|                               |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|           Checksum            |         Urgent Pointer        |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|                    Options                    |    Padding    |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>|                             data                              |<br>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><pre><code>UPD协议(User Datagram Protocol 用户数据报协议)- 为应用层提供`不可靠的, 无连接的, 基于数据报的服务`- 一般需要自己处理`数据确认`和`超时重传`的问题- 通信两者不存储状态, 每次发送都需要指定地址信息. `有自己的长度`</code></pre><p> 0      7 8     15 16    23 24    31<br>+——–+——–+——–+——–+<br>|     Source      |   Destination   |<br>|      Port       |      Port       |<br>+——–+——–+——–+——–+<br>|                 |                 |<br>|     Length      |    Checksum     |<br>+——–+——–+——–+——–+<br>|<br>|          data octets …<br>+—————- …</p><pre><code>User Datagram Header Format</code></pre><pre><code>**网络层**实现了数据包的选路和转发.  只有数据包到不了目标地址, 就`下一跳`(hop by hop), 选择最近的.*IP协议(Internet Protocol)* 以及 *ICMP协议(Internet Control Message Protocol)* 后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)**数据链路层**实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.存在两个协议 *ARP协议(Address Resolve Protocol, 地址解析协议)*. 还有*RARP(Reverse ~, 逆地址解析协议)*.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议*ARP欺骗, 可能与这个有关, 目前不去学习***封装**上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.被TCP封装的数据成为 `TCP报文段`- 内核部分发送成功后删除数据被UDP封装的数据成为 `UDP数据报`- 发送后即删除再经IP封装后成为`IP数据报`最后经过数据链路层封装后为 `帧`以太网最大数据帧1518字节 抛去14头部 帧尾4校验MTU: 帧的最大传输单元 一般为1500字节MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头 - 20TCP头 还有额外的40字节可选部分**ARP**ARP协议能实现任意网络层地址到任意物理地址的转换# 第二章 IP协议详解IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一IP协议为上层协议提供无状态, 无连接, 不可靠的服务IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png)路由机制![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png)给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤- 查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步- 查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到....... 否则下一步- 选择默认路由项, 通常意味着下一跳路由是网关# 第三章 TCP协议详解Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断ISN-初始序号值32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为`确认报文段`PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间RST标志: 要求对方重新建立连接 携带......`复位报文段`SYN标志: 标志请求建立一个连接 携带......`同步报文段`FIN标志: 通知对方本端连接要关闭了, 携带..`结束报文段`16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据16位校验和: `可靠传输的重要保障`发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验`TCP头部`和`数据部分`额外参数之窗口扩大因子, TCP连接初始化时, 双方使用该选项协商通告窗口的扩大因子. 通告窗口大小是16位即最大65535字节, 但实际会比这个要大假设通告窗口大小为N, 扩大因子是M(位移数, 0-14) 实际通告窗口大小为 N*2^M, 或者称为N左移M位**TCP连接的建立和关闭**```s# 同步报文段 需要占用一个序号值10:19:15.870206 IP localhost.46836 &gt; localhost.8222: Flags [S], seq 559157932, win 43690, options [mss 65495,sackOK,TS val 2968784041 ecr 0,nop,wscale 7], length 010:19:15.870219 IP localhost.8222 &gt; localhost.46836: Flags [S.], seq 900113542, ack 559157933, win 43690, options [mss 65495,sackOK,TS val 2968784041 ecr 2968784041,nop,wscale 7], length 010:19:15.870228 IP localhost.46836 &gt; localhost.8222: Flags [.], ack 1, win 342, options [nop,nop,TS val 2968784041 ecr 2968784041], length 010:19:18.113588 IP localhost.46836 &gt; localhost.8222: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 2968786284 ecr 2968784041], length 0# 由于被动方没有数据要发送同时发送了 FIN ACK 10:19:18.113664 IP localhost.8222 &gt; localhost.46836: Flags [F.], seq 1, ack 2, win 342, options [nop,nop,TS val 2968786284 ecr 2968786284], length 010:19:18.113678 IP localhost.46836 &gt; localhost.8222: Flags [.], ack 2, win 342, options [nop,nop,TS val 2968786284 ecr 2968786284], length 0# 完整序号10:31:15.259169 IP localhost.46944 &gt; localhost.8222: Flags [S], seq 898081536, win 43690, options [mss 65495,sackOK,TS val 2969503401 ecr 0,nop,wscale 7], length 010:31:15.259180 IP localhost.8222 &gt; localhost.46944: Flags [S.], seq 3168567292, ack 898081537, win 43690, options [mss 65495,sackOK,TS val 2969503401 ecr 2969503401,nop,wscale 7], length 010:31:15.259190 IP localhost.46944 &gt; localhost.8222: Flags [.], ack 3168567293, win 342, options [nop,nop,TS val 2969503401 ecr 2969503401], length 010:31:17.144633 IP localhost.46944 &gt; localhost.8222: Flags [F.], seq 898081537, ack 3168567293, win 342, options [nop,nop,TS val 2969505287 ecr 2969503401], length 010:31:17.144800 IP localhost.8222 &gt; localhost.46944: Flags [F.], seq 3168567293, ack 898081538, win 342, options [nop,nop,TS val 2969505287 ecr 2969505287], length 010:31:17.144814 IP localhost.46944 &gt; localhost.8222: Flags [.], ack 3168567294, win 342, options [nop,nop,TS val 2969505287 ecr 2969505287], length 0</code></pre><p><strong>TCP超时重传</strong><br>TCP服务必须能够进行超时重传<br>这就需要为每个TCP报文段维护一个重传定时器, 发送时启动<br>如果超时后依然没有收到回复则进行重发 并重置定时器</p><p>超时时间 0.2 0.4 0.8 1.6 3.2 单位是秒, 类似TCP超时重连<br>重传最多次数 默认15</p><p><strong>拥塞控制</strong><br>提高网络利用率, 降低丢包率 保证网络资源对每条数据流的公平性 –拥塞控制</p><h1 id="第四章TCP-IP通信案例"><a href="#第四章TCP-IP通信案例" class="headerlink" title="第四章TCP/IP通信案例"></a>第四章TCP/IP通信案例</h1><p>上游服务器: 一个HTTP请求可能被多个代理服务器转发, 后面的服务器称为前面的服务器的上游服务器</p><p>正向代理服务器: 要求客户端自己设置代理服务器的地址, 客户将每次请求都直接发送到该代理服务器,并由代理服务器来请求目标资源<br>反向代理服务器: 被设置在服务器端, 客户端无需进行设置. 用代理服务器接收网络上的请求, 然后将请求转发给内网上的服务器, 并将从内部服务器上得到的结果返回给客户端, 代理服务器对外表现为一个真正的服务器.</p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分支管理和实际应用及commit规范</title>
      <link href="/2020/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%8F%8Acommit%E8%A7%84%E8%8C%83/"/>
      <url>/2020/03/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%8F%8Acommit%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下<br>2020年7月29日10:53:32 更新 删除一些无意义的话….<br>2021年2月26日23:06:22 合并文档</p><h1 id="压缩提交"><a href="#压缩提交" class="headerlink" title="压缩提交"></a>压缩提交</h1><pre><code class="shell"># 压缩两个提交git rebase --interactive HEAD~2# 将# pick c6d7bf6 fix namespace bug# pick 1c648d8 fix namespace bug# pick 7c648d8 fix namespace bug# 改为# pick c6d7bf6 fix namespace bug# s 1c648d8 fix namespace bug# s 7c648d8 fix namespace bug# 压缩所有提交git rebase --interactive -root# 更新所有submodule# 首次运行git submodule update --init --recursive# 之后运行git submodule foreach --recursive git pull origin master -f</code></pre><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p><code>git checkout -b dev</code>相当于一下两条命令<br><code>git branch dev</code> 分支创建<br><code>git checkout dev</code> 分支切换</p><p><code>git branch -d dev</code> 分支删除</p><p><code>git branch</code> 查看当前所有分支</p><p><strong>分支管理</strong></p><p>通常Git会使用<code>Fast forward</code>模式 这样删除分支后会丢失分支的信息<br>可以再merge的时候加入<code>--no-ff</code>这样就能解决问题<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>由于禁用<code>Fast forward</code>后<br>会生成新的commit所以需要加入<code>-m &quot;merge with no-ff&quot;</code></p><p><strong>暂存代码</strong></p><p>git stash 可以储存当前的工作区 恢复到上一次commit后<br>git stash list 查看储存的工作区列表<br>git stash apply stash@{0} 恢复指定的储存<br>git stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的</p><h1 id="实际工作中分支的应用"><a href="#实际工作中分支的应用" class="headerlink" title="实际工作中分支的应用"></a>实际工作中分支的应用</h1><p><a href="https://zhuanlan.zhihu.com/p/38772378" target="_blank" rel="noopener">主要参考</a></p><p><strong>主分支</strong></p><ul><li><strong>master</strong>: 这个分支最稳定, 相当于放的可发布版本</li><li><strong>develop</strong>: 开发分支, 平行于master分支, 负责合并各种<code>用于开发子功能</code>的分支</li></ul><p><strong>支持分支</strong>:解决某个问题, 结束后合并回<code>master</code>或<code>develop</code>分支</p><ul><li><strong>feature</strong>功能分支, 用于开发一个个子功能, 来自<code>develop</code>合并到<code>develop</code>去</li><li><strong>release</strong>:发布分支, 用于修改版本号等小修改, 来自<code>develop</code>分支合并到<code>master</code>分支</li><li><strong>hotfixes</strong>:紧急修复bug分支, 从<code>master</code>创建, 合并回<code>develop</code>分支和<code>master</code>分支</li></ul><p><img src="https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg" alt="1"><span class="img-alt">1</span></p><p><a href="https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14" target="_blank" rel="noopener">Git 分支管理规范</a></p><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">Git 基础 - 打标签</a></p><p><strong>develop分支完成了操作, 准备发布新的版本</strong></p><pre><code class="shell"># 从 develop 分支上创建 release 分支:# 命名规则如下 release-事件-版本git checkout –b release-20190919-v1.0.0 develop# 修复完release的bug后再次提交修改:git checkout release-20190919-v1.0.0# 提交本地修改, 如果没有修改bug 可以跳过git add .git commit –m “提交日志”# 推送 release 分支git push origin release-20190919-v1.0.0# 发布新版本# 合并 release 分支到 master 分支:git checkout mastergit merge --no-ff release-20190919-v1.0.0# 合并 release 分支到 develop 分支:git checkout developgit merge --no-ff release-20190919-v1.0.0# 在 master 分支上创建标签:git tag tag-20190919-v1.0.0# 删除本地 release 分支:git branch –d release-20190919-v1.0.0# 删除远程 release 分支:git push origin :release-20190919-v1.0.0</code></pre><p>新版本完成之后</p><pre><code class="shell"># 推送master分支git push origin master# 注意上边打的tag需要手动提交 默认push不会提交taggit push origin [tag name]# 也可以给push增加参数git push origin --tags</code></pre><h1 id="本地和远程分支和tag的删除"><a href="#本地和远程分支和tag的删除" class="headerlink" title="本地和远程分支和tag的删除"></a>本地和远程分支和tag的删除</h1><pre><code class="shell"># 本地git tag -d xxxgit branch -d xxx# 远程git push origin :refs/tags/xxxgit push origin :xxx</code></pre><h1 id="commit-规范"><a href="#commit-规范" class="headerlink" title="commit 规范"></a>commit 规范</h1><p><a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">阮一峰 Commit message 和 Change log 编写指南</a></p><p>Angular 规范.<br>每个commit message 包括三分部<br>Header Body 和 Footer</p><pre><code class="txt">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; // 必须// 空一行&lt;body&gt; // 非必须// 空一行&lt;footer&gt; //非必须</code></pre><p><strong>Header</strong></p><ol><li>type 必需 - 说明commit的类别, 只允许下面七个标识<ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul></li><li>scope 非必需 - 用于说明 commit影响的范围 比如登录、注册、充值逻辑等等，视项目不同而不同。</li><li>subject 必需 - commit 目的的简短描述<ul><li>不超过50字符</li><li>第一人称现在时动词开头</li><li>首字母小写</li><li>句尾不加句号</li></ul></li></ol><p><strong>Body</strong><br>本次commit的详细描述, 可以分成多行</p><p><strong>Footer</strong><br>只用于两种情况 目前用不动 不摘了</p><h1 id="撤销add-以及-撤销-commit"><a href="#撤销add-以及-撤销-commit" class="headerlink" title="撤销add 以及 撤销 commit"></a>撤销add 以及 撤销 commit</h1><p>撤销add: <code>git reset 111.txt</code></p><p>撤销创建仓库后的第一次commit <code>git update-ref -d HEAD</code></p><p>不删除工作空间改动的代码, 撤销commit 撤销 git add <code>git reset --mixed HEAD^</code>对应默认<code>git reset HEAD^</code></p><p>不删除工作空间改动的代码, 撤销commit 不撤销 git add <code>git reset --soft HEAD^</code></p><p>删除上次commit之后工作空间改动的代码, 撤销commit 撤销 git add 代码回复到上一次提交结束<code>git reset --hard HEAD^</code>  这会直接让撤销的commit代码丢失</p><p>恢复<code>git reset --hard</code> 使用<code>git reflog</code> 查看历史记录</p><pre><code class="txt">$ git reflog15a06e6 (HEAD -&gt; master) HEAD@{0}: reset: moving to HEAD^14b420e HEAD@{1}: commit: 11111115a06e6 (HEAD -&gt; master) HEAD@{2}: commit (amend): 111$ git reset --hard 14b420e</code></pre><p>修改commit内容 <code>git commit --amend</code></p><h1 id="Merge和Rebase"><a href="#Merge和Rebase" class="headerlink" title="Merge和Rebase"></a>Merge和Rebase</h1><pre><code class="txt">$ cat 111.txt(master)111222444$ cat 111.txt(develop)111222333</code></pre><p><strong>Merge</strong></p><p>在master分支使用<code>git merge develop</code>, 提示有冲突</p><pre><code class="txt">$ git merge develop(master)Auto-merging 111.txtCONFLICT (content): Merge conflict in 111.txtAutomatic merge failed; fix conflicts and then commit the result.$ cat 111.txt111222&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD444=======333&gt;&gt;&gt;&gt;&gt;&gt;&gt; develop$ 解决完冲突后add commit 多了一条记录  合并后的commit按照从旧到新排列Merge: fa72731 0ad9e6bAuthor: lsmg &lt;rjd67441@hotmail.com&gt;Date:   Sat Mar 6 16:07:08 2021 +0800    merge develop into master</code></pre><p><strong>Rebase</strong></p><p>在develop分支进行rebase操作, 将develop的base改为master分支</p><pre><code class="txt">$ git rebase master (develop)  提示develop分支的第一次提交和master的最新提交有冲突error: could not apply 0ad9e6b... develop-3Resolve all conflicts manually, mark them as resolved with&quot;git add/rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.You can instead skip this commit: run &quot;git rebase --skip&quot;.To abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;.Could not apply 0ad9e6b... develop-3Auto-merging 111.txtCONFLICT (content): Merge conflict in 111.txt$ cat 111.txt111222&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD444=======333&gt;&gt;&gt;&gt;&gt;&gt;&gt; 0ad9e6b... develop-3$ git add 111.txt 解决完冲突后 add</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Git操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环判断中使用无符号类型</title>
      <link href="/2020/03/%E9%87%87%E5%9D%91%E8%AE%B0-%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E4%B9%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/03/%E9%87%87%E5%9D%91%E8%AE%B0-%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E4%B9%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>下面的代码 会产生错误.</p><pre><code class="c++">vector&lt;int&gt; test;for (int i = 0; i &lt; test.size() - 1; ++i){}</code></pre><p>无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.</p><p>但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int<br>对于unsigned char在转换成int时，无论最高位是0还是1，都补0<br>signed char的则高位时1补1 0补0</p><pre><code class="c++">// 0*23 1// 1*23 0// 1*24 本来是int 但被当作了 无符号int 所以输出unsigned int a = 1;int b = -2;if (a &lt; b) // 逻辑运算也转换了{    cout &lt;&lt; &quot;a &lt; b&quot; &lt;&lt; endl; // 输出}cout &lt;&lt; a + b &lt;&lt; endl; // 4294967295//   11111111 11111111 11111111 11111111//   00000000 00000000 00000000 00000010// 1 00000000 00000000 00000000 00000001unsigned int c = 2; // 0*22 1 0int d = -1; // 1*24if (c &lt; d){    cout &lt;&lt; &quot;c &lt; d&quot; &lt;&lt; endl; // 输出}cout &lt;&lt; c + d &lt;&lt; endl; // 1   直接把高位的1溢出了 留下了0// 2*23 1// 1*23 0// 1*24 被转换成了int 所以输出-1unsigned char e = 1;char f = -2;if (e &lt; f){    cout &lt;&lt; &quot;e &lt; f&quot; &lt;&lt; endl; // 没有输出}cout &lt;&lt; e + f &lt;&lt; endl; // -1unsigned char g = 2;char h = -1;if (g &lt; h){    cout &lt;&lt; &quot;g &lt; h&quot; &lt;&lt; endl; // 未输出}cout &lt;&lt; g + h &lt;&lt; endl; // 1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 采坑记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 采坑记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jsoncpp代码阅读</title>
      <link href="/2020/03/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Jsoncpp%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2020/03/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Jsoncpp%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<pre><code class="c++">Json::Value root;root[&quot;action&quot;] = &quot;run&quot;;</code></pre><p>首先是 <code>[]运算符重载</code> , 统一不同的重载类型<br>调用<code>resolveReference()</code>进行统一的添加<code>k</code>操作</p><p>首先会进行 校验参数, 然后将key封装成一个对象CZString (封装过程为将传入指针保存到 CZString对象中的cstr_)<br>封装完成后再保存<code>k v</code>的<code>map&lt;CZString, Value&gt;</code>中查找有无相同的CZString(key)有的话返回Value引用,<br>没有则创建新的&lt;CZStrng, 空Value&gt;存入map并返回Value的引用</p><p>然后是<code>=运算符重载</code>, “run”自动转换成Value对象<br>转换过程中, 通过<code>duplicateAndPrefixStringValue()</code>将”run”进行了封装<br><code>char* string_; // if allocated_, ptr to { unsigned, char[] }.</code><br>将长度封装到了一个char指针中, 有点类似自己设计tcp协议…</p><p><code>=运算符重载</code>函数将<code>[]运算符重载</code>返回的对象引用 中的相关值<code>swap()</code>成新的Value对象中的相关值</p><p>到这里理解了在Jsoncpp中 一切都是Value 包括&lt;K, V&gt;键值对也是在Value对象中存储<br>每一个&lt;k, v&gt;都可以作为一个Value对象, 这样既实现了复杂嵌套Json中 v为对象的情况 妙啊</p><pre><code class="c++">// 每个Value对象中都维护一个unionunion ValueHolder {    LargestInt int_;    LargestUInt uint_;    double real_;    bool bool_;    char* string_; // if allocated_, ptr to { unsigned, char[] }.    // 将所有的存贮着key的CZString保存起来    //  typedef std::map&lt;CZString, Value&gt; ObjectValues; // std::map&lt;CZString, Value&gt; 键值对    ObjectValues* map_;  } value_;</code></pre><p>下面的switch的这个type 会在很多地方被修改掉.<br>起初 使用默认构造函数的value type是nullxxx<br>然后调用<code>[]运算符重载</code>的时候会修改掉 type 为 objectValue</p><pre><code class="c++">// 递归调用 进行处理void BuiltStyledStreamWriter::writeValue(Value const&amp; value) {  switch (value.type()) {  case nullValue:    pushValue(nullSymbol_);    break;  case intValue:    pushValue(valueToString(value.asLargestInt()));    break;  case uintValue:    pushValue(valueToString(value.asLargestUInt()));    break;  case realValue:    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,                            precisionType_));    break;  case stringValue: {    // Is NULL is possible for value.string_? No.    char const* str;    char const* end;    bool ok = value.getString(&amp;str, &amp;end);    if (ok)      pushValue(valueToQuotedStringN(str, static_cast&lt;unsigned&gt;(end - str),                                     emitUTF8_));    else      pushValue(&quot;&quot;);    break;  }  case booleanValue:    pushValue(valueToString(value.asBool()));    break;  case arrayValue:    writeArrayValue(value);    break;  case objectValue: {    Value::Members members(value.getMemberNames());    if (members.empty())      pushValue(&quot;{}&quot;);    else {      writeWithIndent(&quot;{&quot;);      indent();      auto it = members.begin();      for (;;) {        String const&amp; name = *it;        Value const&amp; childValue = value[name];        writeCommentBeforeValue(childValue);        writeWithIndent(valueToQuotedStringN(            name.data(), static_cast&lt;unsigned&gt;(name.length()), emitUTF8_));        // :        *sout_ &lt;&lt; colonSymbol_;        writeValue(childValue);        if (++it == members.end()) {          writeCommentAfterValueOnSameLine(childValue);          break;        }        *sout_ &lt;&lt; &quot;,&quot;;        writeCommentAfterValueOnSameLine(childValue);      }      unindent();      writeWithIndent(&quot;}&quot;);    }  } break;  }}</code></pre><p>这次是根据下面的例子分析的</p><pre><code class="c++">int main() {  Json::Value root;  Json::Value data;  constexpr bool shouldUseOldWay = false;  // 左侧返回Value的引用  root[&quot;action&quot;] = &quot;run&quot;;  data[&quot;number&quot;] = 1;  root[&quot;data&quot;] = data;  if (shouldUseOldWay) {    Json::FastWriter writer;    const std::string json_file = writer.write(root);    std::cout &lt;&lt; json_file &lt;&lt; std::endl;  } else {    // 配置文件也是Value对象, 我用我自己.jpg    Json::StreamWriterBuilder builder;    const std::string json_file = Json::writeString(builder, root);    std::cout &lt;&lt; json_file &lt;&lt; std::endl;  }  return EXIT_SUCCESS;}</code></pre><p>算是了解到了这个库的大概工作流程了. 能学到的部分 吃完午饭继续写.<br>吃完饭试了试家里的显示器, 家里的显示器还是太老了…… 八年的显示器了 看得我眼花<br>还是继续用笔记本吧</p><ol><li><p>首先我很喜欢这种运算符重载的使用形式, 用起来非常的舒服, 需要重载两个运算符 <code>[]</code>和<code>=</code> 而且<br><code>=运算符</code>重载使用的swap交换需要的属性, 感觉不错<br>(后来我看了EffectiveC++ 发现这是<code>=运算符处理自我赋值</code>太巧了)</p></li><li><p>针对需要加载配置文件的类 使用了工厂模式</p></li><li><p>writeValue使用了递归处理.</p></li><li><p>统一处理, k v都是Value对象</p></li><li><p>将用户的string 拷贝到新的<code>char*</code>中 同时在开头增加了长度, 尾部补了0, 没有使用额外的变量去存储<code>char*</code>的长度<br>不太清楚这样做有什么好处</p></li><li><p>常量全部用的 <code>static constexpr</code>修饰</p></li><li><p>恰当的对象嵌套</p></li></ol><hr><p>看完了从 Value到Json 接下来看看从Json到Value</p><pre><code class="c++">int main() {  const std::string rawJson = R&quot;({&quot;Age&quot;: 20, &quot;Name&quot;: &quot;colin&quot;})&quot;;  const auto rawJsonLength = static_cast&lt;int&gt;(rawJson.length());  constexpr bool shouldUseOldWay = false;  JSONCPP_STRING err;  Json::Value root;  if (shouldUseOldWay) {    Json::Reader reader;    reader.parse(rawJson, root);  } else {      // 默认构造函数 使用默认的配置    Json::CharReaderBuilder builder;    // 根据builder的配置生成CharReader类    const std::unique_ptr&lt;Json::CharReader&gt; reader(builder.newCharReader());    if (!reader-&gt;parse(rawJson.c_str(), rawJson.c_str() + rawJsonLength, &amp;root,                       &amp;err)) {      std::cout &lt;&lt; &quot;error&quot; &lt;&lt; std::endl;      return EXIT_FAILURE;    }  }  const std::string name = root[&quot;Name&quot;].asString();  const int age = root[&quot;Age&quot;].asInt();  std::cout &lt;&lt; name &lt;&lt; std::endl;  std::cout &lt;&lt; age &lt;&lt; std::endl;  return EXIT_SUCCESS;}</code></pre><p>解析的关键在于<code>parse()</code>函数 传入字符串的首尾指针, 和一个Value引用<br>进入函数后将传入的变量保存到了自己的成员变量中.</p><p>慢慢发现 这个库将很多的默认类型 起了别名 可能是为了统一类型 类似UE4也是自己搞了一套</p><p>主要是<code>OurReader</code>这个负责解析</p><pre><code class="c++">// 使用了大量的usingusing Char = char;using Location = const Char*;</code></pre><p>解析逻辑就是<code>parse()</code>调用<code>readValue()</code><br><code>readValue()</code>负责 获取下一次数据类型type_ -&gt;switch(type_) 根据分支决定是否递归再次调用<code>readValue</code><br>总算把逻辑看懂了, 代码依然认为很赞<br><code>readToken()</code>这个函数贯穿整个解析, 通过这个函数获取到下一次的数据是什么类型, 同时移动相关的状态指针<br><code>readToken()</code> 内部大量调用下面的函数 修改当前指针 同时返回字符, 然后switch这个字符判断下一次的数据类型<br>比如遇到<code>{</code>就是一个对象的开始设置好type并返回 遇到<code>}</code>就是对象的结束…..</p><pre><code class="c++">// 获取current_指向的字符 并自增OurReader::Char OurReader::getNextChar(){  if (current_ == end_)    return 0;  return *current_++;}</code></pre><p>一般第一次调用type_会被设置为对象类型, 然后<code>readValue()</code>进入<code>case 对象分支</code><br><code>case对象分支中</code><br>先进行了一次<code>readToken()</code>获取到了k的类型, 然后根据k类型分支 将k的值转换成对应的value<br>之后又是一次<code>readToken()</code>判断是否存在<code>:</code>不存在就是错误<br>在之后使用这个方法, 保存<code>k</code>的vallue获取<code>v</code>的value再次调用<code>readValue()</code>填充值 返回后继续走</p><pre><code class="c++">// 这里保存了name 这个k 将name的 v放入了顶层Value&amp; value = currentValue()[name];nodes_.push(&amp;value);bool ok = readValue();</code></pre><p>读取完<code>v</code>的value之后必定是<code>,</code>或者<code>}</code>又是一次判断 成功判断后一个<code>k v</code>就获取完毕了</p><p><code>using Nodes = std::stack&lt;Value*&gt;</code><br>后面解析的代码更加的妙不可言, 使用<code>Nodes nodes_{}</code>存储当前的value 实现函数之间的操作</p><p>代码合理的组织<br>比如<code>case 对象分支</code>必定是一个<code>k</code>一个<code>:</code>一个<code>v</code> 然后一个分隔符<code>,</code>或<code>}</code> 这些放入了一个函数</p><p>然后获取到<code>k</code>之后使用<code>Value&amp; value = currentValue()[name]</code>获取<code>v</code></p><p>最后依然是递归的使用</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>定义与声明详解</title>
      <link href="/2020/02/CPP-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/02/CPP-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="变量声明和变量定义"><a href="#变量声明和变量定义" class="headerlink" title="变量声明和变量定义"></a>变量声明和变量定义</h1><p>变量声明: 用于向程序表明变量的类型和名字<br>变量定义: 用于为变量<em>分配存储空间</em>, 同时可为变量指定初始值</p><p>定义时会自动声明, 变量只能被定义一次, 却可以声明多次<br>extern声明不是定义</p><pre><code class="c++">extern int i; // 声明i 但没有定义iint i; // 定义且声明iextern int i = 10; // 定义并声明// 如果再函数体内部试图初始化一个由extern标记的变量,会引发错误</code></pre><h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h1><p>只有extern声明位于函数外部的时候,才能被初始化</p><p><strong>在C++中 可以用来声明全局变量</strong></p><pre><code class="c++">// file1.cppint global_int = 1;// file2.cppextern int global_int;// 后面可以直接使用 global_int, 因为他在其他地方定义了</code></pre>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveCpp读书记录</title>
      <link href="/2020/02/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95110-Effective%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/02/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95110-Effective%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款02-尽量用const-enum-inline-替换-define"><a href="#条款02-尽量用const-enum-inline-替换-define" class="headerlink" title="条款02 尽量用const, enum, inline 替换#define"></a>条款02 尽量用const, enum, inline 替换#define</h2><p>前言 我目前自己做的框架中大量用了#define…. 因为用enum涉及到转换才能到int. 来学习下这条</p><p><strong>使用 const 常量来替换 #define</strong><br>谨防机号表出错, 特殊情况下 还能减少字量</p><p>#define无法限定作用域, 这点我已经感受到了</p><p>定义C风格常量字符串<br>const char* const NAME = “lsmg”; 防止指向和指向内容改变<br>定义C++风格常量字符串<br>const std::string NAME = “lsmg”;</p><p>class专属常量, 使用如下方式. 可以限定作用域</p><pre><code class="c++">class Game{private:    static const int MAX_ROOM = 10000; // 常量声明式 - 常量且只有一份    Gameroom* rooms[MAX_ROOM];}</code></pre><p>如果要获取class专属常量的地址, 或者需要定义式. 则需要在<code>实现文件</code>而非<code>头文件</code>, 如下声明<br><code>const int Game::MAX_ROOM</code> - 未给定初值<br>由于class常量已经在声明时获得初值, 所以不用在给定初值</p><h2 id="条款03-尽可能使用const"><a href="#条款03-尽可能使用const" class="headerlink" title="条款03 尽可能使用const"></a>条款03 尽可能使用const</h2><p><strong>总结</strong></p><ul><li>将某些东西声明为const可帮助编译器探测到错误用法<br>const可以用作在任何作用域内的对象, 函数参数, 函数返回类型, 成员函数本体</li></ul><pre><code class="c++">char greeting[] = &quot;Hello&quot;;char *p = greeting;// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量const char *p = greeting; // 指针指向可以变, 指向的值不能变char* const p = greeting; // 指针指向不可以变, 指向的值可以变const char* const p = greeting; // 都不可以变</code></pre><p><strong>const 参数, 可你帮你检查 == 被写成=的情况</strong></p><p><strong>const 函数, 这里看不太懂 没有原来如此的感觉</strong></p><h2 id="条款04-确定对象使用前已经被初始化"><a href="#条款04-确定对象使用前已经被初始化" class="headerlink" title="条款04 确定对象使用前已经被初始化"></a>条款04 确定对象使用前已经被初始化</h2><p><strong>总结</strong></p><ul><li>为内置型对象进行手工初始化.</li><li>构造函数最好使用成员初值列, 不要在构造函数中赋值. 初值列次数应该与声明次序相同</li><li>为了免除 跨编译单元的初始化次数问题, 用<code>local static</code>对象替换<code>non-local static</code>对象</li></ul><p>永远在使用对象前, 进行初始化.<br>在构造函数中, 对所有值进行初始化<br>构造函数使用<code>成员初始列</code>进行<code>初始化操作</code>而非<code>赋值操作</code></p><p><strong>减少default构造函数不必要的调用</strong></p><pre><code class="c++">Class A{public:    A(const std::string &amp;name, const std::list&lt;Gameroom&gt; &amp;room_list);private:    std::string name_;    std::list&lt;Gameroom&gt; room_list_;    int roomnum_;}A::A(const std::string &amp;name, const std::list&lt;Gameroom&gt; &amp;room_list){    name_ = name; // 这些都是赋值 不是初始化    room_list_ = room_list;    roomnum_ = 0;}// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)// ---roomnum_例外 int属于内置类型</code></pre><p>上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式</p><pre><code class="c++">A::A(const std::string &amp;name, const std::list&lt;Gameroom&gt; &amp;room_list)    :name_(name), room_list_(room_list), roomnum_(0){}</code></pre><p>虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.</p><p><strong>还可以使用成员初值列 来default构造一个成员变量.</strong></p><pre><code class="c++">A::A()    :name_(), room_list_(), roomnum_(0){ // 前两个全部调用的default构造函数}</code></pre><p><strong>const reference 内置类型(初始化与赋值等成本) 一定成员初始值列</strong></p><p><strong>初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出</strong></p><p><strong>不同编译单元内定义之 non-local static对象 的初始化 次序</strong></p><p>static对象: 析构函数会在main() 结束时被自动调用<br>local static对象: 函数内的static对象<br>non-local对象: 其他static对象</p><p>编译单元: 产出单一目标文件的那些源码, 基本是单一源码文件和他包含的头文件</p><pre><code class="c++">// filesystem.hclass FileSystem{public:    size_t GetNum() const;};extern FileSystem tfs; // 声明// filesystem.cppFileSystem tfs; //定义// directory.hclass Directory{public:    Directory(params);    }Directory::Directory(params){    size_t num = tfs.GetNum(); // 使用tfs对象}// main.cppDirectory temp_dir(params);</code></pre><p>只有当 tfs在temp_dir初始化之前被初始化 才能得到正确的结果. 否则会调用未初始化的对象</p><p>但是这个次序无法保证, tfs和tempdir是不同的人在不同的时间于不同的源码文件建立起来的<br>因为C++ 对这种情况没有明确定义</p><p>如何解决这个问题呢??<br>将每个<code>non-local static</code>对象搬到自己的专属函数内(该对象在此函数内被声明为static)<br>函数返回一个reference对象他所包含的对象<br>用户调用这个函数而不是直接调用对象</p><p>解决的原因呢?<br>C++ 保证函数内的<code>local static</code>对象 会在<code>函数被调用期间</code>, <code>首次遇到该对象的定义式</code>被初始化</p><pre><code class="c++">// filesystem.hclass FileSystem{public:    std::size_t GetNum() const;}FileSystem&amp; tfs(){    static FileSystem fs;    return fs;}// directory.hclass Directory{public:    Directory(params);    }Directory::Directory(params){    std::size_t num = tfs().GetNum(); // 使用tfs对象}Directory&amp; temp_dir(){    static Directory td;    return td;}</code></pre><h1 id="构造析构赋值运算"><a href="#构造析构赋值运算" class="headerlink" title="构造析构赋值运算"></a>构造析构赋值运算</h1><h2 id="条款0506-了解C-默认编写并调用哪些函数-并适当拒绝"><a href="#条款0506-了解C-默认编写并调用哪些函数-并适当拒绝" class="headerlink" title="条款0506 了解C++默认编写并调用哪些函数 并适当拒绝"></a>条款0506 了解C++默认编写并调用哪些函数 并适当拒绝</h2><p><strong>夹带如下私货-public-inline</strong></p><ul><li>一个构造函数(如果你没有任何构造函数)</li><li>一个拷贝构造函数</li><li>一个析构函数</li><li>一个拷贝</li></ul><p>拷贝构造函数和拷贝运算符 自动生成的只是单纯的将来源对象的每一个<code>non-static</code>成员变量<br>拷贝到目标对象</p><p><strong>遇到const 和 引用成员 默认的拷贝无法工作, 编译器会发出警告</strong></p><p><strong>将不需要的成员函数声明为private, 并且不实现</strong></p><h2 id="条款07-为多态基类声明virtual析构函数"><a href="#条款07-为多态基类声明virtual析构函数" class="headerlink" title="条款07 为多态基类声明virtual析构函数"></a>条款07 为多态基类声明virtual析构函数</h2><p>返回指向子类的 父类型指针.<br>如果delete这个指针, 在父类析构函数不是virtual的情况下, 很可能会导致<br>父类的成分被销毁, 然而子类多出来的部分不被销毁. 造成局部销毁!!</p><p><strong>防止局部销毁很简单, 将父类的析构函数声明为virtual</strong></p><p><strong>任何class 只要带有virtual函数 几乎确定应该有一个virtual析构函数</strong></p><p><strong>无端的声明virtual函数是错误的</strong></p><p>如果class不含virtual函数, 通常表示这个class 不是想做为父类, 这时如果将其析构函数声明为virual<br>是一个馊主意………….</p><p><em>class类的大小 = 成员变量占据大小 + vptr(vitual table pointer)指针大小(4~8 字节)</em></p><p>每一个带有virtual函数的class都有对应的vtbl</p><p>当对象调用某一vitual函数的时候, 实际调用的函数取决于<br>vptr(vitual table pointer)指针指向的vtbl(vitual table)</p><p>无端的使用virtual函数 会导致占用空间的增大</p><h2 id="条款08-别让异常逃离析构函数"><a href="#条款08-别让异常逃离析构函数" class="headerlink" title="条款08 别让异常逃离析构函数"></a>条款08 别让异常逃离析构函数</h2><p><strong>总结</strong></p><ul><li>析构函数绝对不要抛出异常, 如果被析构函数调用的函数可能抛出异常, 析构函数应该捕获所有异常<br>然后吞下它们, 或者结束程序</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应, class应该提供一个普通函数(而非在析构函数中)<br>执行操作</li></ul><p><strong>析构函数不要抛出异常</strong></p><pre><code class="c++">class Widget{    ...    ~Widget() {...}}void Foo(){    std::vector&lt;Widget&gt; v;}</code></pre><p>当 <code>v</code>被销毁的时候, Widget的析构函数第一次抛出异常C++还能接受?<br>第二次就会造成不明确行为</p><h2 id="条款09-绝不在构造函数和析构过程中调用virtual函数"><a href="#条款09-绝不在构造函数和析构过程中调用virtual函数" class="headerlink" title="条款09: 绝不在构造函数和析构过程中调用virtual函数"></a>条款09: 绝不在构造函数和析构过程中调用virtual函数</h2><p><strong>总结</strong></p><ul><li>在构造和析构期间不要调用virtual函数, 因为这类调用从不下降到<code>子类</code></li></ul><pre><code class="c++">class Transaction{public:    Transaction();    virtual void LogTransaction() const = 0;    ...}Transaction::Transaction(){    ...    LogTransaction();}class BuyTransaction: public Transaction{public:    virtual void LogTransaction() const;    ...}class SellTransaction: public Transaction{public:    virtual void LogTransaction() const;    ...}BuyTransaction b;</code></pre><p>BuyTransaction的构造函数会被调用, 但是父类的构造函数会更显被调用.<br>然后父类构造函数调用<code>LogTransaction()</code>的版本是<code>父类</code>的版本!!! 不是子类的版本</p><p>析构函数也是同样的道理, 当<code>子类</code>的析构函数执行后, <code>子类</code>中的属性值就成为未定义状态<br>进入<code>父类</code>后对象就成为一个<code>父类</code>对象</p><p>本例子中既然无法实现使用<code>virtual</code>函数从<code>父类</code>向下调用, 可以再构造期间, 将<br><code>子类</code>必要的构造信息向上传给<code>父类</code>的构造函数</p><h2 id="条款10-另operator-返回一个reference-to-this"><a href="#条款10-另operator-返回一个reference-to-this" class="headerlink" title="条款10: 另operator= 返回一个reference to *this"></a>条款10: 另operator= 返回一个reference to *this</h2><p>注意这只是一个协议, 并无强制性. 如果不遵守代码依然可以通过编译, 然而这份 协议被所有内置类型<br>和标准程序库提供的类型共同遵守.<br>因此除非你有一个标新立异的好理由, 不然还是随众吧</p><h2 id="条款11-在operator-中处理”自我赋值”"><a href="#条款11-在operator-中处理”自我赋值”" class="headerlink" title="条款11: 在operator= 中处理”自我赋值”"></a>条款11: 在operator= 中处理”自我赋值”</h2><p><strong>总结</strong></p><ul><li>确保当对象自我赋值时operator=有良好的的行为. 其中技术包括比较”来源对象”<br>和”目标对象”的地址, 精心周到的语句顺序, 以及copy-and-swap</li><li>确认任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象的时候, 进行仍未正确</li></ul><p><strong>自我赋值是什么</strong></p><pre><code class="c++">class Widget {...};Widget w;w=w; // 什么这个看起来不可能, 那下面呢?a[i] = a[j]; // 这个怎么样?  潜在的自我赋值*px = *py // 这个呢? 潜在的自我赋值</code></pre><p><strong>会出现的问题</strong></p><pre><code class="c++">class Gameroom{....};class Game{    ...private:    Gameroom* room_;}// operator=的实现代码Game&amp; Game::operator=(const Game&amp; ths){    delete room_;    room_ = new Gameroom(*ths.room_);    return *this;}</code></pre><p>上面的代码 如果 this和ths指向同一个对象就会造成 <code>room_</code>构造失败<br>因为被<code>delete</code>的<code>room_</code>就是要传入的</p><p>如何解决这个问题呢?<br><em>比较来源对象 整同测试</em></p><pre><code class="c++">Game&amp; Game::operator=(const Game&amp; ths){    if (this == &amp;ths)    {        return *this;    }    delete room_;    room_ = new Gameroom(*ths.room_);    return *this;}</code></pre><p>但是如果 <code>new Gameroom(*ths.room_)</code>错误, 导致room_指向不安全的内存<br>使用下面的代码, 可以导出异常安全, 以及自我赋值</p><pre><code class="c++">Game&amp; Game::operator=(const Game&amp; ths){    Gameroom* p_room = room_;    room_ = new Gameroom(*ths.room_);    delete p_room;    retutn *this;}</code></pre><p>现在如果<code>new Gameroom</code>抛出异常, room_还可以保持原状.<br>同时也能处理自我赋值</p><p><em>copy and swap</em><br>这一段描述我看完之后, 突然想到了上午看的Jsoncpp里面的代码!!!!! 就有这个<br>下面的代码更加高效 但是牺牲了清晰性</p><pre><code class="c++">class Game{    void swap(Game&amp; rhs);}Game&amp; Game::operator=(const Game&amp; ths){    Game temp(this);    swap(temp);    return *this;}</code></pre><h2 id="条款12-复制对象时勿忘其每一个成分"><a href="#条款12-复制对象时勿忘其每一个成分" class="headerlink" title="条款12: 复制对象时勿忘其每一个成分"></a>条款12: 复制对象时勿忘其每一个成分</h2><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="条款13-以对象管理资源"><a href="#条款13-以对象管理资源" class="headerlink" title="条款13: 以对象管理资源"></a>条款13: 以对象管理资源</h2><ul><li>防止资源泄露请使用RALL对象, 他们在构造函数获得资源在析构函数释放资源</li><li>较常使用的RALL classes是shared_ptr和auto_ptr(在C++17被删掉了) 建议使用前者其复制行为也比较直观</li></ul><p>使用工厂方法得到一个指向资源对象的指针, 使用这个指针操作完毕后需要delete 这个指针<br>这样这个资源对象的资源就能够被释放</p><p>但是, 这是执行了delete的情况, 如果在<code>指针返回后</code> 在<code>delete执行前</code> 发生了各种情况导致<code>delete没有被执行</code><br>发生的情况包括但不限于, 提前return, 如果位于循环中还可能是continue乃至goto, 甚至是异常抛出.<br>所以直接使用指针管理资源十分不安全.</p><p>同时我们知道 如果使用<code>资源管理对象</code>管理资源 使用资源管理对象的<code>析构函数来释放这个指向资源的指针</code><br>而且对象的<code>析构函数</code>会在资管管理对象<code>生命周期结束后自动调用</code>, 这样就能<code>自动删除资源</code>, 不用依赖手动在合适的时机delete</p><p>使用智能指针是一个非常不错的选择, 当然要注意防止别让多个智能指针指向同一个对象.</p><p>auto_ptr在C++17中被废除了, 简单了解下就好了. 书中称这是诡异的复制行为2333,<br>复加上其底层条件, 受auto_ptr管理的资源绝对没有一个以上的auto_ptr指向他</p><pre><code class="c++">// pR1指向CreateResource的返回物std::auto_ptr&lt;Resource&gt; pR1(CreateResource());// 现在pR2指向了, pR1被设置为了nullptrstd::auto_ptr&lt;Resource&gt; pR2(pR1);// 现在pR1指向了, pR2又成了nullptrpR1 = pR2;</code></pre><p>引用计数型智慧指针……</p><p><em>智能指针析构函数使用的是delete 而不是delete []</em> 所以不要将动态分配的数组保存进去</p><h2 id="条款14-在资源管理类中小心copying行为"><a href="#条款14-在资源管理类中小心copying行为" class="headerlink" title="条款14 在资源管理类中小心copying行为"></a>条款14 在资源管理类中小心copying行为</h2><p>RAII对象应该禁止复制, 或者小心的定义其移动构造函数进行内部资源的移动</p><h2 id="条款15-在资源管理类中提供对原始资源的访问"><a href="#条款15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15: 在资源管理类中提供对原始资源的访问"></a>条款15: 在资源管理类中提供对原始资源的访问</h2><p>Api往往需要访问原始资源, 所以应该提供.</p><p>如果定义隐式类型转换, 虽然使用方便但是可能会发生错误. 显式类型转换则需要额外的控制</p><h2 id="条款16-成对使用new和delete时要采取相同形式"><a href="#条款16-成对使用new和delete时要采取相同形式" class="headerlink" title="条款16: 成对使用new和delete时要采取相同形式"></a>条款16: 成对使用new和delete时要采取相同形式</h2><p>new delete</p><p>new[] delete[]</p><h2 id="条款17-以独立语句将newed对象置入智能指针"><a href="#条款17-以独立语句将newed对象置入智能指针" class="headerlink" title="条款17: 以独立语句将newed对象置入智能指针"></a>条款17: 以独立语句将newed对象置入智能指针</h2><pre><code class="c++">GetB();void Foo(std::shared_ptr&lt;Foo&gt; foo_ptr, B b);Foo(std::shared_ptr&lt;Foo&gt;(new Foo), GetB());</code></pre><p>第三条语句分为三步</p><ol><li>调用GetB()</li><li>new Foo</li><li>调用shared_ptr的构造函数</li></ol><p>由于C++如下的执行顺序并不确定 可能会造成 213的执行顺序</p><p>如果此时GetB()发生错误将会导致new出的对象 没有被智能指针管理</p><h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="条款18-让接口容易被使用-不易被误用"><a href="#条款18-让接口容易被使用-不易被误用" class="headerlink" title="条款18: 让接口容易被使用, 不易被误用"></a>条款18: 让接口容易被使用, 不易被误用</h2><h2 id="条款19-设计class犹如设计type"><a href="#条款19-设计class犹如设计type" class="headerlink" title="条款19: 设计class犹如设计type"></a>条款19: 设计class犹如设计type</h2><p>如何设计高效的classes呢?</p><ul><li>新class的对象该如何被创建和销毁? 这会影响到构造析构函数内存分配释放函数</li><li>对象的初始化和对象的赋值有什么样的差别? 决定构造函数和赋值运算符的行为.<br>搞清初始化和赋值</li><li>注意class对象被值传递 拷贝构造函数会被调用用来生成临时对象</li><li>什么是新class的合法值? <code>setter</code>函数需要进行的范围检查</li><li>你的新class需要配合某个继承图系吗?</li><li>你的新class需要什么样的转换? 如果需要类型转换需要在class中编写<code>类型转换函数</code></li><li>什么样的操作运算符和函数对此class而言是合理的? 决定你为class声明哪些函数(条款 23 24 46)</li><li>将需要驳回的标准函数设置为private</li><li>你的新type有多么一般化? 或许应该定义一整个class家族. 也许模板能帮你</li></ul><h2 id="条款20-const-引用-替换掉-值传递"><a href="#条款20-const-引用-替换掉-值传递" class="headerlink" title="条款20: const 引用 替换掉 值传递"></a>条款20: const 引用 替换掉 值传递</h2><p>值传递会造成大量额外的构造析构被调用</p><p>通过引用传递还能避免对象切割问题. 当一个子类通过值传递并被视为一个基类的时候<br>子类的特性全部丢失</p><p>对于内置类型而言 值传递 比 引用传递 更加高效</p><h2 id="条款21-必须返回对象的时候-别妄想返回其引用"><a href="#条款21-必须返回对象的时候-别妄想返回其引用" class="headerlink" title="条款21: 必须返回对象的时候, 别妄想返回其引用"></a>条款21: 必须返回对象的时候, 别妄想返回其引用</h2><p>local对象如果被从函数 引用返回 函数结束的时候对象就被销毁 造成未定义行为</p><p>如果通过 * 返回一个堆对象 的引用 将会造成诸如内存泄漏等问题</p><h2 id="条款22-将成员变量声明为private"><a href="#条款22-将成员变量声明为private" class="headerlink" title="条款22: 将成员变量声明为private"></a>条款22: 将成员变量声明为private</h2><p>成员变量声明为private提供GetSet方法, 看似麻烦… 实则确实麻烦=, =<br>不过麻烦的相对面就是他的好处</p><p>首先就是提供了封装, 一旦你更改了内如的成员变量的实现等, 你只需要改动GetSet方法, 外部浑然不知.<br>如果你声明为了public, 那么你有极大的可能需要修改每一处直接从外部使用成员的代码.</p><p>之外你还可以将进行参数校验, 等等保护.</p><h2 id="条款23-宁以non-member-non-friend替换member函数"><a href="#条款23-宁以non-member-non-friend替换member函数" class="headerlink" title="条款23: 宁以non-member, non-friend替换member函数"></a>条款23: 宁以non-member, non-friend替换member函数</h2><pre><code class="c++">class A{    DoA();    DoB();    DoC();}</code></pre><p>现在你需要提供一个函数 <code>DoD()</code>实现上面三个函数的功能<br>你有两个选择</p><ol><li>增加一个新的成员函数<code>DoD()</code>内部调用三个函数</li><li>增加一个普通函数, 增加<code>A&amp; a</code>参数调用内部的三个函数</li></ol><p>方法2可以增加其封装性和包裹弹性以及机能扩充性</p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux高性能服务器-进程线程</title>
      <link href="/2020/02/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95102-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86/"/>
      <url>/2020/02/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95102-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第十三章多进程编程"><a href="#第十三章多进程编程" class="headerlink" title="第十三章多进程编程"></a>第十三章多进程编程</h1><h2 id="exec系列系统调用"><a href="#exec系列系统调用" class="headerlink" title="exec系列系统调用"></a>exec系列系统调用</h2><pre><code class="c++">#include &lt;unistd.h&gt;// 声明这个是外部函数或外部变量extern char** environ;// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻// arg-接受可变参数 和 argv用于向新的程序传递参数数组// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量// exec函数是不返回的, 除非出错// 如果未报错则源程序被新的程序完全替换int execl(const char* path, const char* arg, ...);int execlp(const char* file, const char* arg, ...);int execle(const char* path, const char* arg, ..., char* const envp[])int execv(const char* path, char* const argv[]);int execvp(const char* file, char* const argv[]);int execve(const char* path, char* const argv[], char* const envp[]);</code></pre><h2 id="fork系统调用-进程的创建"><a href="#fork系统调用-进程的创建" class="headerlink" title="fork系统调用-进程的创建"></a>fork系统调用-进程的创建</h2><pre><code class="c++">#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0// 次返回值用于区分是父进程还是子进程// 失败返回-1pid_t fork(viod);</code></pre><p>fork系统调用<br>fork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项<br>新的进程表项有很多的属性和原进程相同</p><ul><li>堆指针</li><li>栈指针</li><li>标志寄存器的值</li><li>子进程代码与父进程完全相同</li><li>同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据)</li><li>创建子进程后, <em>父进程打开的文件描述符默认在子进程中也是打开的</em> <code>文件描述符的引用计数</code>, <code>父进程的用户根目录, 当前工作目录等变量的引用计数</code> 均加1</li></ul><p>也存在不同的项目</p><ul><li>该进程的PPID(标识父进程)被设置成原进程的PID,  </li><li><code>信号位图被清除</code>(原进程设置的信号处理函数对新进程无效)</li></ul><p>(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)</p><p>The child process is an exact duplicate of the parent process except<br>for the following points:</p><ul><li><p>The child has its own unique process ID, and this PID does not<br> match the ID of any existing process group (setpgid(2)) or<br> session. 子进程拥有自己唯一的进程ID, 不与其他相同</p></li><li><p>The child’s parent process ID is the same as the parent’s process<br> ID. 子进程的父进程ID PPID 与父进程ID PID相同</p></li><li><p>The child does not inherit its parent’s memory locks (mlock(2),<br> mlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区)</p></li><li><p>Process resource utilizations (getrusage(2)) and CPU time counters<br> (times(2)) are reset to zero in the child.<br> 进程资源使用和CPU时间计数器在子进程中重置为0</p></li><li><p>The child’s set of pending signals is initially empty<br> (sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置</p></li><li><p>The child does not inherit semaphore adjustments from its parent<br> (semop(2)). 不会继承semadj</p></li><li><p>The child does not inherit process-associated record locks from<br> its parent (fcntl(2)).  (On the other hand, it does inherit<br> fcntl(2) open file description locks and flock(2) locks from its<br> parent.)</p></li><li><p>The child does not inherit timers from its parent (setitimer(2),<br> alarm(2), timer_create(2)). 不会继承定时器</p></li><li><p>The child does not inherit outstanding asynchronous I/O operations<br> from its parent (aio_read(3), aio_write(3)), nor does it inherit<br> any asynchronous I/O contexts from its parent (see io_setup(2)).</p></li></ul><h2 id="处理僵尸进程-进程的管理"><a href="#处理僵尸进程-进程的管理" class="headerlink" title="处理僵尸进程-进程的管理"></a>处理僵尸进程-进程的管理</h2><pre><code class="c++">#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.pid_t wait(int* stat_loc);// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)// options函数取值WNOHANG-waitpid立即返回// 如果目标子进程正常退出, 则返回子进程的pid// 如果还没有结束或意外终止, 则立即返回0// 调用失败返回-1pid_t waitpid(pid_t pid, int* stat_loc, int options);WIFEXITED(stat_val); // 子进程正常结束, 返回一个非0WEXITSTATUS(stat_val); // 如果WIFEXITED 非0, 它返回子进程的退出码WIFSIGNALED(stat_val);// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值WTERMSIG(stat_val);// 如果WIFSIGNALED非0 返回一个信号值WIFSTOPPED(stat_val);// 如果子进程意外终止, 它返回一个非0值WSTOPSIG(stat_val);// 如果WIFSTOPED非0, 它返回一个信号值</code></pre><p>对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询</p><ul><li>在<code>子进程结束运行之后, 父进程读取其退出状态前</code>, 我们称该子进程处于<code>僵尸态</code></li><li>另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) <code>父进程结束运行之后, 子进程退出之前</code>, 处于<code>僵尸态</code></li></ul><p>以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.</p><p>waitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.<br>SIGCHLD信号- 子进程结束后将会给父进程发送此信号</p><pre><code class="c++">static void handle_child(int sig){    pid_t pid;    int stat;    while ((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0)    {        // 善后处理emmmm    }}</code></pre><h2 id="信号量-进程的锁"><a href="#信号量-进程的锁" class="headerlink" title="信号量-进程的锁"></a>信号量-进程的锁</h2><p><em>信号量原语</em><br>只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.<br>假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为</p><ul><li>P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行</li><li>V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png" alt=""></li></ul><p><strong>总结PV使用方法</strong></p><p>使用<code>semget</code>获取到唯一的标识.<br>使用<code>semctl</code>的<code>SETVAL</code>传入初始化val的<code>sem_un</code>联合体.来初始化val<br>调用<code>semop</code> 传入唯一标识, <code>sem_op=-1</code>执行P(锁)操作<code>sem_op=1</code>执行V(开锁)操作<br>开关锁通过当<code>sem_op=-1,semval=0</code><br>且未指定<code>IPC_NOWAIT</code><br>等待<code>semval</code>被<code>sem_op=1</code>改为<code>semval=1</code></p><p><strong>创建信号量</strong></p><pre><code class="c++">// semeget 系统调用// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1// sem_flags指定一组标志, 来控制权限// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1int semget(key_t key, int num_sems, int sem_flags);int sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT);</code></pre><p><strong>初始化</strong></p><pre><code class="c++">// semctl 系统调用// sem_id 参数是由semget返回的信号量集标识符// sen_num指定被操作的信号量在信号集中的编号// command指定命令, 可以追加命令所需的参数, 不过有推荐格式// 成功返回对应command的参数, 失败返回-1 errnoint semctl(int sem_id, int sem_num, int command, ...);// 第四个参数 竟然需要手动声明...union semun{    int              val;    /* Value for SETVAL */    struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */    unsigned short  *array;  /* Array for GETALL, SETALL */    struct seminfo  *__buf;  /* Buffer for IPC_INFO                                (Linux-specific) */};// 初始化信号量union semun sem_union;sem_union.val = 1;// 这里可以直接第三个参数传入1(val)if (semctl(sem_id, 0, SETVAL, sem_union) == -1){    exit(0);}// 删除信号量union semun sem_union{};if (semctl(sem_id, 0, IPC_RMID, sem_union) == -1){    exit(EXIT_FAILURE);}</code></pre><hr><p>与semop信号量关联的一些重要的内核变量</p><pre><code class="c++">unsigned short semval; // 信号量的值unsigned short semzcnt; // 等待信号量值变为0的进程数量unsigned short semncnt// 等待信号量值增加的进程数量pid_t sempid; // 最后一次执行semop操作的进程ID</code></pre><p>操作信号量, 实际上就是对上面的内核变量操作</p><pre><code class="c++">// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.// sem_ops 参数指向一个sembuf结构体类型的数组// num_sem_ops 说明操作数组中哪个信号量// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行int semop(int sem_id, struct sembuf* sem_ops, size_t num_sem_ops);// sem_op &lt; 0 期望获得信号量// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量// 如果semval &lt; abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒// 1 发生semval &gt;= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)bool P(int sem_id){    struct sembuf sem_b;    sem_b.sem_num = 0; // 信号量编号 第几个信号量 一般都是第0个    sem_b.sem_op = -1; // P    // IPC_NOWAIT 无论信号量操作是否成功, 都立即返回    // SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量    sem_b.sem_flg = SEM_UNDO;    return semop(sem_id, &amp;sem_b, 1) != -1;}// sem_op &gt; 0 // semval+=sem_op , 要求调用进程对被操作的信号量集有写权限// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)bool V(int sem_id){    struct sembuf sem_b;    sem_b.sem_num = 0;    sem_b.sem_op = 1; // V    sem_b.sem_flg = SEM_UNDO;    return semop(sem_id, &amp;sem_b, 1) != -1;}// -- sem_op = 0// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1</code></pre><p>semget成功时返回一个与之关联的内核结构体semid_ds</p><pre><code class="c++">struct semid_ds{    struct ipc_perm sem_perm;    unsigned long int sem_nsems; // 被设置为num_sems    time_t sem_otime; // 被设置为0    time_t sem_ctime; // 被设置为当前的系统时间}// 用来描述权限struct ipc_perm{    uid_t uid; // 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID    gid_t gid; // 所有者的有效组ID, 被semget设置为调用进程的有效用户ID    uid_t cuid; // 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID    gid_t cgid; // 创建者的有效组ID, 被semget设置为调用进程的有效用户ID    mode_t mode;// 访问权限, 背着只为sem_flags参数的最低9位.}</code></pre><h2 id="共享内存-进程间通信"><a href="#共享内存-进程间通信" class="headerlink" title="共享内存-进程间通信"></a>共享内存-进程间通信</h2><p><strong>最高效的IPC(进程间通信)机制</strong><br>需要自己同步进程对其的访问, 否则会产生竞态条件</p><pre><code class="c++">// key// 与semget相同 标识一段全局唯一的共享内存// size 内存区域大小 单位字节// shmflg// IPC_CREAT 存不存在都创建新的共享内存// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错// SHM_HUGETLB 系统将使用&quot;大页面&quot;来为共享内存分配空间// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足// -在执行写操作的时候将会触发`SIGSEGV`信号// -成功返回唯一标识, 失败返回-1 errnoint shmget(key_t key, size_t size, int shmflg)</code></pre><pre><code class="c++">// shm_id // shmget返回的唯一标识// shm_addr // 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*// shmflg// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联// SHM_EXEC 有执行权限// 成功返回关联到的地址, 失败返回 (void*)-1 errnovoid* shmat(int shm_id, const void* shm_addr, int shmflg)// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容// -shm_nattach +1// -更新 shm_lpid// -shm_atime设置为当前时间</code></pre><pre><code class="c++">// 将共享内存从进程地址空间中分离// 成功后// -shm_nattach -1// -更新 shm_lpid和shm_dtime设置为当前时间// 成功返回0 失败返回-1 errnoint shmdt(const void* shm_addr)</code></pre><pre><code class="c++">int shm_ctl(int shm_id, int command, struct shmid_ds* buf)</code></pre><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png" alt=""></p><hr><p>shmget 同时会创建对应的<code>shmid_ds</code>结构体</p><pre><code class="c++">struct shmid_ds{    struct ipc_perm shm_per; // 权限相关    size_t shm_segsz; // 共享内存大小 单位字节    size    __time_t shm_atime; // 对这段内存最后一次调用semat的时间 0    __time_t shm_dtime; // 对这段内存最后一次调用semdt的时间 0    __time_t shm_ctime; // 对这段内存最后一次调用semctl的时间 当前时间    __pid_t shm_cpid; // 创建者PID    __pid_t lpid; // 最后一次执行shmat或shmdt的进程PID    shmatt_t shm_nattach // 关联到此共享内存空间的进程数量}</code></pre><p><strong>共享内存的POSIX方法</strong></p><pre><code class="c++">int shmfd = shm_open(&quot;/shm_name&quot;, O_CREAT | O_RDWR, 0666);ERROR_IF(shmfd == -1, &quot;shm open&quot;);int ret = ftruncate(shmfd, BUFFER_SIZE);ERROR_IF(ret == -1, &quot;ftruncate&quot;);share_mem = (char*)mmap(nullptr, BUFFER_SIZE,        PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);ERROR_IF(share_mem == MAP_FAILED, &quot;share_mem&quot;);close(shmfd);// 取消关联munmap((void*)share_mem, BUFFER_SIZE);</code></pre><h2 id="进程通信-管道"><a href="#进程通信-管道" class="headerlink" title="进程通信-管道"></a>进程通信-管道</h2><p>管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证<br>父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].</p><p>可以用两个管道来实现双向传输数据, 也可以用<code>socketpair</code>来创建管道</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.<br>每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据</p><pre><code class="c++">#include &lt;sys/msg.h&gt;// 与semget 相同, 成功返回标识符// msgflg的设置和作用域setget相同int msgget(key_t key, int msgflg);</code></pre><pre><code class="c++">// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义// msg_sz 指的是mtext的长度!!!// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT就立即返回 设置errno=EAGIN系统自带这个结构体 不过mtext长度是1...struct msgbuf{    long mtype; /* 消息类型 正整数*/    char mtext[512]; /* 消息数据*/}</code></pre><pre><code class="c++">// msgtype = 0 读取消息队列第一个消息// msgtype &gt; 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT// msgtype &lt; 0 读取第一个 类型值 &lt; abs(msgtype)的消息// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态</code></pre><pre><code class="c++">int msgctl(int msqid, int command, struct msqid_ds *buf);IPC_STAT 复制消息队列关联的数据结构IPC_SET 将buf中的部分成员更新到目标的内核数据IPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程IPC_INFO 获取系统消息队列资源配置信息MSG_INFO 返回已经分配的消息队列所占用资源信息MSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引</code></pre><h2 id="在进程间传递文件描述符"><a href="#在进程间传递文件描述符" class="headerlink" title="在进程间传递文件描述符"></a>在进程间传递文件描述符</h2><h2 id="IPC命令-查看进程间通信的全局唯一key"><a href="#IPC命令-查看进程间通信的全局唯一key" class="headerlink" title="IPC命令-查看进程间通信的全局唯一key"></a>IPC命令-查看进程间通信的全局唯一key</h2><h1 id="第十四章-多线程编程"><a href="#第十四章-多线程编程" class="headerlink" title="第十四章 多线程编程"></a>第十四章 多线程编程</h1><p>根据运行环境和调度者身份, 线程可以分为两种<br>内核线程<br>运行在内核空间, 由内核来调度.<br>用户线程<br>运行在用空间, 由线程库来调用</p><p>当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.</p><p>线程有三种实现方式</p><ul><li>完全在用户空间实现-无需内核支持<br>  创建和调度线程无需内核干预, 速度很快.<br>  不占用额外的内核资源, 对系统影响较小<br>  但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的</li><li>完全由内核调度<br>  创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理<br>  优缺点正好与上一个相反</li><li>双层调度<br>  结合了前两个的优点<br>  不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势</li></ul><h2 id="进程的创建和终止"><a href="#进程的创建和终止" class="headerlink" title="进程的创建和终止"></a>进程的创建和终止</h2><pre><code class="c++">#include &lt;pthread.h&gt;int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg);// 成功返回0 失败返回错误码// thread 用来唯一的标识一个新线程// attr用来设置新县城的属性 传递NULL表示默认线程属性// start_routine 指定新线程运行的函数// arg指定函数的参数</code></pre><pre><code class="c++">void pthread_exit(void* retval);用来保证线程安全干净的退出, 线程函数最好结束时调用.通过`retval`参数向线程的回收者传递其退出信息执行后不会返回到调用者, 而且永远不会失败int pthread_join(pthread_t thread, void** retval)可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.成功时返回0, 失败返回错误码等待其他线程结束thread 线程标识符retval 目标线程的退出返回信息错误码如下`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程`ESRCH`目标线程不存在int pthread_cancel(pthread_t thread)异常终止一个线程, 即为取消线程成功返回0, 失败返回错误码</code></pre><p><strong>线程属性设置</strong></p><pre><code class="c++">接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.// 启动线程取消int pthread_setcancelstart(int state, int* oldstate)第一个参数PTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态PTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求直到这个线程允许被取消第二个参数 返回之前设定的状态// 设置线程取消类型int pthread_setcanceltype(int type, int* oldtype)第一个参数PTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消PTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 直到调用了下面几个所谓的取消点函数最好使用pthread_testcancel函数设置取消点设置取消类型(如何取消)第二个参数原来的取消类型</code></pre><p><strong>设置脱离线程</strong></p><pre><code class="c++">// 初始化线程属性对象int pthread_attr_init(pthread_attr_t *attr);// 销毁线程属性对象, 直到再次初始化前都不能用int pthread_attr_destory(pthread_attr_t *attr)// 参数取值// -PTHREAD_CREATE_JOINABLE 线程可回收// -PTHREAD_CREATE_DETACH 脱离与进程中其他线程的同步 成为脱离线程int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);// 可以直接设置为脱离线程int pthread_detach(pthread_t thread)</code></pre><h2 id="线程同步机制的使用场景"><a href="#线程同步机制的使用场景" class="headerlink" title="线程同步机制的使用场景"></a>线程同步机制的使用场景</h2><p>POSIX信号量-需要自己维护计数值, 用户空间有计数值 信号量自己又计数值<br>两份计数值容易出错</p><p>互斥锁-对临界资源的独占式访问</p><p>条件变量-等待某个条件满足<br>当某个共享数据达到某个值的时候, 唤醒等待这个共享数据的线程</p><p>读写锁-可以多个进程读, 读的时候不能写, 同时只能一个写</p><p>自旋锁-通过while循环频繁尝试获取锁, 适用于锁事件短, 需要快速切换的场景</p><h2 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h2><p>多线程也必须考虑线程同步的问题.<br>虽然<code>pthread_join()</code>可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求<br>比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.</p><pre><code class="c++">#include&lt;semaphore&gt;// 用于初始化一个未命名的信号量.// pshared==0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享// value指定参数的初始值int sem_init(sem_t* sem, int pshared, unsigned int value)// 销毁信号量, 释放其占用的系统资源int sem_destory(sem_t* sem)// 以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞直到sem_wait具有非0值int sem_wait(sem_t* sem)// 跟上面的函数相同不过不会阻塞. 信号量不为0则减一操作, 为0则返回-1 errnoint sem_trywait(sem_t* sem)// 原子操作将信号量的值 +1int sem_post(sem_t* sem)</code></pre><p>初始化已经存在的信号量会导致无法预期的结果</p><p>销毁正被其他线程等待的信号量, 将会导致无法预期的结果</p><p>例子如下</p><pre><code class="c++">constexpr int kNumberMax = 10;std::vector&lt;int&gt; number(kNumberMax);constexpr int kThreadNum = 10;sem_t sems[kThreadNum];pthread_t threads[kThreadNum];constexpr int kPrintTime = 1;void* t(void *no){    int start_sub = *static_cast&lt;int*&gt;(no);    int sub =start_sub;    int time = 0;    while(++time &lt;= kPrintTime)    {        // 锁住本线程 释放下一个线程        sem_wait(&amp;sems[start_sub]);        printf(&quot;%d\n&quot;, number[sub]);        sem_post(&amp;sems[(start_sub + 1) % kThreadNum]);        // 计算下一次要打印的下标        sub = (sub + kThreadNum) % kNumberMax;    }    pthread_exit(nullptr);}int main(){    std::iota(number.begin(), number.end(), 0);    sem_init(&amp;sems[0], 0, 1);    for (int i = 1; i &lt; kThreadNum; ++i)    {        sem_init(&amp;sems[i], 0, 0);    }    for (int i = 0; i &lt; kThreadNum; ++i)    {        pthread_create(&amp;threads[i], nullptr, t, &amp;number[i]);    }    // 等待最后一个线程结束    pthread_join(threads[kThreadNum - 1], nullptr);}</code></pre><p>kThreadNum个进程依次打印<code>[0, kNumberMax)</code><br>每个进程打印kPrintTime次<br>最后一个进程打印完后主线程才能结束</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><pre><code class="c++">// 初始化互斥锁// 第一个参数指向目标互斥锁, 第二个参数指定属性 nullptr则为默认int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);// 销毁目标互斥锁int pthread_mutex_destory(pthread_mutex_t *mutex);// 针对普通锁加锁int pthread_mutex_lock(pthread_mutex_t *mutex);// 针对普通锁立即返回 目标未加锁则加锁 如果已经加锁则返回错误码EBUSYint pthread_mutex_trylock(pthread_mutex_t *mutex);// 解锁 如果有其他线程在等待这个互斥锁, 则其中之一获得int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></pre><p>销毁一个已经加锁的互斥锁 会发生不可预期的后果<br>也可使使用宏<code>PTHREAD_MUTEX_INITIALIZER</code>来初始化一个互斥锁<br>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</p><p><strong>互斥锁属性设置</strong></p><pre><code class="c++">int pthread_mutexattr_init(pthread_mutexattr_t *attr);int pthread_mutexattr_destory(pthread_mutexattr_t *attr);// PTHREAD_PROCESS_SHARED 跨进程共享// PTHREAD_PROCESS_PRIVATE 隶属同一进程的线程int pthread_mutexattr_getpshared(const pthread_mutexattr_t *attr, int *pshared);int pthread_mutexattr_setpshared(const pthread_mutexattr_t *attr, int pshared);// PTHREAD_MUTEX_NORMAL 普通锁 默认类型// PTHREAD_MUTEX_ERRORCHECK 检错锁// PTHREAD_MUTEX_RECURSVE 嵌套锁// PTHREAD_MUTEX_DEFAULT 默认锁int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *type);int pthread_mutexattr_settype(const pthread_mutexattr_t *attr, int type);</code></pre><p>PTHREAD_MUTEX_NORMAL<br>一个线程对其加锁后, 其他请求该锁的进程会形成一个等待队列, 解锁后然后按照优先级获得. 保证资源分配公平<br>A线程对一个<code>已经加锁</code>的普通锁<code>再次加锁(也是A线程)</code>-同一线程在解锁前再次加锁引发死锁<br>对一个已经<code>被其他线程加锁</code>的普通锁<code>解锁</code>, 或者<code>再次解锁已经解锁</code>的普通锁–解锁-不可预期后果</p><p>PTHREAD_MUTEX_ERRORCHECK<br>线程对<code>已经加锁</code>的检错锁<code>再次加锁</code>–加锁-加锁操作返回EDEADLK<br>对一个已经<code>被其他线程加锁</code>的检错锁<code>解锁</code>, 或者<code>再次解锁已经解锁</code>的检错锁–解锁-返回EPERM</p><p>PTHREAD_MUTEX_RECURSVE<br>允许一个线程在释放锁前多次加锁 而不发生死锁.<br>如果<code>其他线程</code>要获得这个锁, 则<code>当前锁拥有者</code>必须执行相应次数的解锁操作–加锁<br>对于<code>已经被其他进程</code>加锁的嵌套锁解锁, 或者对<code>已经解锁</code>的再次解锁–解锁-返回EPERM</p><p>PTHREAD_MUTEX_DEFAULT<br>这种锁的实现可能为上面三种之一<br>对已经加锁的默认锁再次加锁<br>对被其他线程加锁的默认锁解锁<br>再次解锁已经解锁的默认锁<br>都将会发生不可预料后果</p><p>例子</p><pre><code class="c++">pthread_mutex_t mutex;int count = 0;void* t(void *a){    pthread_mutex_lock(&amp;mutex);    printf(&quot;%d\n&quot;, count);    count++;    pthread_mutex_unlock(&amp;mutex);}int main(){    pthread_mutex_init(&amp;mutex, nullptr);    pthread_t thread[10];    for (int i = 0; i &lt; 10; ++i)    {        pthread_create(&amp;thread[i], nullptr, t, nullptr);    }    sleep(3);    pthread_mutex_destroy(&amp;mutex);}</code></pre><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><pre><code class="c++">int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr *cond_attr);// 销毁一个正在被等待的条件变量 将会失败并返回EBUSYint pthread_cont_destory(pthread_cond_t *cond);// 广播式的唤醒所有等待目标条件变量的线程int pthread_cont_broadcast(pthread_cond_t *cond);// 唤醒一个等待目标条件变量的线程int pthread_cond_signal(pthread_cond_t *cond);// 等待目标条件变量int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);</code></pre><p>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;<br>将各个字段初始化为0</p><p>pthread_cond_wait的第二个参数, 用于保护条件变量的互斥锁<br>掉用函数前必须将 mutex加锁, 否则会发生不可预料的后果.<br>函数执行前将调用线程放入条件变量等待队列, 然后将mutex解锁</p><p>从函数调用, 到被放入等待队列的时间内, pthread_cond_signal(broadcast)不会修改条件变量的值<br>也就是 pthread_cond_wait函数不会错过目标条件变量的任何变化,<br>将pthread_cond_wait函数返回的时候, 互斥锁mutex将会再次锁上</p><p>例子</p><pre><code class="c++">pthread_mutex_t mutex;pthread_cond_t cond;int good = 3;int produce_count = 0;int consume_count = 0;void* Producer(void *arg){    while(produce_count &lt; 10)    {        pthread_mutex_lock(&amp;mutex);        good++;        pthread_mutex_unlock(&amp;mutex);        produce_count++;        printf(&quot;produce a good\n&quot;);        // 通知一个线程        pthread_cond_signal(&amp;cond);        sleep(2);    }    pthread_exit(nullptr);}void* Consumer(void *arg){    while (consume_count &lt; 13)    {        // 传入前需要加锁        pthread_mutex_lock(&amp;mutex);        if (good &gt; 0)        {            good--;            consume_count++;            printf(&quot;consume a good, reset %d\n&quot;, good);        }        else        {            printf(&quot;good is 0\n&quot;);            // wait pthread_cond_signal            pthread_cond_wait(&amp;cond, &amp;mutex);        }        pthread_mutex_unlock(&amp;mutex);        usleep(500 * 1000);    }    pthread_exit(nullptr);}int main(){    mutex = PTHREAD_MUTEX_INITIALIZER;    cond = PTHREAD_COND_INITIALIZER;    pthread_t producer, consumer;    pthread_create(&amp;consumer, nullptr, Consumer, nullptr);    pthread_create(&amp;producer, nullptr, Producer, nullptr);    pthread_join(consumer, nullptr);    pthread_mutex_destroy(&amp;mutex);    pthread_cond_destroy(&amp;cond);}</code></pre><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h2 id="线程同步包装类-多线程环境"><a href="#线程同步包装类-多线程环境" class="headerlink" title="线程同步包装类-多线程环境"></a>线程同步包装类-多线程环境</h2><pre><code class="c++">class Sem{public:    Sem()    {        if (sem_init(&amp;sem_, 0, 0) != 0)        {            throw std::exception();        }    }    ~Sem()    {        sem_destroy(&amp;sem_);    }    bool Wait()    {        return sem_wait(&amp;sem_) == 0;    }    bool Post()    {        return sem_post(&amp;sem_) == 0;    }private:    sem_t sem_;};class Mutex{public:    Mutex()    {        if (pthread_mutex_init(&amp;mutex_, nullptr) != 0)        {            throw std::exception();        }    }    ~Mutex()    {        pthread_mutex_destroy(&amp;mutex_);    }    bool Lock()    {        return pthread_mutex_lock(&amp;mutex_) == 0;    }    bool Unlock()    {        return pthread_mutex_unlock(&amp;mutex_) == 0;    }private:    pthread_mutex_t mutex_;};class Cond{public:    Cond()    {        if (pthread_mutex_init(&amp;mutex_, nullptr) != 0)        {            throw std::exception();        }        if (pthread_cond_init(&amp;cond_, nullptr) != 0)        {            // 这里我一开始没有想到..            pthread_mutex_destroy(&amp;mutex_);            throw std::exception();        }    }    ~Cond()    {        pthread_mutex_destroy(&amp;mutex_);        pthread_cond_destroy(&amp;cond_);    };    bool Wait()    {        int ret = 0;        pthread_mutex_lock(&amp;mutex_);        ret = pthread_cond_wait(&amp;cond_, &amp;mutex_);        pthread_mutex_unlock(&amp;mutex_);        return ret == 0;    }    bool Signal()    {        return pthread_cond_signal(&amp;cond_) == 0;    }private:    pthread_cond_t cond_;    pthread_mutex_t mutex_;};</code></pre><p>线程安全或可重入函数–函数能被多个线程同时调用而不发生竞态条件</p><p>多线程程序某个线程调用fork函数, 新进程不会与父进程有相同数量的线程<br>子进程只有一个线程-调用fork线程的完美复制</p><p>但是子进程会继承父进程的互斥锁(条件变量)的状态, 如果互斥锁被加锁了, 但<code>不是由</code>调用fork线程<br>锁住的, 此时<code>子进程</code>再次对这个互斥锁<code>执行加锁</code>操作将会<code>死锁</code>.</p><pre><code class="c++">pthread_mutex_t mutex;void* another(void *arg){    printf(&quot;in child thread, lock the mutex\n&quot;);    pthread_mutex_lock(&amp;mutex);    sleep(5);    // 解锁后 Prepare才能加锁    pthread_mutex_unlock(&amp;mutex);    pthread_exit(nullptr);}// 这个函数在fork创建子进程前被调用void Prepare(){    // 但是会阻塞 直到执行another函数的线程解锁 才能够继续执行    // 这个函数执行完毕前fork不会创建子进程    pthread_mutex_lock(&amp;mutex);}// fork创建线程后 返回前 会在子进程和父进程中执行这个函数void Infork(){    pthread_mutex_unlock(&amp;mutex);}int main(){    pthread_mutex_init(&amp;mutex, nullptr);    pthread_t id;    pthread_create(&amp;id, nullptr, another, nullptr);    sleep(1);    // pthread_atfork(Prepare, Infork, Infork);    int pid = fork();    if (pid &lt; 0)    {        printf(&quot;emmm????\n&quot;);        pthread_join(id, nullptr);        pthread_mutex_destroy(&amp;mutex);        return 1;    }    else if (pid == 0)    {        printf(&quot;child process, want to get the lock\n&quot;);        pthread_mutex_lock(&amp;mutex);        printf(&quot;i cann&#39;t run to here, opps....\n&quot;);        pthread_mutex_unlock(&amp;mutex);        exit(0);    }    else    {        printf(&quot;wait start\n&quot;);        wait(nullptr);        printf(&quot;wait over\n&quot;); // 没有打印 因为子进程不会终止    }    pthread_join(id, nullptr);    pthread_mutex_destroy(&amp;mutex);    return 0;}// $ in child thread, lock the mutex// $ wait start// $ child process, want to get the lock// $ in child thread, lock the mutex// $ wait start// $ child process, want to get the lock// $ i cann&#39;t run to here, opps....// $ wait over</code></pre><p>原版就会发生死锁, 新版(去掉注释的代码) 能够正常运行</p><pre><code class="c++">int pthread_atfork (void (*__prepare) (void),               void (*__parent) (void),               void (*__child) (void));</code></pre><p>第一个句柄 在fork创建子进程前执行<br>第二个句柄 在fork创建出子进程后, fork返回前在父进程中执行<br>第二个句柄 在fork创建出子进程后, fork返回前在子进程中执行</p><h1 id="第十五章-进程池和线程池"><a href="#第十五章-进程池和线程池" class="headerlink" title="第十五章 进程池和线程池"></a>第十五章 进程池和线程池</h1><h1 id="线程池-和-简单HTTP服务器"><a href="#线程池-和-简单HTTP服务器" class="headerlink" title="线程池 和 简单HTTP服务器"></a>线程池 和 简单HTTP服务器</h1><p>对我而言神秘已久的线程池终于揭开了面纱.<br>没想到这就是线程池23333</p><p>线程池写完后 直接写了书上的HTTP服务器.</p><p>那个服务器至少我发现两个问题</p><ul><li>无法发送大文件</li><li>部分请求无法回复</li></ul><p>无法发送大文件, 是因为书中使用了writev发送数据<br>期初我以为下面的判断 writev返回值 等于 -1就是为了发送大文件, 后来发现这个判断只是给期初就发送失败准备的.</p><p>正好前一阵子看了一个服务器的代码<br><a href="https://github.com/Jigokubana/Notes-flamingo" target="_blank" rel="noopener">https://github.com/Jigokubana/Notes-flamingo</a></p><p>我就索性直接将发送部分修改了</p><pre><code class="c++">// write_sum_ 需发送总大小// write_idx_ 已发送大小int temp = 0;if (write_sum_ - write_idx_ == 0){    Modfd(epollfd_, sockfd_, EPOLLIN);    Init();    return true;}while (true){    temp = send(sockfd_, &amp;*write_buff_.begin() + write_idx_, write_sum_ - write_idx_, 0);    if (temp &lt;= -1)    {        if (errno == EAGAIN)        {            Modfd(epollfd_, sockfd_, EPOLLOUT);            return true;        }    }    write_idx_ += temp;    if (write_idx_ == write_sum_)    {        // 解除绑定移到了其他地方        if (linger_)        {            Init();            Modfd(epollfd_, sockfd_, EPOLLIN);            return true;        }        else        {            Modfd(epollfd_, sockfd_, EPOLLIN);            return false;        }    }}</code></pre><p>第二个奇葩的问题就是使用ab压测时候 有些请求无法收到回复.<br>这个问题等后面在解决把, 等我知识更加丰富了再说</p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPP11及以后的常用特性</title>
      <link href="/2020/02/CPP-CPP%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/02/CPP-CPP%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>参考资料<br><a href="https://zh.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/lambda</a><br><a href="https://blog.csdn.net/qq_34199383/article/details/80469780" target="_blank" rel="noopener">https://blog.csdn.net/qq_34199383/article/details/80469780</a></p><pre><code class="c++">[ 捕获 ] ( 形参 ) -&gt; ret { 函数体 }[ 捕获 ] ( 形参 ) { 函数体 }[ 捕获 ] { 函数体 }&amp; 以引用隐式捕获被使用的自动变量= 以复制隐式捕获被使用的自动变量[&amp;]{};          // OK：默认以引用捕获[&amp;, i]{};       // OK：以引用捕获，但 i 以值捕获[=]{};          // OK：默认以复制捕获[=, &amp;i]{};      // OK：以复制捕获，但 i 以引用捕获[this]{}; // 获取this指针, 如果使用了&amp;和=则会默认包括this</code></pre><p><strong>使用场景一</strong><br>以sort为代表的函数 需要传入函数的函数</p><pre><code class="c++">// 原版bool compare(int &amp;a, int &amp;b){    return a &gt; b;}xxx(compare);// 新版xxx([](int a, int b){return a &gt; b;});</code></pre><p><strong>使用场景二</strong></p><pre><code class="c++">auto add = [](int a, int b){return a + b;};int bar = add(1, 2);</code></pre><h3 id="User-defined-literals"><a href="#User-defined-literals" class="headerlink" title="User-defined literals"></a>User-defined literals</h3><pre><code class="c++">using namespace std::chrono_literals;std::this_thread::sleep_for(2000ms);chrono::milliseconds operator&quot;&quot; ms(unsigned long long _Val) noexcept</code></pre><p>第一次看到上面代码 还疑惑了会 点了下ms发现是重载. 才知道这是c++11的特性…</p><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>自己简单实现了一下智能指针</p><p>Counter作为计数类 当调用<code>AddRefCopy</code>时计数值增加<code>Release</code>时计数值减少</p><p><code>Release</code>计数值减少时判断<code>shared_count_</code>如果为0则调用<code>Dispose</code>删除掉保存的指针之后接着调用<code>Destroy</code>删除掉自己</p><p>SharedPtr从<code>from</code>拷贝构造时, 内部Counter指针从<code>from</code>调用<code>AddRefCopy</code>获得 实现拷贝构造计数值增加, 两者共用一个<code>Counter</code></p><p>SharedPtr从<code>from</code>赋值时, 首先对自己保有的Counter指针调用<code>Release</code>减少计数值 然后调用<code>from</code>的<code>AddRefCopy</code>获得新的<code>Counter</code></p><p>SharedPtr析构时调用Counter的<code>Release</code>减少计数值</p><pre><code class="c++">//// Created by rjd67 on 2021/2/28.//#ifndef BASE_MEMORY_H#define BASE_MEMORY_Htemplate&lt;class T&gt;class Counter{public:    explicit Counter(T* ptr);    ~Counter();    void Destroy();    void Dispose();    void Release();    Counter* AddRefCopy();    T* Get();private:    T* ptr_;    int shared_count_;};template&lt;class T&gt;Counter&lt;T&gt;::Counter(T* ptr)    :    ptr_(ptr),    shared_count_(1){}template&lt;class T&gt;Counter&lt;T&gt;::~Counter()= default;template&lt;class T&gt;void Counter&lt;T&gt;::Destroy(){    delete this;}template&lt;class T&gt;void Counter&lt;T&gt;::Release(){    shared_count_--;    if (shared_count_ == 0)    {        Dispose();        Destroy();    }}template&lt;class T&gt;Counter&lt;T&gt;* Counter&lt;T&gt;::AddRefCopy(){    shared_count_++;    return this;}template&lt;class T&gt;void Counter&lt;T&gt;::Dispose(){    delete ptr_;}template&lt;class T&gt;T* Counter&lt;T&gt;::Get(){    return ptr_;}template&lt;class T&gt;class SharedPtr{public:    SharedPtr();    explicit SharedPtr(T* ptr);    ~SharedPtr();    T* Get();    void Reset(T* ptr);    SharedPtr(const SharedPtr&amp;);    SharedPtr&lt;T&gt;&amp; operator=(const SharedPtr&amp;);    T&amp; operator*();    void Swap(SharedPtr&amp; shared_ptr);private:    T* ptr_;    Counter&lt;T&gt;* counter_;};template&lt;class T&gt;SharedPtr&lt;T&gt;::SharedPtr()    :    ptr_(nullptr),    counter_(new Counter&lt;T&gt;(nullptr)){}template&lt;class T&gt;SharedPtr&lt;T&gt;::SharedPtr(T* ptr)    :    ptr_(ptr),    counter_(new Counter&lt;T&gt;(ptr)){}template&lt;class T&gt;SharedPtr&lt;T&gt;::~SharedPtr(){    counter_-&gt;Release();}template&lt;class T&gt;T* SharedPtr&lt;T&gt;::Get(){    return ptr_;}template&lt;class T&gt;void SharedPtr&lt;T&gt;::Reset(T* ptr){    SharedPtr&lt;T&gt;(ptr).Swap(*this);}template&lt;class T&gt;void SharedPtr&lt;T&gt;::Swap(SharedPtr&amp; shared_ptr){    std::swap(ptr_, shared_ptr.ptr_);    std::swap(counter_, shared_ptr.counter_);}template&lt;class T&gt;SharedPtr&lt;T&gt;::SharedPtr(const SharedPtr&amp; shared_ptr){    Counter&lt;T&gt;* other_counter = shared_ptr.counter_;    counter_ = other_counter-&gt;AddRefCopy();    ptr_ = other_counter-&gt;Get();}template&lt;class T&gt;SharedPtr&lt;T&gt;&amp; SharedPtr&lt;T&gt;::operator=(const SharedPtr&amp; shared_ptr){    Counter&lt;T&gt;* other_counter = shared_ptr.counter_;    if (counter_ != other_counter)    {        counter_-&gt;Release();        counter_ = other_counter-&gt;AddRefCopy();        ptr_ = other_counter-&gt;Get();    }    return *this;}template&lt;class T&gt;T&amp; SharedPtr&lt;T&gt;::operator*(){    return *ptr_;}#endif //BASE_MEMORY_H</code></pre><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;future&gt;#include &lt;unistd.h&gt;int Foo(){    std::cout &lt;&lt; &quot;Foo begin&quot; &lt;&lt; std::endl;    sleep(2);    std::cout &lt;&lt; &quot;Foo end&quot; &lt;&lt; std::endl;    return 1;}int main(){    auto get_id = std::async(Foo);    std::cout &lt;&lt; &quot;Other work begin&quot; &lt;&lt; std::endl;    sleep(1); // do other works    std::cout &lt;&lt; &quot;Other work end&quot; &lt;&lt; std::endl;    get_id.wait();    std::cout &lt;&lt; get_id.get() &lt;&lt; std::endl;    return 0;}/*Other work beginFoo beginOther work endFoo end1*/</code></pre><h3 id="mutex-condition"><a href="#mutex-condition" class="headerlink" title="mutex condition"></a>mutex condition</h3><h3 id="std-function-和-std-bind"><a href="#std-function-和-std-bind" class="headerlink" title="std::function 和 std::bind"></a>std::function 和 std::bind</h3><pre><code class="c++">##include &lt;functional&gt;##include &lt;iostream&gt;void PrintA(){    std::cout &lt;&lt; &quot;A&quot; &lt;&lt; std::endl;}void PrintB(int bar){    std::cout &lt;&lt; &quot;B&quot; &lt;&lt; std::endl;}int main(){    std::function&lt;void()&gt; FPrintA = PrintA;    FPrintA();    std::function&lt;void(int)&gt; FPrintB = PrintB;    FPrintB(1);// 感觉配合Lambad 挺不错, 在一个函数中经常使用的功能可以这样定义    std::function&lt;void()&gt; FLambad = [](){std::cout &lt;&lt; &quot;Lambad&quot; &lt;&lt; std::endl;};    FLambad();    // 不过使用auto貌似更简单    auto ALambad = [](){std::cout &lt;&lt; &quot;Lambad&quot; &lt;&lt; std::endl;};    ALambad();}$ A$ B$ Lambad</code></pre><pre><code class="c++">##include &lt;functional&gt;##include &lt;cstdio&gt;void f(int n1, int n2, int n3, int n4){    printf(&quot;f function--&gt;n1: %d, n2: %d, n3: %d, n4: %d\n&quot;, n1, n2, n3, n4);}void ff(int &amp;n1, int&amp; n2, const int&amp; n3){    printf(&quot;before ff function--&gt;n1: %d, n2: %d, n3: %d\n&quot;, n1, n2, n3);    n1 = 11;    n2 = 22;    // n3 = 33; 编译错误    printf(&quot;after ff function--&gt;n1: %d, n2: %d, n3: %d\n&quot;, n1, n2, n3);}int main(){    auto f1 = std::bind(f, std::placeholders::_2, std::placeholders::_3, 666, std::placeholders::_1);    f1(1, 2, 3, 4, 5);    // infunction--&gt;n1: 2, n2: 3, n3: 666, n4: 1    // 1 绑定_1  2绑定_2  3绑定_3   // 4 5被忽略    // 按照 f1的顺序传入参数    // 所以调用为 f(2, 3, 666, 1);    int n1 = 1, n2 = 2, n3 = 3;    auto ff1 = std::bind(ff, n1, std::ref(n2), std::cref(n3));    n1 = -1;    n2 = -2;    n3 = -3;    printf(&quot;before ff1 function--&gt;n1: %d, n2: %d, n3: %d\n&quot;, n1, n2, n3);    ff1(n1, n2, n3);    printf(&quot;after ff1 function--&gt;n1: %d, n2: %d, n3: %d\n&quot;, n1, n2, n3);    // before ff1 function--&gt;n1: -1, n2: -2, n3: -3    // before ff function-- &gt; n1: 1, n2 : -2, n3 : -3 // 这里说明了值传递 参数是绑定时就决定好了 引用参数还是可以改变的    // after ff function-- &gt; n1: 11, n2 : 22, n3 : -3    // after ff1 function-- &gt; n1: -1, n2 : 22, n3 : -3 // 引用传入成功改变, 值传入和const引用传入未变    // std::ref 按引用传入参数 std::cref按const引用传入参数}</code></pre><h1 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><h3 id="0b010101-二进制表达"><a href="#0b010101-二进制表达" class="headerlink" title="0b010101 二进制表达"></a>0b010101 二进制表达</h3><pre><code class="c++">int a = 0b111111111;</code></pre><h2 id="库-1"><a href="#库-1" class="headerlink" title="库"></a>库</h2><h1 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h1><h2 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h2><h3 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h3><pre><code class="c++">#include &lt;map&gt;#include &lt;iostream&gt;int main(){    std::map&lt;int, int&gt; id_map{{1, 2}, {3, 4}};    for (const auto&amp; id : id_map)    {        std::cout &lt;&lt; id.first &lt;&lt; id.second &lt;&lt; std::endl;    }    for (const auto&amp;[id1, id2] : id_map)    {        std::cout &lt;&lt; id1 &lt;&lt; id2 &lt;&lt; std::endl;;    }    return 0;}/*12341234*/</code></pre><h3 id="初始化语句不再局限于for语句-if和switch也能使用-while"><a href="#初始化语句不再局限于for语句-if和switch也能使用-while" class="headerlink" title="初始化语句不再局限于for语句 if和switch也能使用 while: ???"></a>初始化语句不再局限于for语句 if和switch也能使用 while: ???</h3><pre><code class="c++">int Init(){    return 1;}int main(){    for (int a = Init(); a != 2; a++)    {        std::cout &lt;&lt; 1 &lt;&lt; std::endl;    }    if (int a = Init(); a == 1)    {        std::cout &lt;&lt; 1 &lt;&lt; std::endl;    }    switch (int a = Init(); a)    {    case 1:        std::cout &lt;&lt; 1 &lt;&lt; std::endl;    }    return 1;}</code></pre><p>至于while为什么没有 <a href="https://stackoverflow.com/questions/59985550/while-statement-with-initializer" target="_blank" rel="noopener">https://stackoverflow.com/questions/59985550/while-statement-with-initializer</a></p><p>说是C++已经足够复杂了, 每次增加复杂度的时候都要足够的小心, 让这些复杂度增加的合理而自然.</p><p>如果对while增加初始化语句, 那么for? <del>干脆删掉while吧</del></p><h2 id="库-2"><a href="#库-2" class="headerlink" title="库"></a>库</h2><h3 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h3><p><strong>optional</strong></p><pre><code class="c++">std::optional&lt;std::string&gt; Foo(bool b){    if (b)    {        return &quot;123456&quot;;    }    else    {        return {};    }}int main(){    if (!Foo(false).has_value())    {        std::cout &lt;&lt; &quot;no value&quot; &lt;&lt; std::endl; // no value    }    std::cout &lt;&lt; Foo(false).value_or(&quot;(null)&quot;); // (null)    std::cout &lt;&lt; Foo(true).value_or(&quot;no value&quot;); // 123456}</code></pre><h3 id="string-view"><a href="#string-view" class="headerlink" title="string_view"></a>string_view</h3><p>提供了对<code>已经被其他持有所有权的字符串</code>的指针和长度的包装 仅仅提供包装</p><pre><code class="c++">int main(){    const char* str = &quot;123456789&quot;;    std::string_view message(str, strlen(str));    std::cout &lt;&lt; message;}</code></pre><h1 id="C-20"><a href="#C-20" class="headerlink" title="C++20"></a>C++20</h1><h2 id="库-3"><a href="#库-3" class="headerlink" title="库"></a>库</h2><h3 id="协程库"><a href="#协程库" class="headerlink" title="协程库"></a>协程库</h3><pre><code class="c++">// SET(CMAKE_CXX_FLAGS &quot;-fcoroutines -std=c++2a&quot;)#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;coroutine&gt;#include &lt;chrono&gt;#include &lt;functional&gt;using call_back = std::function&lt;void(int)&gt;;void Add100ByCallback(int init, call_back f) // 异步调用{    std::thread t([init, f]()    {        std::this_thread::sleep_for(std::chrono::seconds(3));        f(init + 100);    });    t.detach();}struct Add100AWaitable{    Add100AWaitable(int init)            :init_(init)    {    }    /**     * 返回 awaitable是否已经ready     * @return     */    bool await_ready() const    {        return false; // 返回true说明结果已经得到 不需要执行协程了    }    /**     * 挂起 awaitable 通过handle.resume() 恢复协程     * @param handle     */    void await_suspend(std::coroutine_handle&lt;&gt; handle)    {        auto f = [handle, this](int value) mutable        {            result_ = value;            handle.resume();        };        Add100ByCallback(init_, f); // 调用原来的异步调用    }    /**     * 协程恢复后 会调用此函数 返回结果即为co_wait的返回值     * @return     */    int await_resume()    {        return result_;    }    int init_; // Add100ByCallback的参数    int result_; // Add100ByCallback的结果};/** * 最简单的Promise规范的类型 */struct Task{    struct promise_type    {        auto get_return_object()        {            return Task{};        }        auto initial_suspend()        {            return std::suspend_never{};        }        auto final_suspend()        {            return std::suspend_never{};        }        void unhandled_exception()        {            std::terminate();        }        void return_void()        {        }    };};/** * 协程的入口函数 必须是在某个函数中. 函数的返回值需要满足Promise规范 * @return */Task Add100ByCoroutine(int init, call_back f){    /**     * 协程可以解放异步函数的组织     * 否则多个异步回调实现同步 需要嵌套调用     * int ret = 0;     * Add100ByCallback(5, [&amp;](int value)     * {     *         ret = value;     *         Add100ByCallback(ret, [&amp;](int value)     *         {     *             ret += value;     *         });     * });     */    int ret = co_await Add100AWaitable(init); // 连续调用co_await    ret = co_await Add100AWaitable(ret); // 将多个异步调用转换为串行化的同步调用    f(ret);}int main(){    Add100ByCallback(5, [](int value)    { std::cout &lt;&lt; &quot;get result: &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;; });    Add100ByCoroutine(10, [](int value) // 启动协程    { std::cout &lt;&lt; &quot;get result from coroutine1: &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;; });    Add100ByCoroutine(20, [](int value) // 启动协程    { std::cout &lt;&lt; &quot;get result from coroutine2: &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;; });}</code></pre><p>协程一大用途就是可以方便的将多个异步调用转换为串行化的同步调用</p><h3 id="format库"><a href="#format库" class="headerlink" title="format库"></a>format库</h3><p><a href="https://github.com/fmtlib/fmt" target="_blank" rel="noopener">https://github.com/fmtlib/fmt</a></p><p>将项目中的include和src拷贝出放入format文件夹添加到项目根目录</p><p>format文件夹新增CMakeLists.txt</p><pre><code class="cmake">SET(FORMAT_SRC        src/os.cc        src/format.cc        )add_library(format ${FORMAT_SRC})</code></pre><p>项目根CMakeLists.txt增加如下三行</p><pre><code class="cmake">include_directories(format/include)add_subdirectory(format)target_link_libraries(YOUR EXECUTABLE format)</code></pre><p>即可使用fmt库 相关语法也非常简单</p><pre><code class="c++">const char* errnum;const char* shortmsg;fmt::format(&quot;HTTP/1.0 {} {}\r\n&quot;, errnum, shortmsg);</code></pre>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Libevent代码初期了解</title>
      <link href="/2020/02/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Libevent%E4%BB%A3%E7%A0%81%E5%88%9D%E6%9C%9F%E4%BA%86%E8%A7%A3/"/>
      <url>/2020/02/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Libevent%E4%BB%A3%E7%A0%81%E5%88%9D%E6%9C%9F%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>学习来源<br>&lt;Linux 高性能服务器编程&gt;</p><h1 id="I-O框架库概述"><a href="#I-O框架库概述" class="headerlink" title="I/O框架库概述"></a>I/O框架库概述</h1><h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-1IO%E6%A1%86%E6%9E%B6%E7%BB%84%E7%BB%84%E4%BB%B6.png" alt=""><br>句柄(Handler)<br>由于统一了事件源, 一个事件一般跟一个句柄绑定在一起, 事件就绪之后 会通过句柄通知这一个事件.<br>在Linux中 I/O 事件对应的句柄-&gt;文件描述符, 信号事件-&gt;信号值</p><p>事件多路分发器(EventDemultiplexer)<br>事件的到来是随机的, 异步的. 所以只能通过一个循环一直等待事件并进行处理 — 事件循环<br>一般通过IO复用实现 select poll epoll_wait</p><p>事件处理器(EventHandle)<br>具体事件处理器(ConcreteEventHandler)<br>事件处理器执行事件对应的业务逻辑, 通常包含一个或多个handler_event回调函数, 这些回调函数在事件循环中被执行</p><p>Reactor<br>handler_events: 执行事件循环 重复等待事件, 然后依次调用对应的事件处理器<br>register_handler: 向事件多路分发器中注册事件<br>remove_handler: 从中删除一个事件</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-2%20IO%E6%A1%86%E6%9E%B6%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt=""></p><h2 id="Libevent源码分析"><a href="#Libevent源码分析" class="headerlink" title="Libevent源码分析"></a>Libevent源码分析</h2><pre><code class="c++">#include &lt;sys/signal.h&gt;#include &lt;event.h&gt;#include &lt;cstdio&gt;void signal_cb(int fd, short event, void* argc){    event_base* base = (event_base*)argc;    timeval delay = {2, 0};    printf(&quot;Caught an interrupt signal\n&quot;);    event_base_loopexit(base, &amp;delay);}void timeout_cb(int fd, short event, void* argc){    printf(&quot;timeout\n&quot;);}int main(){    // 相当于创建一个Reactor实例    event_base* base = event_init();    event* signal_event = evsignal_new(base, SIGINT, signal_cb, base);    event_add(signal_event, nullptr);    event* timeout_event = evtimer_new(base, timeout_cb, nullptr);    timeval tv{1, 0};    event_add(timeout_event, &amp;tv);    event_base_dispatch(base);    event_free(signal_event);    event_free(timeout_event);    event_base_free(base);}</code></pre><p>创建一个事件处理器 然后为绑定上相应的回调函数.<br>然后把这个事件处理器注册到事件队列中中,</p><p>然后事件多路分发器依靠循环一直等待事件的到来, 事件到来后通知相应的事件处理器<br>Reactor则管理这些</p><p>首先要去了解下 <code>事件处理器</code> 对应的就是event这个结构体</p><pre><code class="c++">struct event {    struct event_callback ev_evcallback;    // 事件处理器从属的 event_base    struct event_base *ev_base;    // 信号值 或者 文件描述符    evutil_socket_t ev_fd;    // 定时器的超时时间    struct timeval ev_timeout;    // 仅用于定时事件    union {        // 队列--指出在通用定时器中的位置        TAILQ_ENTRY(event) ev_next_with_common_timeout;        // 时间堆--指出了在时间堆中的位置        int min_heap_idx;    } ev_timeout_pos;    union {        struct {            // 通过这个成员 将具有相同文件描述符的IO事件处理器串联起来            LIST_ENTRY (event) ev_io_next;            struct timeval ev_timeout;        } ev_io;        struct {            // 相同信号的串联起来            LIST_ENTRY (event) ev_signal_next;            short ev_ncalls;            /* Allows deletes in callback */            short *ev_pncalls;        } ev_signal;    } ev_;    // 事件类型, 可以通过位处理设置非互斥事件    short ev_events;    // 当前激活事件的类型, 说明被激活的原因    short ev_res;};</code></pre><p>可以看到其中有很多的属性, 三种事件对应的不同的属性.</p><p>这些属性的填充函数<br><code>evsignal_new``evtimer_new</code>是宏 统一调用<code>event_new</code><br><code>event_new</code>调用<code>event_assign</code>来进行主要的填充</p><pre><code>//@通过宏封装注册函数一个事件生成函数 经过宏的封装(可以自动填充某些此事件用不到的参数)可以更方便的对应不同事件的生成, 既统一了注册, 又方便用户调用</code></pre><p>属性之一便是回调函数, 事件回调函数有自己的规定</p><pre><code>//@统一事件回调函数void (*callback)(evutil_socket_t, short, void *)这样能够统一回调函数的格式, 同时方便管理</code></pre><p>事件处理器创建完毕, 该把事件处理器添加到事件注册队列. 样例代码中通过的<code>event_add</code>函数来实现将事件处理器添加到事件注册队列<br><code>event_add</code>实际由<code>event_add_nolock_</code>实现 所以接下来是<code>event_add_nolock_</code>函数的说明</p><pre><code>//@事件处理器的分发实现将传入的event按照不同类型的事件处理器 分别处理(因为event_new已经填充了ev_events说明事件类型)IO事件 添加绑定信号事件 绑定相应的信号定时器 放入相关的的时间管理数据结构中</code></pre><p>使用<code>event_queue_insert_inserted</code>进行注册<br>这里的代码2.1.11 与书上的差别较大, 少了多一半的功能, 也没有被抽成函数, 暂不知道对应的功能代码去了哪里<br>照书上来说<code>event_queue_insert_inserted</code>实现的是将事件处理器加入到<code>event_base</code>的某个事件队列中. 对于新添加的IO和信号事件处理器, 还需要让事件多路分发器来监听对应的事件, 然后建立相应的映射关系. 分别使用<code>evmap_io_add_</code>和<code>evmap_signal_add_</code>(相当于图中的<code>register_event</code>)建立映射. </p><p><code>evmap_io_add_</code>中有一个结构体<code>event_io_map</code><br><code>event_io_map</code>会根据不同的平台最终对应不同的数据结构</p><p><code>evmap_io_add_</code>函数<br>函数中用到的东西, 我目前吸收不了……. 总之是为将IO事件处理器加入到<code>event_base</code>的事件队列中实现的</p><p><code>eventop</code>结构体 是<code>event_base</code>中封装IO复用机制的结构体, 提供了统一的接口</p><pre><code class="c++">// 为给定的event_base声明后端的结构体struct eventop {    // 后端IO复用技术的名称    const char *name;    // 初始化 函数需要初始化所有要用的属性    // 返回的指针会被event_init存储在event_base.evbase    // 失败后返回NULL    void *(*init)(struct event_base *);    // 注册事件    int (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);    // 删除事件    int (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);    // 等待事件    int (*dispatch)(struct event_base *, struct timeval *);    // 释放IO复用机制使用的资源    void (*dealloc)(struct event_base *);    // 标记fork后是否需要重新初始化event_base的标志位    int need_reinit;    // 用于设定io复用技术支持的一些特性    enum event_method_feature features;    // 额外内存的分配    size_t fdinfo_len;};</code></pre><p><code>event_base</code>是Libevent的Reactor. 超长结构体 删除了我不理解的部分</p><pre><code class="c++">struct event_base {    // 记录选择的I/O复用机制    const struct eventop *evsel;    // 指向IO复用机制真正存储的数据    void *evbase;    // 事件变换队列 如果一个文件描述符上注册的事件被多次修改, 则可以使用缓冲避免重复的系统调用    // 比如epoll_ctl, 仅能用于时间复杂度O(1)的IO复用技术    struct event_changelist changelist;    // 信号的后端处理机制    const struct eventop *evsigsel;    // 信号事件处理器使用的数据结构, 其中封装了socketpair创建的管道. 用于信号处理函数和    // 事件多路分发器之间的通信, 统一事件源的思路    struct evsig_info sig;    // 添加到event_base的虚拟(所有, 激活)事件数量, 虚拟(所有, 激活)事件最大数量    int virtual_event_count;    int virtual_event_count_max;    int event_count;    int event_count_max;    int event_count_active;    int event_count_active_max;    // 处理完事件后 是否退出循环    int event_gotterm;    // 是否立即终止循环    int event_break;    // 是否启动一个新的事件循环    int event_continue;    // 当前正在处理的活动事件队列的优先级    int event_running_priority;    // 标记事件循环是否已经启动, 防止重入    int running_loop;    // 活动事件队列数组. 索引值越小的队列优先级越高. 高优先级的活动事件队列中的事件处理器被优先处理    struct evcallback_list *activequeues;    // 活动事件队列数组的大小 说明有nactivequeues个不同优先级的活动事件队列    int nactivequeues;    /** A list of event_callbacks that should become active the next time     * we process events, but not this time. */    struct evcallback_list active_later_queue;    // 共同超时逻辑    // 管理通用定时器队列 实体数量 总数    struct common_timeout_list **common_timeout_queues;    int n_common_timeouts;    int n_common_timeouts_allocated;    // 文件描述符和IO事件之间的映射关系表    struct event_io_map io;    // 信号值和信号事件之间的映射关系表    struct event_signal_map sigmap;    // 时间堆    struct min_heap timeheap;    // 管理系统时间的成员    struct timeval tv_cache;    struct evutil_monotonic_timer monotonic_timer;    struct timeval tv_clock_diff;    time_t last_updated_clock_diff;#ifndef EVENT__DISABLE_THREAD_SUPPORT    // 多线程支持    // 当前运行该event_base的事件循环的线程    unsigned long th_owner_id;    // 独占锁    void *th_base_lock;    // 当前事件循环正在执行哪个事件处理器的回调函数    void *current_event_cond;    // 等待的线程数    int current_event_waiters;#endif    // 正在处理的事件处理器的回调函数    struct event_callback *current_event;};</code></pre><p>事件循环, libevent的动力, 即事件循环</p><p>这次读了一下helloworld的 这一部分代码</p><pre><code class="c++">static voidlistener_cb(struct evconnlistener *listener, evutil_socket_t fd,    struct sockaddr *sa, int socklen, void *user_data){    struct event_base *base = user_data;    struct bufferevent *bev;    bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);    if (!bev) {        fprintf(stderr, &quot;Error constructing bufferevent!&quot;);        event_base_loopbreak(base);        return;    }    // 设置新创建的bufferevent的 读写回调函数 启动写事件 禁用读事件    bufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, NULL);    bufferevent_enable(bev, EV_WRITE);    bufferevent_disable(bev, EV_READ);    bufferevent_write(bev, MESSAGE, strlen(MESSAGE));}</code></pre><p>bufferevent_socket_new 创建了读和写event 设置了真实的回调函数<code>bufferevent_writecb</code>等 然后<br>bufferevent_enable是真正的事件注册函数， 将上面生成的event注册进入eventbase<br><code>EV_WRITE</code>对应的epoll事件是<code>EPOLLOUT</code><br><code>bufferevent_write</code>将要写出的数据放入到缓冲区中。 一旦epollwait返回了 就去调用<code>bufferevent_writecb</code>将缓冲区<br>的内容写出， 然后同时调用用户设置的回调函数</p><p>2020年3月7日20:26:02<br>这次又读了下 系统是怎么区分不同事件来调用回调函数的, 结果返现框架将系统的事件类型对应成自己的事件类型</p><pre><code class="c++">if (what &amp; (EPOLLHUP|EPOLLERR)) {    ev = EV_READ | EV_WRITE;} else {    if (what &amp; EPOLLIN)        ev |= EV_READ;    if (what &amp; EPOLLOUT)        ev |= EV_WRITE;    if (what &amp; EPOLLRDHUP)        ev |= EV_CLOSED;}</code></pre><p>然后传入<code>evmap_io_active_</code>函数, 进而将ev保存到<code>ev_res</code>中然后直接作为参数 传给了回调函数</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git的基础使用</title>
      <link href="/2020/02/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-Git-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/02/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-Git-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>2020年8月9日23:06:10 删除已经熟记的部分命令 精简博客</p><h1 id="git设置代理"><a href="#git设置代理" class="headerlink" title="git设置代理"></a>git设置代理</h1><p>下面设置http代理只对http链接有效, 如果你的库绑定了ssh链接 则无效</p><pre><code class="shell">export http_proxy=http://127.0.0.1:1080export https_proxy=http://127.0.0.1:1080curl cip.cc # 查询当前的状态IP    : xxx.xxx.xxx.xxx地址    : 中国  xx  xx运营商    : 联通数据二    : xxx | 联通数据三    : 中国xxxx | 联通URL    : http://www.cip.cc/xxx.xxx.xxx.xxx</code></pre><h1 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h1><p>密钥生成</p><pre><code># -t Specifies the type of key to create.  The possible values are#“dsa”, “ecdsa”, “ed25519”, or “rsa”.# -C 生成注释 ...所以后面的邮箱就是个注释ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></pre><pre><code>git remote add origin  # origin 意为远程库的名字, git的默认叫法git log --pretty=oneline # 简单显示</code></pre><pre><code># 注意reset是恢复到上一个版本 即为你上一次commit版本或者pull最近的一次git checkout --&lt;filename&gt; # 恢复工作区, 可用于恢复修改和恢复勿删文件git reset HEAD &lt;file&gt; # 恢复暂存区git reset HEAD^ # 恢复版本库git reset --hard &lt;hash版本号 即为log中的一串英文字母, 只需要前几个字母即可&gt;git reflog # 所有版本日志git rm 从版本库中删除文件</code></pre><pre><code>git push -u origin master # 带上 -u 以后提交就不需要加入origin master, 类似记忆功能git checkout -b dev 相当于一下两条命令git branch dev  分支创建git checkout dev  分支切换git branch -d dev   分支删除git branch   查看当前所有分支git merge dev  将制定的dev分支合并到当前的分支</code></pre><h1 id="基础的操作"><a href="#基础的操作" class="headerlink" title="基础的操作"></a>基础的操作</h1><p><code>git status</code>告诉你 你修改了哪些文件 但是你想知道你怎么修改了这些文件, 做了什么改动</p><p>这时候就需要<code>git diff</code></p><pre><code>$git diff-------提示如下-----------diff --git a/test.txt b/test.txtindex 0858ae8..8c14912 100644--- a/test.txt+++ b/test.txt@@ -1,3 +1,4 @@ 111111111111111 222222222222222 333333333333333+444444444444444</code></pre><h1 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h1><p><strong>在commit之间切换</strong><br>Git还可以在不同commit间切换, 当然你必须知道进行过哪些commit, 你不能自己都记在脑子里吧, 所以也存在相关的命令<code>git log</code>来查看你的commit记录</p><pre><code>lsmg@ubuntu:~/temp$ git logcommit ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master)Author: ***********Date:   Sat Dec 7 21:06:42 2019 -0800    ver 0.02commit 603260e28ac0cc8fb8e4243120eb00bca83585d2Author: ***********Date:   Sat Dec 7 20:57:58 2019 -0800    ver 0.01lsmg@ubuntu:~/temp$ git log --pretty=oneline # 简洁显示ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master) ver 0.02603260e28ac0cc8fb8e4243120eb00bca83585d2 ver 0.01</code></pre><p>上面的<code>HEAD</code>代表当前版本, 上一个版本为<code>HEAD^</code>, 上上一个版本为<code>HEAD^^</code>如此类推<br>回到前N个版本<code>HEAD~N</code><br><code>git reset --hard HEAD^</code> 回到上一个版本.<br>这时你当前版本将会丢失, 使用<code>git log</code>也不会查看到原来的版本信息<br>这时使用<code>git reflog</code>来查看你的所有版本日志</p><pre><code>lsmg@ubuntu:~/temp$ git reset --hard 603260e28ac0cc8fb8e4243120eb00bca83585d2HEAD 现在位于 603260e ver 0.01lsmg@ubuntu:~/temp$ git logcommit 603260e28ac0cc8fb8e4243120eb00bca83585d2 (HEAD -&gt; master)Author: rjd67441 &lt;rjd67441@hotmail.com&gt;Date:   Sat Dec 7 20:57:58 2019 -0800    ver 0.01lsmg@ubuntu:~/temp$ git reflog 603260e (HEAD -&gt; master) HEAD@{0}: reset: moving to 603260e28ac0cc8fb8e4243120eb00bca83585d2ee4400f HEAD@{1}: commit: ver 0.02603260e (HEAD -&gt; master) HEAD@{2}: commit (initial): ver 0.01lsmg@ubuntu:~/temp$ git reset --hard ee4400fHEAD 现在位于 ee4400f ver 0.02</code></pre><p><strong>撤销修改</strong></p><p>工作区中的撤销<br><code>git checkout -- &lt;filename&gt;</code><br>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br>暂存区中的撤销<br><code>git reset HEAD &lt;file&gt;</code><br>版本库的撤销<br><code>git reset HEAD^</code> 乖乖回退一次</p><p><strong>删除文件</strong></p><p>删除本地文件后<br>确实需要从版本库中删除<br><code>git rm</code>删除然后<code>git commit</code>提交即可<br>误删除需要使用<code>git chechout -- &lt;filename&gt;</code>来恢复</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Git操作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>头文件互相引用</title>
      <link href="/2020/02/%E9%87%87%E5%9D%91%E8%AE%B0-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8/"/>
      <url>/2020/02/%E9%87%87%E5%9D%91%E8%AE%B0-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>写在前头 本文中的<strong>编译</strong>二字基本都带加粗, 因为目前为止我还没做学到过<strong>编译</strong>器相关的东西,<br>姑且将<code>那个执行过程</code>称为<strong>编译</strong>, 所以加粗</p><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>二月六号的时候 我在写那个小游戏, 写头文件<code>a.h</code>发现即使引用了一个头文件<code>b.h</code>, 也没有办法使用定义在那个头文件之中的结构体.</p><p>其实有点我没在意: 当我在<code>a.h</code>文件中引用<code>b.h</code>的时候<code>b.h</code>会变成<code>invaild</code>, 这里其实就已经提示了</p><pre><code class="c++">// a.h#ifndef UNTITLED1_A_H#define UNTITLED1_A_H#include &quot;b.h&quot;class A{    B *b;};#endif //UNTITLED1_A_H// b.h#ifndef UNTITLED1_B_H#define UNTITLED1_B_H#include &quot;a.h&quot;class B{    A *a;};#endif //UNTITLED1_B_H// main.cpp#include &quot;a.h&quot; // a.h中有b.h就只include a.hint main(){    A a{};    B b{};}error: ‘A’ does not name a typeerror: ‘B’ does not name a type</code></pre><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><h2 id="先说一下-ifndef-endif"><a href="#先说一下-ifndef-endif" class="headerlink" title="先说一下 #ifndef #endif"></a>先说一下 #ifndef #endif</h2><p><code>ifndef</code>全称<code>if not defined</code><br>意思是如果<code>#ifndef</code>后面的宏没有被定义 就继续<strong>编译</strong>其中的内容<br>继续<strong>编译</strong><code>#ifndef</code>的下一句就是<code>#define</code>这个宏, 这样这个宏就被定义了<br>第二次<strong>编译</strong>遇到这个头文件的时候, <code>#ifndef</code>后面的宏已经被定义了就跳过了if中的内容</p><h2 id="include的作用"><a href="#include的作用" class="headerlink" title="#include的作用"></a>#include的作用</h2><p>将 #include右边的文件展开到此文件中</p><h2 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h2><p>这样当你在main函数中 <code>#include &quot;a.h&quot;</code>的时候<code>a.h</code>之中的内容就被展开<br>变成如下</p><pre><code class="c++">// main.cpp#ifndef UNTITLED1_A_H#define UNTITLED1_A_H#include &quot;b.h&quot;class A{    B *b;};#endif //UNTITLED1_A_Hint main(){    A a{};    B b{};}</code></pre><p>还有一个include同样操作得到如下</p><pre><code class="c++">// main.cpp#ifndef UNTITLED1_A_H#define UNTITLED1_A_H#ifndef UNTITLED1_B_H#define UNTITLED1_B_H#include &quot;a.h&quot;class B{    A *a;};#endif //UNTITLED1_B_Hclass A{    B *b;};#endif //UNTITLED1_A_Hint main(){    A a{};    B b{};}</code></pre><p>我猜测<strong>编译</strong>的时候是逐行执行的, 至少在头文件的这部分是逐行执行<br>这样执行完了<code>行号为2 3 4 5</code>的四个宏 准备执行<code>行号为6</code>的这一行<code>#include &quot;a.h&quot;</code>继续展开<br>得到如下</p><pre><code class="c++">// main.cpp#ifndef UNTITLED1_A_H#define UNTITLED1_A_H#ifndef UNTITLED1_B_H#define UNTITLED1_B_H#ifndef UNTITLED1_A_H#define UNTITLED1_A_H#include &quot;b.h&quot;class A{    B *b;};#endif //UNTITLED1_A_Hclass B{    A *a;};#endif //UNTITLED1_B_Hclass A{    B *b;};#endif //UNTITLED1_A_Hint main(){    A a{};    B b{};}</code></pre><p>可能有些乱 但仔细理解还是能到这里. 这下继续逐行执行 准备是<code>行号为6</code>的这一行(也可能是行号7的部分, 区别就是在include的下一行展开还是本行展开)<code>#ifndef UNTITLED1_A_H</code><br>这个宏就判断<code>UNTITLED1_A_H</code>是不是被定义了, 恩被定义了(第三行代码)跳到对应的<code>#endif</code>, 这样就防止了头文件<br>无穷无尽的调用 我将跳过的部分注释掉方便继续分析</p><pre><code class="c++">// main.cpp#ifndef UNTITLED1_A_H#define UNTITLED1_A_H#ifndef UNTITLED1_B_H#define UNTITLED1_B_H//#ifndef UNTITLED1_A_H//#define UNTITLED1_A_H//#include &quot;b.h&quot;//class A//{//   B *b;//};//#endif //UNTITLED1_A_Hclass B{    A *a;};#endif //UNTITLED1_B_Hclass A{    B *b;};#endif //UNTITLED1_A_Hint main(){    A a{};    B b{};}</code></pre><p>下一行就是<code>第十四行</code>的<code>class B</code>的<strong>编译</strong>, 那么问题来了<code>第16行</code>的<code>A</code>是啥东西??.</p><p>这里报错报了两行 我大胆推测一下 <code>class B</code>的<strong>编译</strong>的出错后, 依然在继续这个过程, 到了<code>class A</code>的时候<br>发现其中的<code>B</code>又是啥呢? 推测不同头文件编译互不影响 所以出现了两行报错</p><p>我们回到<code>class B</code>的头文件在<code>class B</code>的前面加上一行<code>class A;</code> 得到如下代码</p><pre><code class="c++">// main.cpp#ifndef UNTITLED1_A_H#define UNTITLED1_A_H#ifndef UNTITLED1_B_H#define UNTITLED1_B_H//#ifndef UNTITLED1_A_H//#define UNTITLED1_A_H//#include &quot;b.h&quot;//class A//{//   B *b;//};//#endif //UNTITLED1_A_Hclass A;class B{    A *a;};#endif //UNTITLED1_B_Hclass A{    B *b;};#endif //UNTITLED1_A_Hint main(){    A a{};    B b{};}</code></pre><p>到了这里你会发现A的报错消失了, 因为这次在<strong>编译</strong><code>class B</code>的时候事先知道了<code>A</code>是一个类并且你必须把<br><code>class B</code>之中的这一句<code>A *a;</code>写成指针, 因为指针大小确定, 而且没有初始化, 所以<strong>编译</strong>就能通过, 如果你写成<br><code>A a;</code>依然会报错, 因为不知道A具体是个啥 最起码的内存都没法分配</p><p>好的下面继续, 你发现虽然A的报错消失了 但是<code>B</code>的报错还在, 我这里依然推测下, 不同头文件之间的<strong>编译</strong>互不影响,<br>所以依然不知道<code>B</code>是什么此时按照上面操作加入<code>class B;</code>前置声明, <strong>编译</strong>正确通过.</p><p>虽然两个头文件<strong>编译</strong>互不影响, 但是既然是main.cpp把他们引进来的 就同时对main.cpp起作用 自然就知道了A和B是啥</p><p>虽然这个问题网上答案很多, 但我对此还是很多不理解, 所以在做某些推测的情况下, 分析出来了这些原因. 如果有误,请直接评论中指出. 这也算是本人的第一篇写的认真的博客</p>]]></content>
      
      
      <categories>
          
          <category> 采坑记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 采坑记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节对齐</title>
      <link href="/2020/02/CPP-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
      <url>/2020/02/CPP-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<p><strong>解释</strong><br>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。–百度百科</p><p><strong>原因</strong><br>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况<br>但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。–百度百科</p><pre><code class="c++">struct Foo{    char foo1;    int foo2;    short foo3;}sizeof(Foo) = 12sizeof(char) + sizeof(int) + sizeof(short) = 7</code></pre><p>说明内存中并不是连续存储的这三个变量;</p><pre><code class="c++">Foo foo1{&#39;1&#39;, 2, 3};write(fd, &amp;foo1, sizeof(foo1));</code></pre><p>// hexdump 查看<br>0000000 5631 0000 0002 0000 0003 0000<br>对应图示如下<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png" alt=""></p><p>第一字节 0x31 正好是 ‘1’ <em>蓝色区域</em></p><p>第二三四字节 为填充 <em>红色区域</em><br>因为sizeof(int)=4所以foo2的偏移量是四的倍数 , 故需要填充三个字节 3+1 = 4</p><p>第五六七八字节 0x02对应2 <em>灰色区域</em></p><p>没有填充是因为sizeof(short)=2所以foo3的偏移量是2的倍数 由于偏移量是8 所以不需要填充</p><p>第九十字节 0x03 对应3</p><p>第十一十二字节填充<em>黑色区域</em><br>因为此结构中最大的sizeof()=4所以需要将字节数对齐到4的倍数 目前10字节 所以需要填充2字节到<br>12字节满足四的倍数</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="/2019/11/CPP-%E6%8C%87%E9%92%88/"/>
      <url>/2019/11/CPP-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级<br>根据运算符优先级判断这个定义的含义</p><h1 id="指针的定义识别"><a href="#指针的定义识别" class="headerlink" title="指针的定义识别"></a>指针的定义识别</h1><h2 id="由运算符优先级判断"><a href="#由运算符优先级判断" class="headerlink" title="由运算符优先级判断"></a>由运算符优先级判断</h2><p>下面列出常见到的运算符</p><p><code>[]</code>中括号这个的优先级最高, 跟括号并列.(排除域运算符).<br>    从左到右的结合性 -意味着<code>p[]</code>中<code>[]</code>会先跟<code>p结合</code>而不是中括号右边的内容<br><code>()</code>与之结合成为函数<br>    从左到右的结合性<br><code>*</code>其次是这个符号<br>    从右到左的结合性</p><p>两个大头<br><code>int *p[3]</code>和<code>int (*p)[3]</code><br>前者由于<code>[]</code>的优先级更高p与之结合说明p是<strong>数组*</strong>得到p本质是什么 数组OR指针*<br>再与<code>*</code>结合说明<strong>数组中的元素</strong>是<strong>指针*</strong>第二次结合 如果第一次是数组-则为数组中的内容, 第一次是指针-则为指针的指向*<br>再与int结合 说明数组中<strong>指针指向</strong>的是int</p><p>后者<code>*</code>先与p结合说明p是一个<strong>指针</strong><br>再与<code>[]</code>结合说明<strong>指针指向</strong>的内容是<strong>数组</strong><br>再与int结合说明<strong>数组中的内容</strong>是int</p><hr><p>本质上定义函数相关的也可以这样理解<br><code>int p(int)</code>和<code>int (*p)(int)</code><br>前者p先与<code>()</code>结合说明p是一个<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p><p>后者p先与<code>*</code>结合说明p是一个<strong>指针</strong><br>与<code>()</code>结合说明<strong>指针指向</strong>的是<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p><h2 id="判断指针的类型"><a href="#判断指针的类型" class="headerlink" title="判断指针的类型"></a>判断指针的类型</h2><p>去除指针声明语句中的指针名称, 剩下的部分就是指针的类型.<br><code>int* p</code>得到<code>int*</code>, 说明指针的类型是<code>int*</code><br><code>int (*p)[3]</code> 说明指针的类型是<code>int (*)[3]</code></p><h2 id="指针指向的类型"><a href="#指针指向的类型" class="headerlink" title="指针指向的类型"></a>指针指向的类型</h2><p>去除指针声明语句中的指针名称, 以及名称左边的指针声明符<em>, 剩下的部分是指针指向的类型<br>`int</em> p<code>得到</code>int<code>说明指针指向的类型就是</code>int<code></code>int (*p)[3]<code>得到</code>int()[3]<code>说明指针指向的类型就是</code>int()[3]`</p><h2 id="指针的值"><a href="#指针的值" class="headerlink" title="指针的值"></a>指针的值</h2><p>指针存储的即为指向一个内存区域的地址值</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++薄书整理</title>
      <link href="/2019/10/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-2/"/>
      <url>/2019/10/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-2/</url>
      
        <content type="html"><![CDATA[<h1 id="定义新量"><a href="#定义新量" class="headerlink" title="定义新量"></a>定义新量</h1><p>auto 自动根据初始值的类型进行自动类型推导.<br>decltype 根据表达式的类型定义对象</p><p>右值引用, 操纵右值对象<br><code>std::move()</code>, 可以将一个</p><p><strong>枚举</strong><br>不限定作用域的定义<br>enum color {red, green, blue};<br>限定在类型内部的作用域<br>enum class color {red, green, blue};<br><code>color a = color::red</code></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>数组传参的长度处理</p><ul><li>直接传递数组长度</li><li>使用C风格字符串(默认结尾有标志)</li><li>使用C++11的新函数begin()和end()同时传递首尾地址</li></ul><p>函数指针<br><code>bool (*pf)(int, int)</code> 可以指向<br><code>bool max(int a,int b)</code><br>调用 <code>pf(1, 1)</code>即可<br>常用于函数的参数是一个函数的返回值</p><p><strong>Lambda</strong><br><code>[]() -&gt; return type {statements}</code><br>中括号代表lambda引导, 其中的captures子句在同一作用域下lambda主体捕获(访问)哪些对象<br>以及如何捕获这些对象</p><ul><li>可以为空, 不会访问外围对象</li><li>[=] 代表用值捕获的方式</li><li>[&amp;] 代表引用捕获</li></ul><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p><strong>辅助函数</strong><br>定义辅助函数, 有点像Java里面的重写toString()函数(最常见的代表的例子)</p><pre><code class="c++">ostream &amp;print(ostream &amp;os){    os &lt;&lt; 1 &lt;&lt; endl;    return os;}</code></pre><p><strong>友元函数</strong><br>一个类的辅助函数从概念上可以看成类的接口, 虽然和类的关系很密切, 但并不是类的成员, 所以不能直接访问私有成员<br>C++ 中可以将该类函数声明为该类的友元.<br>这样就能访问到类的非公有成员.<br>在函数的前面加上<code>friend</code>关键字<br><strong>友元类</strong><br>如果A想访问B的私有成员, 可以在B内声明<code>friend class A</code>, 这样就可以在B内访问A的私有成员<br><em>友元关系是单向的, 不具有交换性, 同时也不具有传递性</em></p><p><strong>构造函数</strong><br>默认构造函数没有参数, 或者所有的参数都具有默认值<br>C++11允许在显示定义构造函数的情况下使用默认构造函数<br>需要在默认构造函数后面加上<code>= default</code><br><em>使用默认构造函数创建类对象时, 切忌在对象名后I使用圆括号, 成了一个函数声明</em></p><p><strong>初始值列表</strong><br>T(int a, int b):a_(a), b_(b){}<br>引用和const修饰的必须用初始值列表初始化, 初始的顺序取决于数据成员在类内的定义顺序,<br>而非初始值列表的顺序</p><p><strong>简化构造函数</strong><br>实际将自己的带参构造函数, 给定默认值, 这样就实现了默认构造函数和带参构造函数的合并</p><p><strong>复制构造函数</strong><br>参数为该类的引用</p><p><strong>委托构造函数</strong><br>减少构造函数代码量<br>实际就是一个构造函数后面加上<code>:</code>调用另一个构造函数, 同时传入参数</p><pre><code class="c++">class A{    int bar1_;    int bar2_;    A(int b1):A(b1, 2){}    A(int b1, int b2):bar1_(b1), bar2_(b2){}}</code></pre><p><strong>运算符重载</strong><br>T operator /(A, B);<br>双目运算符两个参数<br>单目运算符一个参数<br>对于二元运算符, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数.</p><p>运算符重载的声明和定义的分离<br>放在类成员中的运算符重载, 需要算入默认的this指针参数</p><pre><code class="c++">// test.h#include &lt;cstdio&gt;class Test{public:    Test(int a, int b);    Test&amp; operator+(const Test&amp; right);    void PrintAB();private:    int a_;    int b_;};// test.cpp#include &quot;test.h&quot;Test::Test(int a, int b){    a_ = a;    b_ = b;}Test&amp; Test::operator+(const Test&amp; right){    Test test(this-&gt;a_ + right.a_, this-&gt;b_ + right.b_);    return test;}void Test::PrintAB(){    printf(&quot;%d %d\n&quot;, a_, b_);}// main.cppint main(){    Test test1(1, 1);    Test test2(2, 2);    Test test = test1 + test2;    test.PrintAB();    return 0;}// ++ -- Test&amp; operator++(); // 前置版本Test operator++(int); // 后置版本</code></pre><p><strong>类成员指针</strong><br><em>数据成员指针</em> (private不能通过指针访问)<br>其值是数据成员所在地址相对于对象起始地址的偏移值</p><pre><code class="c++">A T::*p1 = &amp;T::xint A::*p1 = &amp;A::valueA a;// 使用方式a.*p = ......................;</code></pre><p>p1指向T类中的 A类型的x数据成员<br><code>A T::</code>可以用<code>auto</code></p><p><em>成员函数指针</em></p><pre><code class="c++">int (A::*pf)();pf = &amp;A::GetValue;// 当然可以使用auto 来简化auto pf2 = &amp;A::GetValue;// 使用方式(a.*pf)();</code></pre><hr><p>统一初始化<br><code>X x1 = {0} 和 X x2 {0}</code> 这两种是不同的实现!!, 大多数情况下这两个是相通的, 然而当<br><code>explicit构造函数</code>存在的时候<code>前者的初始化是错误的</code></p><p><code>int x{0} int x= 0 int x(0)</code> 最后一个是错误的可能会和函数声明冲突</p><pre><code class="c++">class A{    typedef int x;    int z(x);}</code></pre><p>另外还存在一个</p><pre><code class="c++">std::atomic&lt;int&gt; a1{0}; // OKstd::atomic&lt;int&gt; a2(0); // OKstd::atomic&lt;int&gt; a3 = 0; // Error</code></pre><p>这个错误的原因是copy-initialization引起的<br>这个copy-initialization发生在<code>T x = a</code>的声明, 下面我把原博客的部分重要英文替换成中文或代码描述<br><code>std::atomic&lt;int&gt; a3 = 0</code> 从<code>int类型</code>赋值到<code>可能是 cv-qualified</code>的<code>class type</code><br><a href="https://stackoverflow.com/questions/27527642/what-does-cv-qualified-mean" target="_blank" rel="noopener">cv-qualified</a></p><pre><code class="c++">// ***cv-qualified***// non cv_qualifiedint first; char *second; // cv-qualified const int third; volatile char * fourth; </code></pre><p><code>std::atomic&lt;int&gt; a3 = 0</code> 满足了这个条件属于<code>copy-initialization</code><br><a href="https://www.quora.com/What-is-the-difference-between-copy-initialization-and-direct-initialization-of-objects-in-c++" target="_blank" rel="noopener">copy-initialization</a><br><a href="https://blog.csdn.net/ljianhui/article/details/9245661" target="_blank" rel="noopener">直接初始化和复制初始化的区别</a><br>直接初始化会直接用参数生成对象, 而复制初始化会<code>用参数生成临时对象, 然后将这个对象复制到正要创建的对象</code></p><pre><code class="c++">class A{public:        A () { } //直接初始化会调用这个构造函数        A (const A&amp; a) { } //复制初始化会调用这个}</code></pre><p>接下来需要通过<code>std::atomic&lt;int&gt;(int)</code>把0转换成成一个纯右值(prvalue)的临时对象<br><a href="https://zh.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">纯右值</a><br><a href="https://www.cnblogs.com/zpcdbky/p/5275959.html" target="_blank" rel="noopener">纯右值</a><br>然后再将这个临时对象用直接初始化(调用复制构造函数), 然而<code>std::atomic&lt;int&gt;</code>把拷贝<br>构造函数给禁用了, 就会出错<br><code>std::atomic&lt;int&gt; a3 {0}</code>这个会直接调用接收int的构造函数</p><p>回到<code>X x1 = {0}</code>这里, 这个表达式是一个复制构造, 用一个braced-init-list(指的{0}).<br>这里有两个阶段<br>首先是会把单个参数的构造函数汇总起来(得到A-list)供选择, 如果其中没有合适的构造函数, 再将候选列表<br>转换为所有构造函数</p><p>如果如果A-list没有构造函数, 并且class T存在默认构造函数, 第一阶段就会被忽略<br>如果在一个使用<code>{}</code>的初始化, 并且选择到了<code>explicit 构造函数头上</code>就会报错</p><p><code>explicit</code>可以防止在调用某个成员函数的时候, 实参类型(通过构造函数之一)自动转换成相应参数,<br>但此时这个函数需要其他的成员变量参与到函数运行, 恰巧这时所需要的其他成员变量没有得到合适的初始化, 就会发生错误(没有得到合适初始化的原因就是, 自动调用了不合适的构造函数生成了这个函数所需要的参数(一般是对象))</p><p>@2019年10月26日21:25:58@算是第一次解决一个环环相扣的问题, 精力有点不足了<br><a href="https://zhuanlan.zhihu.com/p/21102748" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21102748</a> 后续会继续进行理解<br><a href="https://blog.csdn.net/spaceyqy/article/details/22730939" target="_blank" rel="noopener">这里还发现一个</a></p><h1 id="模板-泛型-动态内存-数据结构"><a href="#模板-泛型-动态内存-数据结构" class="headerlink" title="模板, 泛型 动态内存, 数据结构"></a>模板, 泛型 动态内存, 数据结构</h1><pre><code class="c++">template &lt;typename T&gt;const T&amp; GetMax(const T&amp; a, const T&amp; b){    return a &gt; b ? a : b;}int main(){    std::cout &lt;&lt; GetMax(1, 2);    std::cout &lt;&lt; GetMax&lt;int&gt;(1, 2); // 显示指定模板类型    return 0; }</code></pre><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/C%2B%2B%E5%86%85%E5%AD%98.png" alt=""><br>C++堆的内存需要手动new和delete, 如果一个对象new出来没有在能被释放的时候释放就会造成–<strong>内存泄漏</strong>(需要及时delete不需要的对象)<br>一个指向动态内存的指针, 在动态内存被释放后, 指针依然指向原来的地址–<strong>空悬指针</strong>(释放内存后将相应的指针设置为nullptr)</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux高性能服务器-高级部分</title>
      <link href="/2019/08/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95101-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/"/>
      <url>/2019/08/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95101-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第九章-I-O复用"><a href="#第九章-I-O复用" class="headerlink" title="第九章 I/O复用"></a>第九章 I/O复用</h1><p>I/O复用使得程序能同时监听多个文件描述符.</p><ul><li>客户端程序需要同时处理多个socket 非阻塞connect技术</li><li>客户端程序同时处理用户输入和网络连接 聊天室程序</li><li>TCP服务器要同时处理监听socket和连接socket</li><li>同时处理TCP和UDP请求 - 回射服务器</li><li>同时监听多个端口, 或者处理多种服务 - xinetd服务器</li></ul><p>常用手段<code>select</code>, <code>poll</code>, <code>epoll</code></p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><pre><code class="c++">// maxfdp 一般设置为最大描述符+1, 因为这里表示的是数量 而描述符从0开始// readfds  需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回// errorfds 错误// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout); //操作fd_set的宏FD_ZERO(fd_set* fdset);FD_SET(int fd, fd_set* fdset);FD_CLR(int fd, fd_set* fdset);FD_ISSET(int fd, fd_set* fdset);// 设置 timeval 超时时间struct timeval{    long tv_sec; // 秒    long tv_usec; // 微秒}</code></pre><p>struct fd_set 一个集合,可以存储多个文件描述符<br>内部是一个32位整数的数组, 数组第一个元素对应0<del>31描述符 一个二进制位代表一个描述符<br>数组第二个元素对应32</del>63 以此类推</p><p>可读条件</p><ul><li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li><li>socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0</li><li>监听socket上有新的连接请求</li><li>socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1</li></ul><p>可写条件</p><ul><li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, <strong>且套接字已经连接, 或套接字不需要连接UDP</strong></li><li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li><li>socket使用非阻塞connect 连接成功或失败后</li><li>socket上有未处理的错误 套接字的写操作不阻塞 并返回-1</li></ul><p>异常条件</p><ul><li>发送带外数据</li></ul><p>select函数在第二个参数列表 可读的时候返回<br>或者是等到了规定的时间返回</p><p>返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表<br>这就需要每次返回后都更新 fdset集合</p><p>返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset<br> 是否在其中<br>然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读<br>还是此连接断开</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p><strong>poll</strong><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png" alt=""><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png" alt=""></p><pre><code class="c++">#include &lt;poll.h&gt;// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\// nfds 遍历结合大小 左闭右开// timeout 单位为毫秒 -1 为阻塞 0 为立即返回int poll(struct pollfd* fds, nfds_t nfds, int timeout);struct pollfd{    int fd;    short events;  //注册的事件, 告知poll监听fd上的哪些事件    short revents; // 实际发生的事件}</code></pre><pre><code class="c++">#define exit_if(r, ...) \{   \    if (r)  \    {   \        printf(__VA_ARGS__);    \        printf(&quot;errno no: %d, error msg is %s&quot;, errno, strerror(errno));    \        exit(1);    \    }   \}   \struct client_info{    char *ip_;    int port_;};int main(int argc, char* argv[]){    int port = 8001;    char ip[] = &quot;127.0.0.1&quot;;    struct sockaddr_in address;    address.sin_port = htons(port);    address.sin_family = AF_INET;    address.sin_addr.s_addr = htons(INADDR_ANY);    int listenfd = socket(PF_INET, SOCK_STREAM, 0);    exit_if(listenfd &lt; 0, &quot;socket error\n&quot;);    int ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address));    exit_if(ret == -1, &quot;bind error\n&quot;);    ret = listen(listenfd, 5);    exit_if(ret == -1, &quot;listen error\n&quot;);    constexpr int MAX_CLIENTS = 1024;    struct pollfd polls[MAX_CLIENTS] = {};    struct client_info clientsinfo[MAX_CLIENTS] = {};    polls[3].fd = listenfd;    polls[3].events = POLLIN | POLLRDHUP;    while (true)    {        ret = poll(polls, MAX_CLIENTS + 1, -1);        exit_if(ret == -1, &quot;poll error\n&quot;);        for (int i = 3; i &lt;= MAX_CLIENTS; ++i)        {            int fd = polls[i].fd;            if (polls[i].revents &amp; POLLRDHUP)            {                polls[i].events = 0;                printf(&quot;close fd-%d from %s:%d\n&quot;, fd, clientsinfo[fd].ip_, clientsinfo[fd].port_);            }            if (polls[i].revents &amp; POLLIN)            {                if (fd == listenfd)                {                    struct sockaddr_in client_address;                    socklen_t client_addresslen = sizeof(client_address);                    int clientfd = accept(listenfd, (struct sockaddr*)&amp;client_address,                            &amp;client_addresslen);                    struct client_info *clientinfo = &amp;clientsinfo[clientfd];                    clientinfo-&gt;ip_ = inet_ntoa(client_address.sin_addr);                    clientinfo-&gt;port_ = ntohs(client_address.sin_port);                    exit_if(clientfd &lt; 0, &quot;accpet error, from %s:%d\n&quot;, clientinfo-&gt;ip_,                            clientinfo-&gt;port_);                    printf(&quot;accept from %s:%d\n&quot;, clientinfo-&gt;ip_, clientinfo-&gt;port_);                    polls[clientfd].fd = clientfd;                    polls[clientfd].events = POLLIN | POLLRDHUP;                }                else                {                    char buffer[1024];                    memset(buffer, &#39;\0&#39;, sizeof(buffer));                    ret = read(fd, buffer, 1024);                    if(ret == 0)                    {                        close(fd);                    }                    else                    {                        printf(&quot;recv from %s:%d:\n%s\n&quot;, clientsinfo[fd].ip_,                               clientsinfo[fd].port_, buffer);                    }                }            }        }    }}</code></pre><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p><strong>epoll</strong></p><p>epoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异</p><ul><li>epoll使用一组函数完成任务</li><li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中</li><li>epoll无需每次调用都传入文件描述符集或事件集.</li></ul><p>有特定的文件描述符创建函数, 来标识这个事件表<code>epoll_create()</code><br><code>epoll_ctl()</code> 用来操作这个内核事件表<br><code>epoll_wait()</code> 为主要函数 成功返回就绪的文件描述符个数 失败返回-1<br>如果<code>epoll_wait()</code>函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出<code>epoll_wait</code>检测到的就绪事件.</p><p><em>event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率</em></p><pre><code class="c++">// 索引poll返回的就绪文件描述符int ret = poll(fds, MAX_EVENT_NUMBER - 1);// 遍历for(int i = 0; i &lt; MAX_EVENT_NUMBER; ++i) {    if(fds[i].revents &amp; POLLIN) {        int sockfd = fds[i].fd;    }}// 索引epoll返回的就绪文件描述符int ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER,  -1);for(int i = 0; i &lt; ret; i++) {    int sockfd = events[i].data.fd;    // sockfd 一定就绪 ?????}</code></pre><p><strong>LT和ET模式</strong><br>LT(电平触发, 默认的工作模式)<br>LT模式下的epoll相当于一个效率较高的poll<br>epoll_wait将会一只通知一个事件知道这个事件被处理</p><p>ET(边沿触发, epoll的高效工作模式)模式<br>当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个<br>文件描述符<br>epoll_wait只会通知一次, 不论这个事件有没有完成</p><p>ET模式</p><pre><code>-&gt; 123456789-123456789-123456789event trigger onceget 9bytes of content: 123456789get 9bytes of content: -12345678get 9bytes of content: 9-1234567get 4bytes of content: 89read later</code></pre><p>LT模式</p><pre><code>-&gt; 123456789-123456789-123456789event trigger onceget 9bytes of contents: 123456789event trigger onceget 9bytes of contents: -12345678event trigger onceget 9bytes of contents: 9-1234567event trigger onceget 4bytes of contents: 89</code></pre><p>ET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式<br>LT模式只要事件没被处理就会一直通知</p><pre><code class="c++">#include &lt;epoll.h&gt;// size 参数只是给内核一个提示, 事件表需要多大// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表int epoll_create(int size);// epfd 为 epoll_create的返回值// op为操作类型// - EPOLL_CTL_ADD 向事件表中注册fd上的事件// - EPOLL_CTL_MOD 修改fd上的注册事件// - EPOLL_CTL_DEL 删除fd上的注册事件// fd 为要操作的文件描述符int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);struct epoll_event{    _uint32_t events; // epoll事件    epoll_data_t data; // 用户数据 是一个联合体}typedef union epoll_data{    void* ptr; // ptr fd 不能同时使用    int fd;    uint32_t u32;    uint64_t u64;}epoll_data_t// maxevents监听事件数 必须大于0// timeout 为-1 表示阻塞// 成功返回就绪的文件描述符个数 失败返回-1int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);</code></pre><h2 id="三种IO复用的比较"><a href="#三种IO复用的比较" class="headerlink" title="三种IO复用的比较"></a>三种IO复用的比较</h2><p><code>select</code>以及<code>poll</code>和<code>epoll</code><br>相同</p><ul><li>都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.</li><li>返回值为就绪的文件描述符数量, 返回0则表示没有事件发生</li><li><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png" alt=""></li></ul><h2 id="I-O-复用的高级应用-非阻塞connect"><a href="#I-O-复用的高级应用-非阻塞connect" class="headerlink" title="I/O 复用的高级应用, 非阻塞connect"></a>I/O 复用的高级应用, 非阻塞connect</h2><p>connect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.</p><p>当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功</p><h1 id="第十章信号"><a href="#第十章信号" class="headerlink" title="第十章信号"></a>第十章信号</h1><h2 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h2><p>发送信号Api</p><pre><code class="c++">#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;// pid &gt; 0 发送给PID为pid标识的进程//  0 发送给本进程组的其他进程// -1 发送给进程以外的所有进程, 但发送者需要有对目标进程发送信号的权限// &lt; -1 发送给组ID为 -pid 的进程组中的所有成员// 出错信息 EINVAL 无效信号, EPERM 该进程没有权限给任何一个目标进程 ESRCH 目标进程(组) 不存在int kill(pid_t pid, int sig);</code></pre><p>接收信号Api</p><pre><code class="c++">#include &lt;signal.h&gt;typedef void(*_sighandler_t) (int);#include &lt;bits/signum.h&gt; // 此头文件中有所有的linux可用信号// 忽略目标信号#define SIG_DFL ((_sighandler_t) 0)// 使用信号的默认处理方式#define SIG_IGN ((_sighandler_t) 1)</code></pre><p>常用信号</p><pre><code>SIGHUP 控制终端挂起SIGPIPE 往读端被关闭的管道或者socket连接中写数据SIGURG socket连接上收到紧急数据SIGALRM 由alarm或setitimer设置的实时闹钟超时引起SIGCHLD 子进程状态变化</code></pre><p>信号函数</p><pre><code class="c++">// 为一个信号设置处理函数#include &lt;signal.h&gt;// _handler 指定sig的处理函数_sighandler_t signal(int sig, __sighandler_t _handler)int sigaction(int sig, struct sigaction* act, struct sigaction* oact)</code></pre><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>信号是用户, 系统, 或者进程发送给目标进程的信息, 以通知目标进程某个状态的改变或者系统异常.<br>产生条件</p><ul><li>对于前台进程<br>用户可以通过输入特殊的终端字符来给它发送信号, CTRL+C 通常为一个中断信号 <code>SIGINT</code></li><li>系统异常<br>浮点异常和非法内存段的访问</li><li>系统状态变化<br>由alarm定时器到期将引起<code>SIGALRM</code>信号</li><li>运行kill命令或调用kill函数</li></ul><p><em>服务器必须处理(至少忽略) 一些常见的信号, 以免异常终止</em></p><p>中断系统调用?</p><h1 id="第十一章定时器"><a href="#第十一章定时器" class="headerlink" title="第十一章定时器"></a>第十一章定时器</h1><h2 id="socket选项SO-RCVTIMEO-和-SO-SNDTIMEO"><a href="#socket选项SO-RCVTIMEO-和-SO-SNDTIMEO" class="headerlink" title="socket选项SO_RCVTIMEO 和 SO_SNDTIMEO"></a>socket选项<code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code></h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/SO_RCVTIMEO%E5%92%8CSO_SNDTIMEO%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt=""></p><p>使用示例, 通过设置对应的SO_SNDTIMEO 得到超时后的路线</p><pre><code class="c++">int timeout_connect(const char* ip, const int port, const int sec){    struct sockaddr_in address{};    address.sin_family = AF_INET;    address.sin_port = htons(port);    address.sin_addr.s_addr = inet_addr(ip);    int sockfd = socket(PF_INET, SOCK_STREAM, 0);    exit_if(sockfd &lt; 0, &quot;socket error\n&quot;);    struct timeval timeout{};    timeout.tv_sec = sec;    timeout.tv_usec = 0;    socklen_t timeout_len = sizeof(timeout);    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, timeout_len);    int ret = connect(sockfd, (struct sockaddr*)&amp;address, sizeof(address));    if (ret == -1)    {        // 当 errno为EINPROGRESS 说明 等待了 10S后依然无法连接成功 实现了定时器        if (errno == EINPROGRESS)        {            printf(&quot;connecting timeout, process timeout logic\n&quot;);            return -1;        }        printf(&quot;error occur when connecting to server\n&quot;);        return -1;    }    return sockfd;}int main(int argc, char* argv[]){    exit_if(argc &lt;= 2, &quot;wrong number of parameters\n&quot;)    const char* ip = argv[1];    const int port = atoi(argv[2]);    int sockfd = timeout_connect(ip, port, 10);    if (sockfd &lt; 0)    {        return 1;    }    return 0;}</code></pre><h2 id="SIGALRM信号-基于升序链表的定时器"><a href="#SIGALRM信号-基于升序链表的定时器" class="headerlink" title="SIGALRM信号-基于升序链表的定时器"></a>SIGALRM信号-基于升序链表的定时器</h2><p>由alarm和setitimer函数设定的实时闹钟一旦超时, 将会触发SIGALRM信号, 用信号处理函数处理定时任务<br> 相关的代码放在了github上 代码还是很多的就不放上来了<a href="https://github.com/rjd67441/Notes-HighPerformanceLinuxServerProgramming/tree/master/12.%20%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%9511-2%E5%92%8C11-3%E5%8F%8A11-4%20%E9%93%BE%E8%A1%A8%E5%AE%9A%E6%97%B6%E5%99%A8%2C%20%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">连接</a></p><p>总结放在了 日记的博客上 链接后面再甩出来</p><h2 id="IO复用系统调用的超时参数"><a href="#IO复用系统调用的超时参数" class="headerlink" title="IO复用系统调用的超时参数"></a>IO复用系统调用的超时参数</h2><h2 id="高性能定时器"><a href="#高性能定时器" class="headerlink" title="高性能定时器"></a>高性能定时器</h2><h2 id="时间轮"><a href="#时间轮" class="headerlink" title="# 时间轮"></a># 时间轮</h2><h2 id="时间堆"><a href="#时间堆" class="headerlink" title="# 时间堆"></a># 时间堆</h2><h1 id="第十二章高性能IO框架库"><a href="#第十二章高性能IO框架库" class="headerlink" title="第十二章高性能IO框架库"></a>第十二章高性能IO框架库</h1><p>另出一篇博客</p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux高性能服务器-初级部分</title>
      <link href="/2019/08/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95100-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/"/>
      <url>/2019/08/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95100-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>开头选了这本书, 看到这本书是他人总结三大本后自己写的, 先求个理解大概.<br>话说别人推荐的c++服务器咋都是c语言…..<br>2019年8月17日20:37:53</p><p>每学习一部分就写一个demo</p><a id="more"></a><p>2020年7月16日12:43:41</p><p>上面那个more标签让我想起了我第一个hexo博客的主题.<br>大二暑假了, 距离这篇博客写下已经将近一年了. 时间过得真快, 唯一不变的就是自己依然的菜..<br>也理解为什么C++服务器推荐的C语言</p><p>这里将第五章后面的内容整理下.<br>这算是我第一次写的博客吧, 之前写的时候写的过于详细和冗余了. 目前有了一点基础, 所以这次重新读是为了<br>把博客和书读薄</p><p>目前第五章后的博客有13000个汉字和44000个字母. 看看整理完毕后有多少吧</p><h2 id="第五章Linux网络编程基础API"><a href="#第五章Linux网络编程基础API" class="headerlink" title="第五章Linux网络编程基础API"></a>第五章Linux网络编程基础API</h2><h3 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h3><p>字节序分为 <code>大端字节序</code>和<code>小端字节序</code><br>由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序</p><p>为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).<br>这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序</p><p><strong>基础连接</strong><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg" alt=""><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg" alt=""></p><p>字节序转换</p><pre><code class="c++">#include &lt;netinet/in.h&gt;unsigned long int htonl (unsigned long int hostlong); // host to network longunsigned short int htons (unsigned short int hostlong); // host to network shortunsigned long int ntohl (unsigned long int netlong);unsigned short int ntohs (unsigned short int netlong);</code></pre><p>点分十进制地址和网络地址转换<br>程序需要使用网络地址 给人察看需要使用点分十进制 灵活转换</p><pre><code class="c++">#include &lt;arpa/inet.h&gt;// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONEin_addr_t  inet_addr(const char* strptr);// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0int inet_aton(const char* cp, struct in_addr* inp);// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖char* inet_ntoa(struct in_addr in); // src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1int inet_pton(int af, const char * src, void* dst);// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)const char* inet_ntop(int af, const void*  src, char* dst, socklen_t cnt);</code></pre><p>socket 三部曲</p><pre><code class="c++">// 创建 命名 监听 socket# include &lt;sys/socket.h&gt;// domain指定使用那个协议族 PF_INET PF_INET6// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)// 有两个使用较多的选项SOCK_NONBLOCK 设置非阻塞// SOCK_CLOEXEC 使用fork创建子进程的时候在子进程中关闭该socket// protocol设置为默认的0// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1int socket(int domain, int type, int protocol);// socket为socket文件描述符// my_addr 为地址信息// addrlen为socket地址长度// 成功返回0 失败返回 -1// 这里细说还有个EADDRINUSE(被绑定的地址正在使用如TIME_WAIT状态)// 与之搭配的解决方式 是使用setsockopt设置SO_REUSEADDR为trueint bind(int socket, const struct sockaddr* my_addr, socklen_t addrlen);// backlog表示队列最大的长度int listen(int socket, int backlog);</code></pre><p>服务器</p><pre><code class="c++">// 接受连接 失败返回-1 成功时返回socketint accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen)</code></pre><p>客户端</p><pre><code class="c">// 发起连接#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;// 第三个参数为 地址指定的长度// 成功返回0 失败返回-1int connect(int sockfd, const struct sockaddr * serv_addr, socklen_t addrlen);</code></pre><p>连接关闭</p><pre><code class="c++">// 关闭连接#include &lt;unistd.h&gt;// 参数为保存的socket// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)int close(int fd);// 立即关闭#include &lt;sys/socket.h&gt;// 第二个参数为可选值 //    SHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃//    SHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去//    SHUT_RDWR 同时关闭读和写// 成功返回0 失败为-1 设置errnoint shutdown(int sockfd, int howto)// 1. close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列// 2. close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕</code></pre><p>基础TCP</p><pre><code class="c">#include&lt;sys/socket.h&gt;#include&lt;sys/types.h&gt;// 读取sockfd的数据// buf 指定读缓冲区的位置// len 指定读缓冲区的大小// flags 参数较多// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1ssize_t recv(int sockfd, void *buf, size_t len, int flags);// 发送ssize_t send(int sockfd, const void *buf, size_t len, int flags);</code></pre><table><thead><tr><th>选项名</th><th>含义</th><th>可用于发送</th><th>可用于接收</th></tr></thead><tbody><tr><td>MSG_CONFIRM</td><td>指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)</td><td>Y</td><td>N</td></tr><tr><td>MSG_DONTROUTE</td><td>不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中)</td><td>Y</td><td>N</td></tr><tr><td>MSG_DONTWAIT</td><td>非阻塞</td><td>Y</td><td>Y</td></tr><tr><td>MSG_MORE</td><td>告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率</td><td>Y</td><td>N</td></tr><tr><td>MSG_WAITALL</td><td>读操作一直等待到读取到指定字节后才会返回</td><td>N</td><td>Y</td></tr><tr><td>MSG_PEEK</td><td>看一下内缓存数据, 并不会影响数据</td><td>N</td><td>Y</td></tr><tr><td>MSG_OOB</td><td>发送或接收紧急数据</td><td>Y</td><td>Y</td></tr><tr><td>MSG_NOSIGNAL</td><td>向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号</td><td>Y</td><td>N</td></tr></tbody></table><p>基础UDP</p><pre><code class="c">#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen);ssize_t sendto(int sockfd, const void* buf, size_t len, ing flags, const struct sockaddr* dest_addr, socklen_t addrlen);</code></pre><p>通用读写函数</p><pre><code class="c">#inclued &lt;sys/socket.h&gt;ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);struct msghdr{/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/    void* msg_name;     socklen_t msg_namelen;    /* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中     * 的数据将一并发送称为集中写(gather write);    */    struct iovec* msg_iov;    int msg_iovlen; /* 分散内存块的数量*/    void* msg_control; /* 指向辅助数据的起始位置*/    socklen_t msg_controllen; /* 辅助数据的大小*/    int msg_flags; /* 复制函数的flags参数, 并在调用过程中更新*/};struct iovec{    void* iov_base /* 内存起始地址*/    size_t iov_len /* 这块内存长度*/}</code></pre><p>其他Api</p><pre><code class="c">#include &lt;sys/socket.h&gt;// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, // 是的话返回1, 不是返回0// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. int sockatmark(int sockfd);// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1// getpeername 获取远端的信息, 同上int getsockname(int sockfd, struct sockaddr* address, socklen_t* address_len);int getpeername(int sockfd, struct sockaddr* address, socklen_t* address_len);</code></pre><p>重要 socket属性设置</p><pre><code class="c++">/* 以下函数头文件均相同*/// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度// 成功时返回0 失败返回-1int getsockopt(int sockfd, int level, int option_name, void* option_value,                         socklen_t restrict option_len);int setsockopt(int sockfd, int level, int option_name, void* option_value,                         socklen_t restrict option_len);</code></pre><pre><code class="c">struct linger{    int l_onoff /* 开启非0, 关闭为0*/    int l_linger; /* 滞留时间*/    /*    * 当onoff为0的时候此项不起作用, close调用默认行为关闭socket    * 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段    * 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关     * 闭, 如果是处于非阻塞则立即关闭    */};</code></pre><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/socket%E9%80%89%E9%A1%B9.jpg" alt=""></p><p><strong>网络信息API</strong></p><pre><code class="c">#include &lt;netdb.h&gt;// 通过主机名查找ipstruct hostent* gethostbyname(const char* name);// 通过ip获取主机完整信息 // type为IP地址类型 AF_INET和AF_INET6struct hostent* gethostbyaddr(const void* addr, size_t len, int type);struct hostent{  char *h_name;            /* Official name of host.  */  char **h_aliases;        /* Alias list.  */  int h_addrtype;        /* Host address type.  */  int h_length;            /* Length of address.  */  char **h_addr_list;        /* List of addresses from name server.  */}int main(int argc, char* argv[]){    if (argc != 2)    {        printf(&quot;非法输入\n&quot;);        exit(0);    }    char* name = argv[1];    struct hostent *hostptr{};    hostptr = gethostbyname(name);    if (hostptr == nullptr)    {        printf(&quot;输入存在错误 或无法获取\n&quot;);        exit(0);    }    printf(&quot;Official name of hostptr: %s\n&quot;, hostptr-&gt;h_name);    char **pptr;    char inet_addr[INET_ADDRSTRLEN];    printf(&quot;Alias list:\n&quot;);    for (pptr = hostptr-&gt;h_aliases; *pptr != nullptr; ++pptr)    {        printf(&quot;\t%s\n&quot;, *pptr);    }    switch (hostptr-&gt;h_addrtype)    {        case AF_INET:        {            printf(&quot;List of addresses from name server:\n&quot;);            for (pptr = hostptr-&gt;h_addr_list; *pptr != nullptr; ++pptr)            {                printf(&quot;\t%s\n&quot;,                        inet_ntop(hostptr-&gt;h_addrtype, *pptr, inet_addr, sizeof(inet_addr)));            }            break;        }        default:        {            printf(&quot;unknow address type\n&quot;);            exit(0);        }    }    return 0;}/*./run baidu.comOfficial name of hostptr: baidu.comAlias list:List of addresses from name server:    39.156.69.79    220.181.38.148*/</code></pre><p>以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科</p><p>Service文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下</p><ul><li>通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(“serve”,”tcp”)获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名</li><li>如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的<pre><code class="c">#include &lt;netdb.h&gt;// 根据名称获取某个服务的完整信息struct servent getservbyname(const char* name, const char* proto);</code></pre></li></ul><p>// 根据端口号获取服务信息<br>struct servent getservbyport(int port, const char* proto);</p><p>struct servent<br>{<br>    char* s_name; /* 服务名称<em>/<br>    char ** s_aliases; /</em> 服务的别名列表<em>/<br>    int s_port; /</em> 端口号<em>/<br>    char</em> s_proto; /* 服务类型, 通常为TCP或UDP*/<br>}</p><pre><code>```c#include &lt;netdb.h&gt;// 内部使用的gethostbyname 和 getserverbyname// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)// service 用于接收服务名, 字符串表示的十进制端口号// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果// result 指向一个链表, 用于存储getaddrinfo的反馈结果int getaddrinfo(const char* hostname, const char* service, const struct addrinfo* hints, struct addrinfo** result)struct addrinfo{    int ai_flags;    int ai_family;    int ai_socktype; /* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/    int ai_protocol;    socklen_t ai_addrlen;    char* ai_canonname; /* 主机的别名*/    struct sockaddr* ai_addr; /* 指向socket地址*/    struct addrinfo* ai_next; /* 指向下一个结构体*/}// 需要手动的释放堆内存void freeaddrinfo(struct addrinfo* res);</code></pre><p><img src="https://ftp.bmp.ovh/imgs/2019/08/7ebedb14d8eedeac.png" alt=""></p><pre><code class="c">#include &lt;netdb.h&gt;// host 存储返回的主机名// serv存储返回的服务名int getnameinfo(const struct sockaddr* sockaddr, socklen_t addrlen, char* host, socklen_t hostlen, char* serv    socklen_t servlen, int flags);</code></pre><p><img src="https://ftp.bmp.ovh/imgs/2019/08/bc7196e9a30d5152.png" alt=""></p><p>测试<br>使用</p><pre><code class="shell">telnet ip port #来连接服务器的此端口netstat -nt | grep port #来查看此端口的监听</code></pre><h2 id="第六章高级IO函数"><a href="#第六章高级IO函数" class="headerlink" title="第六章高级IO函数"></a>第六章高级IO函数</h2><p>Linux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率<br><em>文件描述符</em><br>文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。<br>STDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件</p><h3 id="创建文件描述符-pipe-dup-dup2-splice"><a href="#创建文件描述符-pipe-dup-dup2-splice" class="headerlink" title="创建文件描述符 - pipe dup dup2 splice"></a>创建文件描述符 - pipe dup dup2 splice</h3><p><strong>pipe函数</strong><br>这个函数可用于创建一个管道, 实现进程间的通信. </p><pre><code class="c">// 函数定义// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组// 失败返回-1 errno#include &lt;unistd.h&gt;int pipe(int fd[2]);</code></pre><pre><code class="c">// 双向管道// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socketpair(int domain, int type, int protocol, int fd[2]);</code></pre><p>学习了后面的内容了解到了进程间通信, 回来补上一个例子</p><pre><code class="c">int main(){    int fds[2];    socketpair(PF_UNIX, SOCK_STREAM, 0, fds);    int pid = fork();    if (pid == 0)    {        close(fds[0]);        char a[] = &quot;123&quot;;        send(fds[1], a, strlen(a), 0);    }    else if (pid &gt; 0)    {        close(fds[1]);        char b[20] {};        recv(fds[0], b, 20, 0);        printf(&quot;%s&quot;, b);    }}</code></pre><p><strong>dup和dup2函数</strong><br>复制一个现有的文件描述符</p><pre><code class="c">#include &lt;unistd.h&gt;// 返回的文件描述符总是取系统当前可用的最小整数值int dup(int oldfd);// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭// 如果newfd==oldfd 则不关闭newfd直接返回int dup2(int oldfd, int newfd);</code></pre><p>dup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.<br>回来补上例子, 这个例子由于关掉了<code>STDOUT_FILENO</code>dup最小的即为<code>STDOUT_FILENO</code>所以<br>标准输出都到了这个文件之中</p><pre><code class="c">int main(){    int filefd = open(&quot;/home/lsmg/1.txt&quot;, O_WRONLY);    close(STDOUT_FILENO);    dup(filefd);    printf(&quot;123\n&quot;);    exit(0);}</code></pre><h3 id="读写数据-readv-writev-mmap-munmap"><a href="#读写数据-readv-writev-mmap-munmap" class="headerlink" title="读写数据 - readv writev mmap munmap"></a>读写数据 - readv writev mmap munmap</h3><p><strong>readv/writev</strong></p><pre><code class="c">#include &lt;sys/uio.h&gt;// count 为 vector的长度, 即为有多少块内存// 成功时返回写入\读取的长度 失败返回-1ssize_t readv(int fd, const struct iovec* vector, int count);ssize_t writev(int fd, const struct iovec* vector, int count);struct iovec {    void* iov_base /* 内存起始地址*/    size_t iov_len /* 这块内存长度*/}</code></pre><p>回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中<br>使用hexdump查看这个文件<code>0000000 86a0 0001</code>可以看到<code>186a0</code>即为100000</p><pre><code class="c">// 2020年1月7日16:52:11int main(){    int file = open(&quot;/home/lsmg/1.txt&quot;, O_WRONLY);    int temp = 100000;    iovec temp_iovec{};    temp_iovec.iov_base = &amp;temp;    temp_iovec.iov_len = sizeof(temp);    writev(file, &amp;temp_iovec, 1);}</code></pre><p>sendfile函数</p><pre><code class="c">#include &lt;sys/sendfile.h&gt;// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取ssize_t sendfile(int out_fd, int in_fd, off_t* offset, size_t count);O_RDONLY只读模式O_WRONLY只写模式O_RDWR读写模式int open(file_name, flag);</code></pre><p>stat结构体, 可用fstat生成, <strong>简直就是文件的身份证</strong></p><pre><code class="c">#include &lt;sys/stat.h&gt;struct stat{    dev_t       st_dev;     /* ID of device containing file -文件所在设备的ID*/    ino_t       st_ino;     /* inode number -inode节点号*/    mode_t      st_mode;    /* protection -保护模式?*/    nlink_t     st_nlink;   /* number of hard links -链向此文件的连接数(硬连接)*/    uid_t       st_uid;     /* user ID of owner -user id*/    gid_t       st_gid;     /* group ID of owner - group id*/    dev_t       st_rdev;    /* device ID (if special file) -设备号，针对设备文件*/    off_t       st_size;    /* total size, in bytes -文件大小，字节为单位*/    blksize_t   st_blksize; /* blocksize for filesystem I/O -系统块的大小*/    blkcnt_t    st_blocks;  /* number of blocks allocated -文件所占块数*/    time_t      st_atime;   /* time of last access -最近存取时间*/    time_t      st_mtime;   /* time of last modification -最近修改时间*/    time_t      st_ctime;   /* time of last status change - */};</code></pre><p><strong>身份证</strong>生成函数</p><pre><code class="c">// 第一个参数需要调用open生成文件描述符// 下面其他两个为文件全路径int fstat(int filedes, struct stat *buf);// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息int stat(const char *path, struct stat *buf);int lstat(const char *path, struct stat *buf);/** ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全* 删除就可以正常访问* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说* `文件`本身就类似快捷方式, 指向文件存在的区域.*/</code></pre><p> <strong>mmap和munmap函数</strong></p><p><code>mmap</code>创建一块进程通讯共享的内存(可以将文件映射入其中), <code>munmap</code>释放这块内存</p><pre><code class="c">#include &lt;sys/mman.h&gt;// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)// flag参数 内存被修改后的行为// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略// 成功返回区域指针, 失败返回 -1void* mmap(void* start, size_t length, int port, int flags, int fd, off_t offset);// 成功返回0 失败返回-1int munmap(void* start, size_t length);</code></pre><p><strong>splice函数</strong><br>用于在两个文件名描述符之间移动数据, 0拷贝操作</p><pre><code class="c">#include &lt;fcntl.h&gt;// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置// len为指定移动的数据长度, flags参数控制数据如何移动.// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????ssize_t splice(int fd_in, loff_t* off_in, int fd_out, loff_t* off_out, size_t len, unsigned int flags);// 使用splice函数  实现echo服务器int main(int argc, char* argv[]){    if (argc &lt;= 2)    {        printf(&quot;the parmerters is wrong\n&quot;);        exit(errno);    }    char *ip = argv[1];    int port = atoi(argv[2]);    printf(&quot;the port is %d the ip is %s\n&quot;, port, ip);    int sockfd = socket(PF_INET, SOCK_STREAM, 0);    assert(sockfd &gt;= 0);    struct sockaddr_in address{};    address.sin_family = AF_INET;    address.sin_port = htons(port);    inet_pton(AF_INET, ip, &amp;address.sin_addr);    int ret = bind(sockfd, (sockaddr*)&amp;address, sizeof(address));    assert(ret != -1);    ret = listen(sockfd, 5);    int clientfd{};    sockaddr_in client_address{};    socklen_t client_addrlen = sizeof(client_address);    clientfd = accept(sockfd, (sockaddr*)&amp;client_address, &amp;client_addrlen);    if (clientfd &lt; 0)    {        printf(&quot;accept error\n&quot;);    }    else    {        printf(&quot;a new connection from %s:%d success\n&quot;, inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));        int fds[2];        pipe(fds);        ret = splice(clientfd, nullptr, fds[1], nullptr, 32768, SPLICE_F_MORE);        assert(ret != -1);        ret = splice(fds[0], nullptr, clientfd, nullptr, 32768, SPLICE_F_MORE);        assert(ret != -1);        close(clientfd);    }    close(sockfd);    exit(0);}</code></pre><h2 id="第七章Linux服务器程序规范"><a href="#第七章Linux服务器程序规范" class="headerlink" title="第七章Linux服务器程序规范"></a>第七章Linux服务器程序规范</h2><ul><li>Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)</li><li>Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.</li><li>Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.</li><li>Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.</li><li>Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.</li><li>Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力</li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><pre><code class="shell">sudo service rsyslog restart // 启动守护进程</code></pre><pre><code class="c">#include &lt;syslog.h&gt;// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或// - 0 LOG_EMERG  /* 系统不可用*/// - 1 LOG_ALERT   /* 报警需要立即采取行动*/// - 2 LOG_CRIT /* 非常严重的情况*/// - 3 LOG_ERR  /* 错误*/// - 4 LOG_WARNING /* 警告*/// - 5 LOG_NOTICE /* 通知*/// - 6 LOG_INFO /* 信息*///  -7 LOG_DEBUG /* 调试*/void syslog(int priority, const char* message, .....);// ident 位于日志的时间后 通常为名字// logopt 对后续 syslog调用的行为进行配置// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/// facility参数可以修改syslog函数中的默认设施值void openlog(const char* ident, int logopt, int facility);// maskpri 一共八位 0000-0000// 如果将最后一个0置为1 表示 记录0级别的日志// 如果将最后两个0都置为1 表示记录0和1级别的日志// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志int setlogmask(int maskpri);// 关闭日志功能void closelog();</code></pre><h3 id="用户信息-切换用户"><a href="#用户信息-切换用户" class="headerlink" title="用户信息, 切换用户"></a>用户信息, 切换用户</h3><p>UID - 真实用户ID<br>EUID - 有效用户ID - 方便资源访问<br>GID - 真实组ID<br>EGID - 有效组ID</p><pre><code class="c">#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;uid_t getuid();uid_t geteuid();gid_t getgid();gid_t getegid();int setuid(uid_t uid);int seteuid(uid_t euid);int setgid(gid_t gid);int setegid(gid_t gid);</code></pre><p>可以通过 <code>setuid</code>和<code>setgid</code>切换用户 <strong>root用户uid和gid均为0</strong></p><h3 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h3><p>PGID - 进程组ID(Linux下每个进程隶属于一个进程组)</p><p>#include &lt;unistd.h&gt;<br>pid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1<br>int setpgid(pid_t pid, pid_t pgid);</p><p><strong>会话</strong><br>一些有关联的进程组将形成一个会话<br>略过</p><p><strong>查看进程关系</strong><br>ps和less</p><p><strong>资源限制</strong><br>略<br><strong>改变目录</strong><br>略</p><h2 id="第八章高性能服务器程序框架"><a href="#第八章高性能服务器程序框架" class="headerlink" title="第八章高性能服务器程序框架"></a>第八章高性能服务器程序框架</h2><p><strong>服务器模型-CS模型</strong></p><p><strong>优点</strong></p><ul><li>实现起来简单</li></ul><p><strong>缺点</strong></p><ul><li>服务器是通信的中心, 访问过大的时候会导致响应过慢</li></ul><p>模式图<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%BE8-2%20TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt=""></p><p>编写的demo 没有用到fork函数. 后续待完善</p><p><strong>服务器框架 IO模型</strong></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png" alt=""></p><p>这个模型大概能够理解, 自己也算是学了半年的Javaweb.</p><p>socket在创建的时候默认是阻塞的, 不过可以通过传<code>SOCK_NONBLOCK</code>参解决<br>非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会<code>返回-1</code> 所以需要通过<code>errno</code>来区分这些错误.<br><strong>事件未发生</strong><br>accept, send,recv errno被设置为 <code>EAGAIN(再来一次)</code>或<code>EWOULDBLOCK(期望阻塞)</code><br>connect 被设置为 <code>EINPROGRESS(正在处理中)</code></p><p>需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能</p><p>常用IO复用函数 <code>select</code> <code>poll</code> <code>epoll_wait</code> 将在第九章后面说明<br>信号将在第十章说明</p><p><strong>两种高效的事件处理模式和并发模式</strong><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Reactor%E6%A8%A1%E5%BC%8F.png" alt=""></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Proactor%E6%A8%A1%E5%BC%8F.png" alt=""></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%90%8C%E6%AD%A5IO%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%9A%84Proactor%E6%A8%A1%E5%BC%8F.png" alt=""></p><p>程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).<br>前者使用并发编程反而会降低效率, 后者则会提升效率<br>并发编程有多进程和多线程两种方式</p><p>并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.<br>服务器主要有两种并发模式</p><ul><li>半同步/半异步模式</li><li>领导者/追随者模式</li></ul><p><strong>半同步/半异步模式</strong><br>在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)</p><p>而在这里(并发模式)<br>同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程<br>异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5.png" alt=""></p><p>服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式<br>同步线程 - 处理客户逻辑, 处理请求队列中的对象<br>异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列</p><p>半同步/半异步模式 存在变体 <code>半同步/半反应堆模式</code><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png" alt=""></p><p>异步线程 - 主线程 - 负责监听所有socket上的事件</p><p><strong>领导者/追随者模式</strong><br>略</p><p><strong>高效编程方法 - 有限状态机</strong></p><pre><code class="c">// 状态独立的有限状态机STATE_MACHINE(Package _pack) {    PackageType _type = _pack.GetType();    switch(_type) {        case type_A:            xxxx;            break;        case type_B:            xxxx;            break;    }}// 带状态转移的有限状态机STATE_MACHINE() {    State cur_State = type_A;    while(cur_State != type_C) {        Package _pack = getNewPackage();        switch(cur_State) {            case type_A:                process_package_state_A(_pack);                cur_State = type_B;                break;            case type_B:                xxxx;                cur_State = type_C;                break;        }    }}</code></pre><p>花了小一个小时 终于一个字母一个字母的抄完了那个5000多字的代码<br>@2019年9月8日22:08:46@</p><h3 id="提高服务器性能的其他建议-池-数据复制-上下文切换和锁"><a href="#提高服务器性能的其他建议-池-数据复制-上下文切换和锁" class="headerlink" title="提高服务器性能的其他建议 池 数据复制 上下文切换和锁"></a>提高服务器性能的其他建议 池 数据复制 上下文切换和锁</h3><p><strong>池</strong> - 用空间换取时间<br>进程池和线程池</p><p><strong>数据复制</strong> - 高性能的服务器应该尽量避免不必要的复制</p><p><strong>上下文切换和锁</strong><br>减少<code>锁</code>的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.</p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++Primer学习</title>
      <link href="/2019/08/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9580-CPPPrimer/"/>
      <url>/2019/08/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9580-CPPPrimer/</url>
      
        <content type="html"><![CDATA[<h1 id="TOOD"><a href="#TOOD" class="headerlink" title="TOOD"></a>TOOD</h1><p>explicit 参见7.5.4节 265</p><p>运算符优先级………..</p><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><p><strong>char 在默认情况下, 既不是有符号. 也不是无符号.</strong></p><pre><code class="c++">char a; // 此时a可能是 signed char 也可能是 unsigned char 可能会在不同系统之前产生错误// 可以显式声明, 来确保不会出现此错误signed char a;unsigned char a; </code></pre><p><strong>输入</strong></p><pre><code class="c++">char name[10];cin.getline(name, 10); // 可以读取换行符, 但不保存cin.get(name, 10); // 不读取换行符, 可能导致get到换行符// 空行和超出长度问题 将在后面说明</code></pre><p>运算符优先级<br><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg" alt=""></p><p><strong>基础的数组</strong></p><pre><code class="c++">int a[] = {1, 2, 3, 4};// 下方由于 new 只是返回一个地址所以用 int* 接收 int* b = new int[4];cout &lt;&lt; a[0] &lt;&lt; endl; // 1cout &lt;&lt; *(a + 1) &lt;&lt; endl;// 2</code></pre><p><strong>对指针解引用</strong><br>第一印象是 解除引用, 然而并不是</p><pre><code class="c++">/*&quot;*&quot;的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。比如int a=10; int *p=&amp;a;cout&lt;&lt;*p&lt;&lt;endl; 输出a的值，就是解引用操作。*/</code></pre><p><strong>常用 宏</strong><br>| 定义 | 说明 |<br>| —– | —– |<br>| <code>__FILE__</code> | 存放文件名的字符串字面值 |<br>| <code>__LINE__</code> | 存放当前行号的整形字面值 |<br>| <code>__TIME__</code> | 存放文件编译时间的字符串字面量 |<br>| <code>__DATE__</code> | 存放文件编译日期的字符串字面值 |<br>| <code>__VA_ARGS__</code> | 用来接受函数参数中<code>...</code>, 类似printf函数, 这个宏只能在宏中使用 |</p><h1 id="第一部分-基础知识"><a href="#第一部分-基础知识" class="headerlink" title="第一部分 基础知识"></a>第一部分 基础知识</h1><h2 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h2><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><strong>2.2 与钱相关的数据存储 使用的类型</strong><br>银行相关钱相关的数据 保存 使用整形, 不太可能使用浮点数. 浮点数运算可能会出现误差<br>使用<code>1</code>代表<code>1RMB</code> 或者使用<code>1</code>代表<code>0.01RMB</code></p><p><strong>2.9 解释下列定义 对于非法说出错在哪里</strong></p><pre><code class="c++">std::cin &gt;&gt; int input_value; // error: expected primary-expression before ‘int’int i1 = {3.14};// narrowing conversion of ‘3.1400000000000001e+0’ from ‘double’ to ‘int’ inside { } [-Wnarrowing]double salary = wage = 9999.99;// error: ‘wage’ was not declared in this scope 如果定义wage则语句不报错int i2 = 3.14;</code></pre><p><strong>2.10 下列变量的初始值是什么</strong></p><p>内置类型变量未被显示初始化  函数体之外初始化为0  函数体内是未被定义的<br>类    一般都拥有默认的初始化方式</p><pre><code class="c++">std::string g_str; // 全局变量 且拥有默认初始化方式 为空字符串int g_int; //     全局变量 初值为0int main(){    int local_int; // 局部变量 未定义    std::string local_str; // 拥有默认初始化方式 空字符串}</code></pre><p><strong>2.14 下面代码输出什么</strong><br>起初一看 以为会是循环到溢出 直接就把代码码了下来运行 发现是正常的.<br>就算for中 <code>int i = 0</code>改为<code>i = 0</code>依然不会溢出<br>for的i覆盖了外面的i</p><pre><code class="c++">#include &lt;iostream&gt;int main(){    int i = 100, sum = 0;    for (int i = 0; i != 10; ++i)    {        sum += i;    }    std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; std::endl; //$ 100 45    return 0;}</code></pre><p>输出<del>~</del></p><pre><code class="c++">#include &lt;iostream&gt;int main(){    int i, &amp;ri = i;    i = 5;    ri = 10;    std::cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ri &lt;&lt;std::endl; //$ 10 10    return 0;}</code></pre><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>一个形如42的值被称为<code>字面值常量(literal)</code>, 这样的值你一看到(面), 就知道是多少</p><p>scope 作用域</p><h3 id="无符号"><a href="#无符号" class="headerlink" title="无符号"></a>无符号</h3><p><strong>unsigned int和int运算的时候 自动转换为unsigned</strong></p><pre><code class="c++">unsigned int a = 10;int b = -11;std::cout &lt;&lt; a + b &lt;&lt; std::endl; //$ 4294967295</code></pre><p><strong>警惕for循环中的 无符号类型</strong><br>size_t</p><h3 id="声明定义初始化赋值"><a href="#声明定义初始化赋值" class="headerlink" title="声明定义初始化赋值"></a>声明定义初始化赋值</h3><p><strong>声明</strong><br>声明不是定义, 可以多次声明<br>指明变量的type和name.<br>对于变量的声明需要使用<code>extern</code>关键字, 如果使用了<code>extern</code>关键字的同时初始化就成了定义</p><pre><code class="c++">int i; // 声明并定义 未初始化extern int a; // 声明extern int a = 10; // 定义 声明 初始化</code></pre><p><strong>定义</strong><br>声明并定义, 只能定义一次<br>定义的时候需要指定type和name. 申请空间, 可能进行初始化.</p><p><strong>初始化 赋值</strong><br>初始化 不是赋值<br>初始化是创建变量时 赋予其一个初始值<br>赋值是擦除当前的值 赋予新的值</p><p><strong>变量类型选择</strong><br>数值范围超过<code>int</code> 建议使用<code>long long</code>, <code>long</code>的长度仅是大于等于<code>int</code><br>char类型可能是 <code>signed</code> 还可能是<code>unsigned</code> 如果针对范围有特殊要求 应该注明是否有无符号<br>浮点运算建议使用double float经常精度不够, 然而两者运算效率却相差无几. <code>long double</code>反而绝大多数情况用不到</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const变量必须被初始化</p><p>所谓指向常量的引用或指针, 不过是指针或引用自以为是罢了, 他们觉得自己指向了常量, 所以自觉不去修改</p><p>顶层const: 表示指针本身是常量<br>底层const: 表示指针指向是一个常量<br>指针本身是一个对象, 他可以指向另一个对象. 因此, 指针本身是不是常量, 以及指针所向是不是一个常量就是两个独立的问题.</p><p>执行拷贝的时候, 常量是顶层const还是底层const区别明显, 顶层const可以视为不见<br>然而底层const的限制不能忽视, 拷入和拷出对象必须具有相同的底层const资格</p><p><strong>指针常量和类型别名</strong></p><pre><code class="c++">typedef char* pstring;const pstring cstr = 0;</code></pre><p>这里pstring是指向char的指针 const pstring是指向char的常量指针 指针指向不能变<br>而不是简单地将pstring替换掉</p><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>在一个复杂系统中, 很难分辨一个初始值到底是不是常量表达式.<br>当然可以定义一个const变量 并把初始值设定为我们认为的常量表达式, 然而实际依然有非常量表达式的情况</p><p>C++11标准 将变量声明为constexpr由编译器来验证变量是否是一个常量表达式</p><pre><code class="c++">constexpr int mm = 20; // 20是常量表达式constexpr int yy = mm + 1; // mf + 1是常量表达式constexpr int sz = size(); // 当size是一个constexpr函数时才是正确的声明语句</code></pre><p>指针和引用都能定义成constexpr, 但初始值受到严格限制.<br>constexpr指针的初始值必须是nullptr或者0 或者存储于某个固定地址中的对象(位于所有函数体之外)<br>constexpr引用能绑定到 某个固定地址中的对象</p><p><strong>decltype和引用</strong><br><code>decltype((i)) d</code> 双层括号是引用<br><code>decltype(i) d</code>单层括号只有i是引用的时候 d才是引用</p><h2 id="第三章-字符串-向量和数组"><a href="#第三章-字符串-向量和数组" class="headerlink" title="第三章 字符串 向量和数组"></a>第三章 字符串 向量和数组</h2><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><p><strong>3.34</strong><br>p1和p2指向同一数组中的元素, 则下面程序的功能是什么? 什么情况下程序是非法的?<br>p1 += p2 - p1;<br>将p1移动到p2的位置  不会非法……….</p><h3 id=""><a href="#" class="headerlink" title="{} = ()"></a>{} = ()</h3><pre><code class="c++">string a = &quot;cccc&quot;;  // 只有一个参数值string b(10, &#39;c&#39;); // 拥有两个参数值 10和&#39;c&#39;</code></pre><p>使用=, 进行拷贝初始化 只能提供一个初始值<br>使用(), 进行直接初始化, 可以提供多个初始值进行初始化</p><pre><code class="c++">class A{  int a1 = 10;  int a2(10);  // temp.cpp:4:12: error: expected identifier before numeric constant  // int a2(10);  // temp.cpp:4:12: error: expected ‘,’ or ‘...’ before numeric constant  int a3{10};}</code></pre><p>类内初始值 不能使用小括号</p><p>列表初始化只能放在花括号中 </p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector中不能保存引用, 因为使用引用就必须初始化.</p><p>设想, 你设置了vector包含十个元素, 这十个空间就必须被初始化,<br>然而引用必须要绑定到具体的对象上, 此时却没有对象进行绑定</p><p>再者如果容器复制的时候 引用怎么复制?</p><pre><code class="c++">vector&lt;int&gt; v1(10); // 10个元素, 全为0vector&lt;int&gt; v2{10}; // 一个元素, 为10vector&lt;int&gt; v3(10, 1); // 10个元素, 全为1vector&lt;int&gt; v4{10, 1}; // 两个元素, 10和1// -----------------------------------------vector&lt;string&gt; v5{&quot;hi&quot;}; // 列表初始化 有一个元素vector&lt;string&gt; v6(&quot;hi&quot;); // 错误不能使用字符串字面值构建vector元素vector&lt;string&gt; v7{10}; // 10个默认初始化的对象vector&lt;string&gt; v8{10, &quot;hi&quot;}; // 十个值为&quot;hi&quot;的元素</code></pre><p>因为不能使用int来初始化string对象, 列表初始化要求列表值类型与尖括号种类型相同<br>v7和v8并不是列表初始化, 而是转去尝试用默认值(默认值????)初始化</p><p>这里感觉有点?去看了下英文原版<br>the compiler looks for<br>other ways to initialize the object from the given values.</p><p><strong>迭代器</strong><br>使用的时候注意迭代器失效, </p><h3 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h3><pre><code class="c++">int (*array_ptr)[10] = &amp;arr; // 指向十个整数的数组int (&amp;array_ref)[10] = arr; // 十个整数数组的引用</code></pre><pre><code class="c++">int a[] = {0, 1, 2, 3, 4, 5, 6, 7};auto a1(a); // a1是指针类型decltype(a) a2; //a2是有八个元素的数组int* b = std::begin(a); // 指向首元素int* c = std::end(a); // 指向最后一个元素的后一位ptrdiff_t d = c - b; // ptrdiff_t 定义在cstddef中int* p = &amp;a[2];int k = p[-1];// 内置下标运算符所用的索引值不是无符号型 可以为负</code></pre><h2 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h2><p>当一个对象被用作右值的时候, 使用的是对象的值(内容)<br>当一个对象被用做左值的时候, 使用的是对象的身份(在内存中的位置)</p><p>如果表达式的求值结果是左值, decltype作用于该表达式得到一个引用类型.</p><p><code>int* p</code><br>解引用运算符生成左值 <code>decltype(*p)</code>得到的是<code>int&amp;</code><br>取地址运算符生成右值 <code>decltype(&amp;p)</code>的结果是<code>int**</code></p><p>大多数运算符没有规定按照什么顺序求值<br><code>int i = f1() * f2()</code><br>这两函数的调用顺序是未定义的</p><p>只有四种运算符规定了运算对象的求值顺序<br>短路求值<br><code>&amp;&amp;</code> 从左到右<br><code>||</code> 从左到右</p><p><code>?:</code><br><code>,</code> 逗号运算符 从左到右 首先求值左侧然后丢掉结果 真正返回的是右侧结果</p><p>书写表达式的建议</p><ol><li>拿不准的时候最好使用括号来组合表达式. 括号不香吗?</li><li>如果改变了某个运算对象的值, 在表达使得其他地方就不要再使用这个运算对象</li></ol><p><code>(-m) / n</code> 和 <code>m / (-n)</code> 等于 <code>-(m / n)</code><br><code>m % (-n)</code> 等于 <code>m % n</code><br><code>(-m) % n</code> 等于 <code>-(m % n)</code></p><pre><code class="c++">int ival, jvalival = jval = 0;</code></pre><p>赋值运算符右结合, 所以右侧的<code>jval = 0</code>是左侧赋值运算符的右侧运算对象<br>又因为赋值运算符返回的是其左侧运算对象, 所以右侧赋值运算符的结果(Jval)赋给了ival</p><p>赋值运算符的优先级低于关系运算符, 所以条件语句中, 赋值部分应该加上括号</p><p><code>sizeof *p</code><br>sizeof 不会实际求运算对象的值, 所以即使p是无效指针也不会有什么影响<br>sizeof对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小<br>sizeof对string对象和vector对象 只返回该类型固定部分的大小, 不会计算对象中元素占用了多少空间<br>sizeof(string) 与string长度无关, 不同的编译器有不同的具体实现<br><a href="http://www.cplusplus.com/forum/general/218642/" target="_blank" rel="noopener">http://www.cplusplus.com/forum/general/218642/</a></p><p>sizeof(vector<int>) 返回24字节 64位系统指针8字节 三个指针24字节 (头指针, 尾指针, 当前容量尾指针)<br>pointer <em>M</em>start;<br>pointer <em>M</em>finish;<br>pointer <em>M</em>end_of_storage;</p><p>非内置类型基本都含有指针, 指向堆中分配的内存, 所以存在存储任意大小都会返回固定sizeof</p><p><code>const-name&lt;type&gt;(expr)</code><br>命名显式强制类型转换</p><p>static_cast 静态类型转换 用于替代隐式类型转换</p><ul><li>子类向父类转换 安全</li><li>父类向子类转换 无动态类型检查 不安全</li><li>基本数据类型转换</li><li>指针类型转换</li><li>将任何其他类型转换为void类型</li></ul><p>任何具有明确定义的类型转换, 只要底层不包含const, 都能使用. 值类型转换以及指针类型转换<br>如果类型不兼容, 则编译阶段报错.</p><p>dynamic_cast<br>运行时转换, 如果转换失败返回null. type和expr必须同是类指针或者类引用<br>用于父类向子类的转换</p><p>const_cast<br>增加或删除运算对象的底层const, 如果对象本身不是一个常量 获取写权限是合法的, 如果是常量则会产生未定义后果.</p><p>reinterpret_cast<br>为运算对象的位模式提供较低层次上的重新解析<br><a href="https://zhuanlan.zhihu.com/p/33040213" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33040213</a></p><h2 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章 语句"></a>第五章 语句</h2><p>即使不准备在default标签下做任何工作, 定义一个default标签也是有作用的. 可以告知读者,<br>我们已经考虑到了默认情况, 只是目前什么也没做</p><p><strong>switch-case关于变量定义的问题</strong></p><pre><code class="c++">#include &lt;string&gt;#include &lt;iostream&gt;int main(){    switch (true)    {        case true:            std::string v1;            std::string v2 {};            int v3 = 0;            int v4;            break;        case false:            std::cout &lt;&lt; v1 &lt;&lt; std::endl;            std::cout &lt;&lt; v2 &lt;&lt; std::endl;            std::cout &lt;&lt; v3 &lt;&lt; std::endl;            std::cout &lt;&lt; v4 &lt;&lt; std::endl;            break;    }    return 0;}// 编译报错 注意没有   v4  控制流绕过了初始化变量的语句switch-case.cpp: In function ‘int main()’:switch-case.cpp:16:14: error: jump to case label [-fpermissive]         case false:              ^~~~~switch-case.cpp:12:17: note:   crosses initialization of ‘int v3’             int v3 = 0;                 ^~switch-case.cpp:11:25: note:   crosses initialization of ‘std::__cxx11::string v2’             std::string v2 {};                         ^~switch-case.cpp:10:25: note:   crosses initialization of ‘std::__cxx11::string v1’             std::string v1;// 两个case语句加上括号后报错变为switch-case.cpp: In function ‘int main()’:switch-case.cpp:18:26: error: ‘v1’ was not declared in this scope             std::cout &lt;&lt; v1 &lt;&lt; std::endl;                          ^~switch-case.cpp:19:26: error: ‘v2’ was not declared in this scope             std::cout &lt;&lt; v2 &lt;&lt; std::endl;                          ^~switch-case.cpp:20:26: error: ‘v3’ was not declared in this scope             std::cout &lt;&lt; v3 &lt;&lt; std::endl;                          ^~switch-case.cpp:21:26: error: ‘v4’ was not declared in this scope             std::cout &lt;&lt; v4 &lt;&lt; std::endl;</code></pre><p>定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程</p><p>牢记for语句头中定义的对象只在for循环体内可见.<del>~</del></p><p><strong>break continue</strong></p><p>break负责终止离他最近的while, do while, for或者switch. 并从这些语句后的第一条开始继续执行</p><p>continue语句终止最近的循环中当前迭代, 并立即开始下一次迭代</p><p><strong>异常处理</strong><br>代码可以使用throw来抛出异常<br>大部分可以指定msg来初始化异常<br>throw exception_type(“msg”)<br>表中exception不能指定msg, 来初始化, 除此外表中其他都需要msg初始</p><p>位于<code>stdexcept</code>头文件中</p><table><thead><tr><th>错误名称</th><th>对应原因</th></tr></thead><tbody><tr><td>exception</td><td>最常见的问题</td></tr><tr><td>runtime_error</td><td>只有运行的时候才能查到错误</td></tr><tr><td>range_error</td><td>运行时错误: 超范围</td></tr><tr><td>overflow_error</td><td>运行时错误: 上溢</td></tr><tr><td>underflow_error</td><td>运行时错误: 下溢</td></tr><tr><td>logic_error</td><td>程序逻辑错误</td></tr><tr><td>domain_error</td><td>程序逻辑错误: 参数对应的结果不存在</td></tr><tr><td>invalid_argument</td><td>程序逻辑错误: 无效参数</td></tr><tr><td>length_error</td><td>程序逻辑错误: 试图创建一个超出该类型最大长度的对象  如vector::reserve</td></tr><tr><td>out_of_range</td><td>程序逻辑错误: 超范围</td></tr></tbody></table><h2 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h2><p>形参名是可选的, 但是由于无法使用未命名的形参, 所以一般都有一个名字.</p><p>自动对象: 只存在于块执行期间的对象<br>局部静态对象: 只在<code>第一次</code>经过对象语句时进行初始化, 直到程序终止才被销毁.</p><p>数组引用形参</p><pre><code class="c++">void print(int (&amp;arr)[10]){    for (auto elem : arr)    {        cout &lt;&lt; elem &lt;&lt; endl;    }}</code></pre><p>函数返回引用得到左值<br>返回其他类型得到右值</p><p>p205页 还真没见过 返回数组指针这种形式</p><h2 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h2><h3 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h3><p><strong>7.25 Screen能安全的依赖于拷贝和赋值操作的默认版本吗</strong><br>Screen中只有内置类型和string, 如果其含有动态管理的内存则不行<br>当类需要分配类对象以外的资源时, 默认版本经常会失效</p><p>默认构造函数, 会造成 内置类型和复合类型成员 默认初始化后 值未定义</p><p>关于未定义这点我去写了小段程序看了下, 也搜了一下</p><p><a href="https://stackoverflow.com/a/2218275/11581349" target="_blank" rel="noopener">https://stackoverflow.com/a/2218275/11581349</a></p><p>It will be automatically initialized if</p><ul><li>it’s a class/struct instance in which the default constructor initializes all primitive types; like MyClass instance; 有默认构造函数类或者结构体, 并且默认构造函数初始化所有内置类型</li><li>you use array initializer syntax, e.g. int a[10] = {} (all zeroed) or int a[10] = {1,2}; (all zeroed except the first two items: a[0] == 1 and a[1] == 2) 使用了大括号初始化</li><li>same applies to non-aggregate classes/structs, e.g. MyClass instance = {}; (more information on this can be found here) 同大括号初始化</li><li>it’s a global/extern variable 全局或者extern类型</li><li>the variable is defined static (no matter if inside a function or in global/namespace scope) 变量被声明为static</li></ul><p>默认初始化发生的情况</p><ul><li>不使用任何初始值定义一个非静态变量或者数组</li><li>一个类本身含有类类型的成员且使用合成的默认构造函数</li><li>类类型的成员没有在构造函数初始值列表中显示地初始化时</li></ul><p>值初始化</p><ul><li>数组初始化提供的初始值数量小于数组大小</li><li>不使用初始值定义一个局部静态变量</li><li>书写T()表达式 显示地请求值初始化</li></ul><p>mutable可变数据成员, 从远不会是const.  可以在const成员函数中对其进行修改</p><p>类的GetBalance函数的函数体在整个Account类可见之后才被处理.</p><p>编译器看到GetBalance的声明后 开始从类内(<strong>类内会从使用Money前查找</strong>)到类外寻找Money声明, 然后函数的返回值和bal成员变量的类型为double, 接着类可见之后处理函数体 函数会返回double类型的成员变量bal</p><pre><code class="c++">typedef double Money;std::string balance = &quot;string&quot;;class Account{public:    // typedef std::string Money; 这里则不会报错    Account() = default;    ~Account() = default;    Money GetBalance() const    { return balance;  }private:    // typedef std::string Money; 会报错 因为由于GetBalance函数已经使用了外部的Money    Money balance;};int main(){    Account account;    std::cout &lt;&lt; account.GetBalance(); // $ 0    return 0;}</code></pre><pre><code class="c++">class Foo{public:    Foo(int val):        bar1(val),        bar2(bar1){}private:    int bar1; // 更改两个顺序  将会导致先使用 bar1初始化bar2 然后使用val初始化bar1    int bar2;}</code></pre><p>在我看了一些项目后使用的上面的写法, 然而这种写法却不合适 除非你严格按照变量顺序写.</p><p>如果你将bar2和bar1的顺序不小心更换了, 难以排查的bug</p><p><strong>使用默认构造函数声明对象 需要去掉对象名后的空括号对</strong></p><pre><code class="c++">Foo foo(); // 错误Foo foo;</code></pre><h3 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参, 则它实际上定义了转换为此类类型的隐式转换机制 – 称这种构造函数为<strong>转换构造函数</strong></p><p>Foo含有一个只有string类型的构造函数. 当一个函数的参数是Foo类型时. 你可以将string类型直接传递给这个函数. 会自动从string类型构造成Foo类型</p><pre><code class="c++">// Value(string val); 可以加上explicit防止隐式类型转换// void Add(Value val);string val1 = &quot;val1&quot;;foo.Add(val1); // 正确 隐式转换成Valuefoo.Add(&quot;val2&quot;); // 错误 只能进行一步转换  需要从&quot;val2&quot;到string再到Value</code></pre><h3 id="聚合类-字面值常量类"><a href="#聚合类-字面值常量类" class="headerlink" title="聚合类 字面值常量类"></a>聚合类 字面值常量类</h3><p>聚合类</p><ul><li>所有成员都是public</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类也没有virtual函数</li></ul><pre><code class="c++">class Foo{public:    std::string str;    int val;};int main(){    Foo foo = {&quot;1&quot;, 1};}</code></pre><p>字面值常量类</p><ul><li>数据成员都是字面值类型的聚合类</li></ul><p>如果一个类不是聚合类, 但是符合以下要求也是字面值类型常量类</p><ul><li>数据成员必须是字面值类型</li><li>类必须含有一个constexpr构造函数</li><li>如果一个数据成员含有类内初始值, 则初始值必须是一条常量表达式. 如果成员属于某种类类型, 则初始值必须使用成员自己的constexpr构造函数</li><li>类必须使用默认析构函数</li></ul><h1 id="第二部分-cpp标准库"><a href="#第二部分-cpp标准库" class="headerlink" title="第二部分 cpp标准库"></a>第二部分 cpp标准库</h1><h2 id="第八章-IO库"><a href="#第八章-IO库" class="headerlink" title="第八章 IO库"></a>第八章 IO库</h2><p>想到了遇到过的<code>while(std::cin &gt;&gt; xx)</code>究竟是如何判断的呢? <code>&gt;&gt;</code>返回的对象是<code>std::cin</code>如何将其转换为<code>bool</code>?</p><p>重载运算符</p><pre><code class="c++">explicit __CLR_OR_THIS_CALL operator bool() const {        return !fail();    }_NODISCARD bool __CLR_OR_THIS_CALL operator!() const {    return fail();}class Foo{public:    explicit operator bool()    {        std::cout &lt;&lt; &quot;operator *&quot; &lt;&lt; std::endl;        return true;    }    bool operator!()    {        std::cout &lt;&lt; &quot;operator !&quot; &lt;&lt; std::endl;        return true;    }};int main(){    Foo foo;    if (foo); // $ operator *    if (!foo);// $ operator !}</code></pre><p>endl  换行 刷新缓冲区<br>flush 刷新缓冲区<br>ends  空字符 刷新缓冲区</p><p>unitbuf 所有输出操作后都会立即刷新缓冲区<br>nounitbuf 恢复正常的缓冲方式</p><h2 id="第九章-顺序容器"><a href="#第九章-顺序容器" class="headerlink" title="第九章 顺序容器"></a>第九章 顺序容器</h2><h3 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h3><p><strong>9.6 下面的程序有何错误 你应该如何修改它?</strong></p><pre><code class="c++">list&lt;int&gt; lst1;list&lt;int&gt;::iterator iter1 = lst1.begin(),iter2 = lst1.end();while (iter1 &lt; iter2)</code></pre><p>将<code>while (iter1 &lt; iter2)</code> 改成<code>while(iter1 != iter2)</code><br>迭代器是指向元素的指针, 对于list来说比较元素指针大小无法判断<br>@@@@</p><p><strong>9.12 对于接受一个容器创建其拷贝的构造函数 和 接收两个迭代器创建拷贝的构造函数之间的不同</strong></p><p><strong>创建拷贝</strong>-要求容器类型和元素类型都相同<br><strong>接收两个迭代器</strong>-元素类型能够相互转化即可</p><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><p>assign函数 仅顺序容器</p><ul><li>用指定元素的拷贝 替换左侧容器中的所有元素</li></ul><p>swap函数</p><ul><li>只会真正交换array的元素 与长度有关</li><li>其他容器会交换内部的数据结构 常数时间完成</li></ul><p>除了string指向容器的迭代器 引用和指针在swap操作之后都不会失效 仍指向swap操作前的元素,<br>但是这些元素已经属于不同的容器了</p><p>关系运算符</p><ul><li>两个容器具有相同的大小 且所有元素两两对应相等 这两个容器相等 否则不等</li><li>如果两个容器大小不同, 但较小的容器中每个元素都等于较大容器中对应元素 则较小容器 &gt; 较大容器</li><li>比较结果取决于第一个不相等的元素的比较结果 类似 compare</li></ul><p>容器的运算符 非迭代器<br>== != 运算符 所有容器都支持<br>&lt; &lt;= &gt; &gt;= 运算符 无序关联容器不支持</p><p>size_type 无符号整数 足够保存此种容器类型最大可能容器的大小<br>difference_type 带符号整数类型 足够保存两个迭代器之间的距离<br>value_type 元素类型</p><p>除了array之外其他容器的默认构造函数会创建一个指定类型的<code>空容器</code></p><p>只有<code>顺序容器</code>的<code>构造函数</code>才接<code>受大小参数</code> 关联容器并不支持</p><p>如果元素类型是内置类型或者具有默认的构造函数的类类型,可以只为构造函数提供一个容器大小的参数<br>如果元素类型没有默认构造函数 除了容器大小参数 还必须指定一个显示的元素初始值</p><p>只有支持随机访问容器的迭代器才支持<code>operator&lt;</code>, list只能使用<code>=</code>来判断迭代器</p><p>成员访问函数<code>front</code>,<code>back</code>,<code>下标</code>,<code>at</code>访问返回的都是引用. 如果容器是一个const对象 则返回值是const的引用 </p><p>大多数会使迭代器失效的函数如erase<code>会在调用后返回删除的后一个元素位置的迭代器</code>, 使用返回值替换原来的迭代器可以在删除元素的情况下遍历所有元素</p><p>不要保存end返回的迭代器, 添加删除vector或string元素后都会失效. <code>while (x != v.end())</code>或者是<code>for(; x != v.end();)</code></p><p>向容器中添加元素</p><ul><li>目标是vector或string 且存储空间被重新分配, 则指向容器的迭代器指针引用都会失效. 如果存储空间没有被重新分配, 则插入位置后的三者都会失效</li><li>目标是deque 插入到除首尾之外的任何位置都会使三者失效 首尾添加元素则迭代器失效 但是指向存在元素的引用和指针不会失效</li><li>对于list和forward_list 三者仍然有效</li></ul><p>从容器中删除元素</p><ul><li>vector和string 被删元素之前的三者仍有效</li><li>list和forward_list 三者仍有效</li><li>deque 首尾之外的任何位置删除元素 指向被删除元素外<code>其他任何元素</code>的三者也会失效 如果删除尾元素则<code>尾后迭代器</code>失效 其他迭代器和指针不受影响</li></ul><h2 id="第十章-泛型算法"><a href="#第十章-泛型算法" class="headerlink" title="第十章 泛型算法"></a>第十章 泛型算法</h2><p>迭代器使得算法不依赖于容器, 可以解引用迭代器得到值, 也可以移动访问其他元素</p><p>不过迭代器依赖于元素类型 因为会使用如<code>==</code> <code>&lt;</code>之类的操作符 作用在元素上得到结果</p><p>小小accumulate也有很多细节问题</p><ul><li>函数的返回值类型与第三个参数相同, 需要序列中元素能够转换成第三个参数的类型</li><li>遍历元素的结果是加在第三个参数上的</li></ul><p>一个lambad只有在其捕获列表中捕获一个他所在函数中的局部变量, 才能在函数体中使用该变量.</p><p>捕获列表只用于局部非static变量, lambda可以直接使用局部static变量和他所在函数之外声明的名字</p><p><code>值传递</code>的变量在lambda创建的时候进行拷贝, 所以随后的修改不会影响到lambda内的值</p><p><code>引用捕获</code>的则需要确保在lambda执行期间, 被引用的变量时存在的</p><p>| 形式 | 说明 |<br>| <code>[]</code> | 空捕获列表. lambda不能使用所在函数变量 |<br>| <code>[names]</code> | 逗号分隔的所在函数的局部变量列表. 默认使用拷贝, 如果变量名前有&amp;则使用引用 |<br>| <code>[&amp;]</code> | 隐式捕获列表, 引用捕获 |<br>| <code>[=]</code> | 隐式捕获列表, 值捕获 |<br>| <code>[&amp;, names]</code> | 引用捕获, names列表使用值捕获 |<br>| <code>[=, names]</code> | 值捕获, names列表使用引用捕获 |</p><p>谓词 - 一个可调用的表达式, 其返回结果是一个能用做条件的值</p><ul><li>一元谓词 只接收单一参数</li><li>二元谓词 有两个参数</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>find_if</td><td></td></tr><tr><td>for_each</td><td></td></tr><tr><td>bind</td><td>参数绑定, 可以进行诸如 一二元谓词互换的操作 参数重排 绑定引用参数</td></tr><tr><td>ref</td><td>返回对象的引用</td></tr></tbody></table><ol><li>普通迭代器</li><li>插入迭代器</li></ol><ul><li>back_inserter 创建一个使用push_back的迭代器(需容器支持push_back)</li><li>front_inserter 创建一个使用push_front的迭代器(需容器支持push_front)</li><li>insterer 创建一个使用insert的迭代器</li></ul><ol start="3"><li>流迭代器</li></ol><ul><li>istream_iterator</li><li>ostream_iterator</li></ul><ol start="4"><li>反向迭代器 - 除了forward_list均支持</li></ol><p>算法要求的迭代器类型 五类迭代器</p><ul><li>输入迭代器 只读, 不写, 单边扫描, 只能递增</li><li>输出迭代器 只写, 不读, 单边扫描, 只能递增</li><li>前向迭代器 读写 多遍 只能递增</li><li>双向迭代器 读写 多遍 增减都可</li><li>随机访问迭代器 读写 多遍 支持全部迭代器运算</li></ul><h2 id="第十二章-动态内存与智能指针"><a href="#第十二章-动态内存与智能指针" class="headerlink" title="第十二章 动态内存与智能指针"></a>第十二章 动态内存与智能指针</h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png" alt=""></p><p><strong>make_shared</strong></p><p><strong>shared_ptr的拷贝和赋值</strong><br>当进行拷贝或者赋值操作时候 shared_ptr都会记录有多少个其他的shared_ptr<br>指向相同的对象</p><p>引用计数增加的情况</p><ul><li>拷贝shared_ptr </li><li>初始化其他shared_ptr指针</li><li>作为参数传递给一个函数</li><li>作为函数的返回值</li></ul><p>引用计数减少</p><ul><li>赋予新值</li><li>被销毁(例如离开作用域)</li></ul><p>当引用计数为0的时候, 就会释放自己管理的对象</p><p><strong>使用动态内存的原因</strong></p><ul><li>程序不知道自己需要使用多少对象 容器类</li><li>程序不知道所需对象的准确类型</li><li>程序需要在多个对象间共享数据</li></ul><p><strong>程序需要在多个对象间共享数据</strong><br>一般情况</p><pre><code class="c++">vector&lt;string&gt; v1; // empty{ // 新的作用域    vector&lt;string&gt; v2 = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};    v1 = v2;} // 离开作用域 v2被销毁// v1中有三个元素, 是原来三个元素的拷贝</code></pre><p>下面是我们要实现的情况</p><pre><code class="c++">vector&lt;string&gt; v1; // empty{ // 新的作用域    vector&lt;string&gt; v2 = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};    v1 = v2; // v1 v2共享相同的元素} // 离开作用域 v2被销毁 但v2的元素不能被销毁// v1中有三个元素, 指向原来三个元素</code></pre><p>创建一个类来管理这个vector, 但是不能直接保存在其中, 因为当这个类的对象销毁的时候内部的vector也就销毁<br>所以需要保存在动态内存中</p><p>所以使用shared_ptr来管理动态分配的vector, 当最后一个vector的使用者被销毁的时候才释放内存</p><p>确定下这个类提供的操作</p><ul><li>修改元素的操作会进行校验 不合法则抛出异常</li><li>默认构造函数</li><li>接受单一的initiaizer_list&lt;string&gt;类型的参数. 这个参数可以接受一个初始器的花括号列表</li></ul><p><strong>直接管理内存</strong></p><p>了解到两个概念 一个<code>默认初始化</code>一个<code>值初始化</code></p><pre><code class="c++">int i, *pi1 = &amp;i, *pi2 = nullptr;double *pd = new double(33), *pd2 = pd;delete i; // 错误 i不是指针delete pi1; // 未定义 pi1指向一个局部变量 具有潜在性危害delete pd; // okdelete pd2; // 未定义 内存已经被释放 具有潜在性危害delete pi2; // 正确 释放空指针没有错误const int *pci = new const int(1024);delete pci // 正确 释放一个const对象// delete之后指针就变成了`空悬指针` 需要将其置为`nullptr`</code></pre><p><strong>shared_ptr和new结合使用</strong></p><pre><code class="c++">// 错误智能指针构造函数是explicit// 无法将内置指针隐式转换成一个智能指针, 必须使用直接初始化shared_ptr&lt;int&gt; p1 = new int(1024); // 正确  使用了直接初始化shared_ptr&lt;int&gt; p2(new int(1024));</code></pre><p>定义和改变方式</p><pre><code class="c++">// p管理内置指针q所指向的对象, q必须指向new分配的内存, 且能够转换为T*类型shared_ptr&lt;T&gt; p(q)// p从unique_ptr u那里接管了对象的所有权 将U置为空shared_ptr&lt;T&gt; p(u)// p 接管了内置指针q所指向的对象的所有权, q必须能转化为T* 类型// p将使用可调用对象d来代替deleteshared_ptr&lt;T&gt; p(q, d)// p是shared_ptr p2的拷贝// p将用可调用对象d来代替deleteshared_ptr&lt;T&gt; p(p2, d)// 若p是唯一指向其对象的shared_ptr, reset会释放此对象// 如果传递了可选的参数-内置指针q, 则会令p指向q 否则将p置为空// 如果还传递了d, 会调用d而不是delete来释放qp.reset()p.reset(q)p.reset(q, d)</code></pre><p><strong>注意</strong></p><p>使用unique_ptr的时候要注意</p><ol><li>不要在函数调用传参的括号中 使用临时变量 这样一旦函数调用完成就会被销毁<pre><code class="c++">void process(shared_ptr&lt;int&gt; ptr)</code></pre></li></ol><p>shared_ptr<int> p(new int(42 )) ; // 引用 = 1<br>process(p); // 拷贝 会递增它的引用计数 ;在 process 中引用计数位为2<br>int i = *p; // 正确 引用计数为1</p><p>int <em>x(new int(1024)); // 危险 这是一个普通指针，不是一个智能指针<br>process(x) ; // 错误 不能将 int</em> 转换为 一个 shared_ptr<int><br>process(shared_ptr<int> (x)); // 合法的，但内存会被释放! 因为临时对象会被销毁<br>int j =*x //未定义的 是一个空悬指针!</p><pre><code>2. 如果使用智能指针不要使用get函数初始化另一个智能指针或为其赋值因为一旦新生成的智能指针离开作用域或者被释放, 会影响到原来的智能指针```c++std::shared_ptr&lt;int&gt; p = new int(8); // 不能将一个int* 赋值给shared_ptr&lt;int&gt;std::shared_ptr&lt;int&gt; p1;p1.reset(new int(8)); // 可以std::shared_ptr&lt;int&gt; p2(new int(8)); // OK// 使用make_share来创建shared_ptr指针std::shared_ptr&lt;int&gt; p3 = std::make_shared&lt;int&gt;(20);auto p4 = std::make_shared&lt;int&gt;(20);// make_share不能用来创建unique_ptrstd::unique_ptr&lt;int&gt; d;std::unique_ptr&lt;int&gt; d1 (new int(8)); </code></pre><ol start="3"><li>unique_ptr不支持普通的赋值和拷贝操作, 因为unique_ptr要独占所指向的对象<pre><code class="c++">std::unique_ptr&lt;int&gt; d1 (new int(1)); std::unique_ptr&lt;int&gt; d2 (new int(8)); </code></pre></li></ol><p>d1.release(); // 释放原来所指向的对象<br>d1.reset(d2.release()); // d2释放后由d1获取</p><pre><code>**智能指针陷阱**1. 不使用相同的内置指针值初始化(或reset)多个智能指针2. 不使用delete get返回的指针3. 不使用get初始化或者reset另一个智能指针4. 如果你使用get返回指针, 当最后一个对应的智能指针销毁 这个指针就变成了垂悬指针5. 使用智能指针管理非new分配的内存, 需要传递一个删除器.**weak_ptr**不控制所指向对象生存周期, 指向一个shared_ptr管理的对象.由于weak_ptr不参与对应的shared_ptr的引用计数, vector可能已经被释放了释放后 lock将返回一个空指针**allocator 将内存的分配和对象的构造分离开**# 第三部分 类设计者的工具## 第十六章 模板与泛型编程`template &lt;typename T&gt;`编译器用推断出的模板参数来`实例化`一个特定版本的函数.不同的模板参数类型`实例化`出不同的函数 然后进行调用.**模板类型参数**如果有多个模板参数```c++// 错误template &lt;typename T, U&gt;// 正确template &lt;typename T, typename U&gt;// 正确template &lt;typename T, class U&gt;</code></pre><p><strong>非类型模板参数</strong></p><pre><code class="c++">template &lt;unsigned N, unsigned M&gt;int compare(const char (&amp;p1)[N], const char (&amp;p2)[M]){    return strcmp(p1, p2);}compare(&quot;hi&quot;, &quot;mmm&quot;);int compare(const char (&amp;p1)[3], const char (&amp;p2)[4]) // 注意空字符</code></pre><p>编译器会使用字面常量的大小来代替N和M, 从而实例化模板</p><p>非类型参数可以使<code>整形</code>或者是一个指向对象或者函数类型的<code>指针</code>或者<code>(左值)引用</code><br>绑定到<code>非类型整数参数</code>的实参必须是一个常量表达式.<br>绑定到<code>指针</code>或者<code>引用非类型模板参数</code>的实参必须具有静态的生存期</p><p>静态内存用来保存<code>局部static对象</code>, <code>类static数据成员</code>和<code>定义于任何函数之外的变量</code><br>栈内存用来保存定义在函数内的非static对象.<br>分配在静态内存和栈内存的由编译器自动创建和销毁</p><p>堆 用来存储动态分配的对象</p><p>编译器遇到一个模板类型定义的时候并不会生成代码, 而是实例化出一个特定版本的时候才会实例化</p><p><strong>使用类的类型成员</strong></p><pre><code class="c++">template &lt;typename T&gt;T::size_type* p;</code></pre><p>默认情况下, C++语言假定通过域运算符访问名字而不是类型.<br>如果想要使用模板类型参数(T)的类型成员(size_type) 必须使用<code>typename</code>而不是<code>class</code></p><p><strong>默认模板实参</strong></p><pre><code class="c++">template &lt;typename T, typename F = less&lt;T&gt;&gt;int compare(const T&amp; v1, const T&amp; v2, F f = f()){    if (f(v1, v2)) return -1;    if (f(v2, v1)) return 1;    return 0;}</code></pre><h1 id="第四部分-高级主题"><a href="#第四部分-高级主题" class="headerlink" title="第四部分 高级主题"></a>第四部分 高级主题</h1><h2 id="第十七章-标准库特殊设施"><a href="#第十七章-标准库特殊设施" class="headerlink" title="第十七章 标准库特殊设施"></a>第十七章 标准库特殊设施</h2><p>tuple这里看了, 例子写了总感觉实用性不是很大? 或许可以用在便捷处理输入参数?</p><p>biset感觉还是有点用</p><pre><code class="c++">std::bitset&lt;32&gt; b;// 以下位不足 高位都补0unsigned long long u = ULLONG_MAX;std::bitset&lt;32&gt; bu(u);std::string s1 = &quot;10101010101010&quot;;std::bitset&lt;32&gt; bs1(s1);std::string s2 = &quot;ababaabbababb&quot;;// std::bitset&lt;32&gt; bs2(s2); std::invalid_argument// a instand 0 b instand 1std::bitset&lt;32&gt; bs2(s2, 0, 32, &#39;a&#39;, &#39;b&#39;);bu.any(); // 存在 置位(1) 的二进制位吗bu.all(); // 所有位都置位了吗bu.none(); // b中不存在置位的二进制位吗bu.count(); // 置位数目bu.size(); // 数目bu.test(1); // 位置1是置位的返回true 否则返回falsebu.set(1, true); // 将1位 置 true-&gt;1 false-&gt;0bu.reset(1); // 将1位复位 置0bu.reset(); // 将所有位复位 置0bu.flip(1); // 1位取反bu.flip(); // 全部取反bu[1].flip();bu[1]; // 1位 1-&gt;true 0-&gt;falsebu.to_ulong();bu.to_ullong();bu.to_string(&#39;a&#39;, &#39;b&#39;); // 0-&gt;a 1-&gt;b</code></pre><h2 id="第十九章-特殊工具与技术"><a href="#第十九章-特殊工具与技术" class="headerlink" title="第十九章 特殊工具与技术"></a>第十九章 特殊工具与技术</h2><pre><code class="c++">string* sp = new string(&quot;a value&quot;);sp-&gt;~string();</code></pre><p>可以销毁对象, 但是不会释放内存</p><p>使用class 限定作用域的枚举类 默认类型是int 而未限定作用域的未知</p><pre><code class="c++">void (TcpConnection::*fp)(const std::string_view&amp;) = &amp;TcpConnection::SendInLoop;            loop_-&gt;RunInLoop(std::bind(fp,                     this,                    std::string(data, length))); // OKTcpConnection::SendInLoop;            loop_-&gt;RunInLoop(std::bind(&amp;TcpConnection::SendInLoop,                     this,                    std::string(data, length))); // ERROR</code></pre><p>这里是由于存在函数重载, 需要显式指定函数. 同时成员函数需要使用<code>&amp;</code>来获取地址, 而非成员函数则存在到地址的隐式转换</p><p>mem_fn 可以自动将一个函数推断为function对象</p>]]></content>
      
      
      <categories>
          
          <category> 读书记录 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
