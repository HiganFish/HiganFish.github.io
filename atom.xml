<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsmg的大学之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lsmg.xyz/"/>
  <updated>2025-02-27T06:39:40.173Z</updated>
  <id>http://blog.lsmg.xyz/</id>
  
  <author>
    <name>Lsmg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows下Unity内存泄露排查</title>
    <link href="http://blog.lsmg.xyz/2024/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-Windows%E4%B8%8BUnity%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%8E%92%E6%9F%A5/"/>
    <id>http://blog.lsmg.xyz/2024/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-Windows%E4%B8%8BUnity%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%8E%92%E6%9F%A5/</id>
    <published>2024-11-14T19:48:22.000Z</published>
    <updated>2025-02-27T06:39:40.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目使用Unity开发，使用过程中可以明显内存有异常增长，所以排查了一下原因，做一下记录。</p><p>分三步描述</p><ol><li>寻找异常内存分配时的地址</li><li>寻找异常内存分配的堆栈</li><li>寻找对应的项目代码</li></ol><h1 id="寻找异常内存分配时的地址"><a href="#寻找异常内存分配时的地址" class="headerlink" title="寻找异常内存分配时的地址"></a>寻找异常内存分配时的地址</h1><h2 id="后台用的工具"><a href="#后台用的工具" class="headerlink" title="后台用的工具"></a>后台用的工具</h2><p>使用massif可以详细打印内存分配时的堆栈信息，但是没有Windows版本，询问GPT后得到了下面几个工具。</p><ol><li>Unity自带的Profile</li><li>vs2022</li><li>vmmap64</li></ol><h2 id="工具一，Unity自带的Profile"><a href="#工具一，Unity自带的Profile" class="headerlink" title="工具一，Unity自带的Profile"></a>工具一，Unity自带的Profile</h2><p>拍摄两个快照，发现内存异常增长的部分被划分到了Unknown，也不会显示堆栈所以需要换工具。</p><h2 id="工具二，vs2022"><a href="#工具二，vs2022" class="headerlink" title="工具二，vs2022"></a>工具二，vs2022</h2><p>Attach到Unity之后使用<strong>堆快照</strong>无法发现明显的内存增长，换工具。</p><h2 id="工具三vmmap64"><a href="#工具三vmmap64" class="headerlink" title="工具三vmmap64"></a>工具三vmmap64</h2><p>附加到Unity进程之后会自动拍摄快照，之后隔一段时间手动F5刷新一下。之后点击Timeline，选择对应的时间范围，可以看到这期间的内存新增申请。可以明显看到不是Heap在增长，而是Private Data在增长, 且都是相同的524284K，符合内存泄露的特征。</p><p>所以下一步需要找到不断申请的524284K的Private Data是谁申请的。</p><p>观察一下分配的虚拟内存是524284K，但这并不是实际占用的物理内存，最终占用的物理内存是258000K左右(另一部分保留了)。可以理解为这一块内存是逐渐从0K占用逐渐增长到了258000K。</p><p>每次F5刷新时，可以看到新的524284K大小的虚拟内存申请和对应的起始地址如0xA0000，之后Unity会顺序写入直到0xA0000+258000K。</p><p>了解到这一点之后，可以使用硬件断点设置写内存断点，当向指定地址写入时触发断点，进而查看堆栈。</p><p>所以需要一个内存地址，从上文可以看到内存是逐渐从0xA0000到0xA0000+258000K，所以拍摄快照时，如果内存使用到了0xA0000+1000K，则其必定会访问到0xA0000+10000K，所以对0xA0000+10000K下断点等待Unity的访问。</p><h1 id="寻找异常内存分配的堆栈"><a href="#寻找异常内存分配的堆栈" class="headerlink" title="寻找异常内存分配的堆栈"></a>寻找异常内存分配的堆栈</h1><h2 id="Windbg"><a href="#Windbg" class="headerlink" title="Windbg"></a>Windbg</h2><p>Attach到Unity进程，之后恢复Unity运行，返回vmmap64拍摄快照之后，立刻返回Windbg将Unity暂停。</p><p>回到vmmap64，查看最新的524284K的起始地址和已经使用大小，计算一个将来会访问的地址0xA123456。</p><p>回到windbg使用ba w 4 0xA123456 设置硬件断点，之后恢复Unity的运行，等到Unity访问到524284K内存块中的0xA123456时就会触发断点。此时就获得了向这块异常内存块写入数据时的堆栈。</p><h1 id="寻找对应的项目代码"><a href="#寻找对应的项目代码" class="headerlink" title="寻找对应的项目代码"></a>寻找对应的项目代码</h1><h2 id="查看Unity源码"><a href="#查看Unity源码" class="headerlink" title="查看Unity源码"></a>查看Unity源码</h2><p>找到对应的相关代码，是有开关的功能，查找开关的开启和关闭的接口。回到项目中找使用接口的代码，找到问题代码。</p><p>最终是因为开始Profile后没有关闭，导致Unity的Profile一直运行，内存一直增长。</p><h1 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h1><p>vmmap64中显示这块内存分配到了PrivateData, vs2022的堆快照无法发现问题, 暂不清楚Unity是如何使用内存的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目使用Unity开发，使用过程中可以明显内存有异常增长，所以排查了一下原因，做一下记录。&lt;/p&gt;
&lt;p&gt;分三步描述&lt;/p&gt;
&lt;ol&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="个人记录" scheme="http://blog.lsmg.xyz/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>CMake项目常见的编译加速方式汇总</title>
    <link href="http://blog.lsmg.xyz/2024/11/%E4%BC%98%E5%8C%96-%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F2/"/>
    <id>http://blog.lsmg.xyz/2024/11/%E4%BC%98%E5%8C%96-%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F2/</id>
    <published>2024-11-13T14:48:22.000Z</published>
    <updated>2025-02-27T06:39:40.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>本文主要介绍CMake项目，在不改动或较小改动项目代码的情况下，如何减少编译时间。同时简要介绍其原理和使用场景。包含ccache，编译集群，CMake依赖优化，避免动态编译宏和UnityBuild。</p><h1 id="加快编译速度"><a href="#加快编译速度" class="headerlink" title="加快编译速度"></a>加快编译速度</h1><p>分通解，增量编译和全量编译三个方面来介绍。通解开启简单方便，增量编译减小项目重编范围。全量编译减少编译数量。</p><h2 id="通解"><a href="#通解" class="headerlink" title="通解"></a>通解</h2><h3 id="使用ccache"><a href="#使用ccache" class="headerlink" title="使用ccache"></a>使用ccache</h3><h4 id="原理及使用场景"><a href="#原理及使用场景" class="headerlink" title="原理及使用场景"></a>原理及使用场景</h4><p>ccache会缓存编译结果，在编译文件和编译宏未发生变化时，直接返回缓存的编译结果。</p><p>使用场景：在文件内容未变化时加速效果近乎100%，开启简单方便。</p><p>单机器，搭配make使用时，效果有限。</p><p>2024-12-02更新：了解到存在远程ccache。AB机器相同代码的情况下，如果A机器编译过一次传到远端，B机器编译时make判定全量编译，ccache会从远端下载A机器的编译结果。这时效果就很明显。</p><h4 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h4><p>使用<code>yum install ccache</code>安装</p><p>在CMake中添加如下内容开启ccache</p><pre><code class="CMake">find_program(CCACHE_PROGRAM ccache)if(CCACHE_PROGRAM)    message(STATUS &quot;Found ccache: ${CCACHE_PROGRAM}&quot;)    set(CMAKE_C_COMPILER_LAUNCHER ${CCACHE_PROGRAM})    set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_PROGRAM})else()    message(WARNING &quot;ccache not found, proceeding without ccache&quot;)endif()</code></pre><p><strong>验证方式</strong></p><p><code>ccache -s</code>直接查看命中缓存次数。</p><pre><code class="sh">$ ccache -s                        cache directory                     /root/.ccachecache hit (direct)                   467cache hit (preprocessed)               2cache miss                          1009files in cache                      1701 这里是缓存命中的次数cache size                         656.0 Mbytesmax cache size                       1.0 Gbytes</code></pre><h3 id="使用编译集群"><a href="#使用编译集群" class="headerlink" title="使用编译集群"></a>使用编译集群</h3><h4 id="原理及使用场景-1"><a href="#原理及使用场景-1" class="headerlink" title="原理及使用场景"></a>原理及使用场景</h4><p>cpp项目编译时，每个源码文件都是一个编译单元，所以可以使用多线程并行编译。编译集群简单粗暴增加编译的并行数量。</p><p>使用场景：大规模编译时效果明显，收费。</p><h4 id="开启方式-1"><a href="#开启方式-1" class="headerlink" title="开启方式"></a>开启方式</h4><p>公司内部<a href="https://devops.woa.com/console/turbo/card-matrix/task/init" target="_blank" rel="noopener">devops</a>中就有编译加速，接入很简单。</p><h2 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h2><p>介绍如何减少不必要的编译项目。</p><h3 id="如何发现不必要的编译项目？"><a href="#如何发现不必要的编译项目？" class="headerlink" title="如何发现不必要的编译项目？"></a>如何发现不必要的编译项目？</h3><p>CMake生成后，使用Make编译时，会打印一些日志，如下所示。</p><pre><code class="txt">$ make MyExecutable              Scanning dependencies of target MyExecutable[ 33%] Building CXX object CMakeFiles/MyExecutable.dir/src/main.cpp.o[ 66%] Building CXX object CMakeFiles/MyExecutable.dir/src/Foo.cpp.o[100%] Linking CXX executable MyExecutable[100%] Built target MyExecutable</code></pre><p>从日志可以看到在编译MyExecutable时, Make将main.cpp.o和Foo.cpp.o重新编译，说明这两个文件所依赖的文件发生了变化。</p><p>将在<strong>依赖优化原理</strong>处介绍如何查看其依赖内容。这里只需要知道通过日志，可以观察本次编译的内容是否符合预期，如果发现不该编译的文件进行了编译，则可以查看其依赖内容，判断是否可以进行优化。</p><h3 id="CMake依赖优化"><a href="#CMake依赖优化" class="headerlink" title="CMake依赖优化"></a>CMake依赖优化</h3><h4 id="依赖优化原理"><a href="#依赖优化原理" class="headerlink" title="依赖优化原理"></a>依赖优化原理</h4><p>CMake生成之后会生成如下所示的depend.make文件</p><pre><code class="txt"># depend.makeCMakeFiles/MyExecutable.dir/src/Foo.cpp.o: ../src/Foo.cppCMakeFiles/MyExecutable.dir/src/Foo.cpp.o: src/version.hCMakeFiles/MyExecutable.dir/src/main.cpp.o: ../src/Foo.hCMakeFiles/MyExecutable.dir/src/main.cpp.o: ../src/main.cpp</code></pre><p>depend.make文件中描述了文件间的依赖情况。Foo.cpp.o依赖Foo.cpp和version.h。当version.h的<strong>修改时间戳</strong>变化时，会导致Foo.cpp.o重新生成。</p><p>如不想让冒号左侧的文件重新生成，则需要保证冒号右侧文件的<strong>修改时间戳</strong>不发生变化。如果内容无变化，但是<strong>修改时间戳</strong>发生变化，同样会导致左侧文件重新生成。</p><p>项目中存在的协议文件，需要转换后生成代码文件才能在代码中使用。如果转换时使用批量处理，会导致协议文件未变化，但代码文件发生了变化。代码文件发生变化后，所有依赖此代码文件的目标都会重新生成。</p><p>正确的做法应该是在协议文件发生变化时，再进行代码文件生成。手动识别较繁琐，正好CMake提供了此功能。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>编译时存在动态生成文件时</p><p>弊：需要理清生成文件的依赖关系</p><h4 id="开启方式-2"><a href="#开启方式-2" class="headerlink" title="开启方式"></a>开启方式</h4><pre><code class="CMake">set(XML_SRCS)file(GLOB CFG_FILES &quot;*.xml&quot;)set(GameResFile GameRes.h)# 主要命令，定义了产出文件GameResFile，生成脚本ConvertGameRes.sh，生成GameResFile所需的文件CFG_FILESadd_custom_command(OUTPUT ${GameResFile}        COMMAND bash ConvertGameRes.sh        DEPENDS ${CFG_FILES}        WORKING_DIRECTORY ${RES}/script/one)# 将所有动态生成文件添加到一个目标如XmlHeaders中list(APPEND XML_SRCS ${GameResFile})add_custom_target(XmlHeaders ALL DEPENDS ${XML_SRCS})# 需要使用GameRes.h的服务添加XmlHeaders为依赖add_dependencies(AServer XmlHeaders)</code></pre><p>编译AServer时会检查其依赖XmlHeaders是否有变化，XmlHeaders检查XML_SRCS即GameResFile是否需要重新生成。</p><p>当GameResFile的依赖文件CFG_FILES发生变化或产物GameResFile不存在时，调用ConvertGameRes.sh进行生成。</p><h3 id="避免使用频繁变化的编译宏"><a href="#避免使用频繁变化的编译宏" class="headerlink" title="避免使用频繁变化的编译宏"></a>避免使用频繁变化的编译宏</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在CMake中可以使用add_definitions添加编译宏，之后在代码文件中即可使用此宏获取对应的内容。如下所示打印编译时间。</p><pre><code class="txt"># 定义BUILD_TIME宏add_definitions(-DBUILD_TIME=\&quot;${BUILD_TIME}\&quot;)# 使用宏std::cout &lt;&lt; &quot;Current machine IP address: &quot; &lt;&lt; BUILD_TIME &lt;&lt; std::endl;</code></pre><p>编译宏会存储到如下CMake生成的flags.make中</p><pre><code class="make"># CMAKE generated file: DO NOT EDIT!# Generated by &quot;Unix Makefiles&quot; Generator, CMake Version 3.17# compile CXX with /usr/bin/c++CXX_DEFINES = -DBUILD_TIME=123</code></pre><p>每当编译宏发生变化时flags.make的修改时间也会发生变化。在build目录中搜索依赖此文件的内容，如下所示。</p><pre><code class="txt">$ grep -R &quot;flags.make&quot; ./*                   ./build.make:include CMakeFiles/MyExecutable.dir/flags.make./build.make:CMakeFiles/MyExecutable.dir/src/main.cpp.o: CMakeFiles/MyExecutable.dir/flags.make./build.make:CMakeFiles/MyExecutable.dir/src/Foo.cpp.o: CMakeFiles/MyExecutable.dir/flags.make</code></pre><p>可以看到main.cpp.o和Foo.cpp.o都依赖了flags.make。</p><p>所以每当cmake重新生成，宏内容发生变化时，flags.make也会发生变化，导致依赖flags.make的文件重新生成。</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>项目存在变化的编译宏时使用。</p><h4 id="开启方式-3"><a href="#开启方式-3" class="headerlink" title="开启方式"></a>开启方式</h4><pre><code class="txt">// 文件CompileVersion.cpp.in#define _BUILDDATE &quot;@BUILDDATE@&quot;#define _BUILDIP &quot;@BUILDIP@&quot;#include &quot;CompileVersion.h&quot;std::string GetCompileVersionStr(){    std::string strVersion;    strVersion += &quot;\033[40;32mSo Build Date   \033[0m: &quot;_BUILDDATE&quot;\n&quot;;    strVersion += &quot;\033[40;32mSo Build Host   \033[0m: &quot;_BUILDIP&quot;\n&quot;;    return strVersion;}// 文件 CompileVersion.h#pragma once#include &lt;string&gt;std::string GetCompileVersionStr();// 文件 CMakeconfigure_file(CompileVersion.cpp.in CompileVersion.cpp)</code></pre><p>configure_file会将模板CompileVersion.cpp.in中@BUILDDATE@替换成CMake中BUILDDATE变量。同时将产出放在cpp中，对外提供h文件。这样当版本信息发生变化时仅会编译CompileVersion.cpp</p><h2 id="全量编译"><a href="#全量编译" class="headerlink" title="全量编译"></a>全量编译</h2><h3 id="使用UnityBuild"><a href="#使用UnityBuild" class="headerlink" title="使用UnityBuild"></a>使用UnityBuild</h3><h4 id="原理及使用场景-2"><a href="#原理及使用场景-2" class="headerlink" title="原理及使用场景"></a>原理及使用场景</h4><p>默认的编译方式会逐个处理每个编译文件，如果A.cpp和B.cpp都include了common.h，编译A.cpp和B.cpp时common.h会被处理两次。将A.cpp和B.cpp合并为一个编译单元后，common.h仅会被处理一次。</p><p>弊：命名空间污染，重新编译范围扩大，同时手动组织比自动组织效果更好。</p><h4 id="自动组织开启方式-cmake3-16添加"><a href="#自动组织开启方式-cmake3-16添加" class="headerlink" title="自动组织开启方式 cmake3.16添加"></a>自动组织开启方式 cmake3.16添加</h4><pre><code class="CMake"># CMake中打开UnityBuildSET(CMAKE_UNITY_BUILD OFF)# 设置成一个文件所需的数量set(CMAKE_UNITY_BUILD_BATCH_SIZE 16）# 关闭指定文件的UnityBuild，使其单独编译set_source_files_properties(A.cpp PROPERTIES SKIP_UNITY_BUILD_INCLUSION ON)</code></pre><h4 id="手动组织开启方式-cmake3-18添加"><a href="#手动组织开启方式-cmake3-18添加" class="headerlink" title="手动组织开启方式 cmake3.18添加"></a>手动组织开启方式 cmake3.18添加</h4><p>这里项目未实际使用，直接粘贴的<a href="https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD_MODE.html#prop_tgt:UNITY_BUILD_MODE" target="_blank" rel="noopener">文档</a>的内容。</p><pre><code class="CMake">add_library(example_library            source1.cxx            source2.cxx            source3.cxx            source4.cxx)set_target_properties(example_library PROPERTIES                      UNITY_BUILD_MODE GROUP                      )set_source_files_properties(source1.cxx source2.cxx source3.cxx                            PROPERTIES UNITY_GROUP &quot;bucket1&quot;                            )set_source_files_properties(source4.cxx                            PROPERTIES UNITY_GROUP &quot;bucket2&quot;                            )</code></pre><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>项目中未使用的内容</p><ol><li>编译速度-使用PCH，使用后未发现明显的加速效果。</li><li>链接速度-使用多线程链接器，加快链接速度，目前链接很快，倾向于不做改动。</li></ol><h1 id="加快部署速度"><a href="#加快部署速度" class="headerlink" title="加快部署速度"></a>加快部署速度</h1><p>简单的快速部署方式：常用的SSH工具由于权限一般不能使用，问GPT生成一个带账号密码以及能够接受文件的HTTPServer，功能只需要在接受文件并校验后，替换文件，执行服务器重启脚本。可以将脚本输出放到HTTP的回包中，上传文件和接收文件时进行压缩和解压缩，降低对带宽的需求。</p><p>需要部署服务器时可以通过curl命令直接上传文件后触发部署。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;本文主要介绍CMake项目，在不改动或较小改动项目代码的情况下，如何减少编译时间。同时简要介绍其原理和使用场景。包含ccache，编译集群，
      
    
    </summary>
    
    
      <category term="优化" scheme="http://blog.lsmg.xyz/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="编译加速" scheme="http://blog.lsmg.xyz/tags/%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>CMAKE&amp;Make</title>
    <link href="http://blog.lsmg.xyz/2024/07/CPP-CMAKE/"/>
    <id>http://blog.lsmg.xyz/2024/07/CPP-CMAKE/</id>
    <published>2024-07-02T17:07:45.000Z</published>
    <updated>2025-02-27T06:39:40.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="aux-source-directory"><a href="#aux-source-directory" class="headerlink" title="aux_source_directory"></a>aux_source_directory</h1><p>今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.<br>可能会存在一些问题</p><p><a href="https://cmake.org/cmake/help/latest/command/aux_source_directory.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/latest/command/aux_source_directory.html</a></p><pre><code class="cmake"># 必须片段# CMake 最低版本号要求cmake_minimum_required (VERSION 2.8)# 项目信息project (Demo1)# 指定生成目标add_executable(Demo main.cc)# 多文件# 如果一味地在add_executable中添加源文件, 会导致太长了# 将dir目录中所有源文件保存在变量中aux_source_directory(. DIR_SOURCE)# 将变量赋值给Demoadd_executable(Demo ${DIR_SOURCE})# 多文件多目录# 需要在主目录和子文件夹中都编写CMakeLists.txt文件# 主文件添加子目录add_subdirectory(dir1)# 添加链接库target_link_libraries(Demo Foo)# dir1目录中aux_source_directory(. DIR1_SOURCE)# 生成链接库 Foo 在主文件中添加即可add_library(Foo ${DIR1_SOURCE})</code></pre><h1 id="CMAKE和MAKE之间的区别"><a href="#CMAKE和MAKE之间的区别" class="headerlink" title="CMAKE和MAKE之间的区别"></a>CMAKE和MAKE之间的区别</h1><p><a href="https://my.oschina.net/xunxun/blog/86781" target="_blank" rel="noopener">博客原文</a></p><p>自己的理解<br>通过为cmake编写CMakeList文件, cmake即可按照规则生成相应的Makefile文件<br>然后make读取Makefile文件就可以按照规则将源代码编译</p><p>总的来说cmake就是为make生成Makefile文件, (Makefile文件可以自己编写, 也可以用Cmake生成)<br>应该是编写CMakeList的代码量少于或者简单于Makefile, 简化了操作</p><h1 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a>find_package</h1><p><a href="https://zhuanlan.zhihu.com/p/97369704" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/97369704</a></p><p><a href="https://www.jianshu.com/p/a0915895dbbc" target="_blank" rel="noopener">https://www.jianshu.com/p/a0915895dbbc</a></p><p>find_package 存在两个模式</p><ul><li>module模式</li><li>config模式</li></ul><pre><code class="cmake">find_package(GLEW REQUIRED) # 先module模式再config模式find_package(GLEW REQUIRED CONFIG) # 使用config模式</code></pre><p><strong>module模式</strong></p><pre><code class="cmake">find_package(GLEW REQUIRED)if (GLEW_FOUND)    message(&quot;cannot find glew&quot;)endif()</code></pre><p>通过上述命令查找glew库，首先会去cmake的modules目录下查找对应的cmake文件。</p><p>glew对应的cmake文件为<code>FindGLEW.cmake</code></p><pre><code class="txt">C:/Application/Code/cmake-3.19.0-rc2-win64-x64/share/cmake-3.19/Modules/FindGLEW.cmake</code></pre><p><strong>config模式</strong></p><p>如果module模式对应的cmake文件不存在则启动config模式。</p><p>config模式会在如下目录搜索对应的配置文件<code>glew-config.cmake</code>或<code>GLEWConfig.cmake</code></p><p>W代表windows平台 U代表unix平台</p><pre><code class="txt">&lt;prefix&gt;/                                                       (W)&lt;prefix&gt;/(cmake|CMake)/                                         (W)&lt;prefix&gt;/&lt;name&gt;*/                                               (W)&lt;prefix&gt;/&lt;name&gt;*/(cmake|CMake)/                                 (W)&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/                 (U)&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/                       (U)&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/(cmake|CMake)/         (U)&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/         (W/U)&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/               (W/U)&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/(cmake|CMake)/ (W/U)</code></pre><p>prefix生成规则如下</p><ol><li>查找<code>GLEW_ROOT</code>的cmake变量</li><li>使用命令行<code>cmake -DCMAKE_PREFIX_PATH=/tmp/test</code></li><li>特定的cmake变量如<code>GLEW_DIR</code> <code>CMAKE_PREFIX_PATH</code></li></ol><pre><code class="cmake"># glew-config.cmakefind_path(GLEW_INCLUDE_DIR glew/include/)find_library(GLEW_LIBRARY NAMES glew32 PATHS glew/lib/Release/x64)if (GLEW_INCLUDE_DIR AND GLEW_LIBRARY)    set(GLEW_FOUND TRUE)endif()</code></pre><h1 id="相关原理"><a href="#相关原理" class="headerlink" title="相关原理"></a>相关原理</h1><pre><code class="shell">## CMake根目录生成Makefile# 使用all走这里all: cmake_check_build_system    $(CMAKE_COMMAND) -E cmake_progress_start /tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles /tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles/progress.marks    $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 all    $(CMAKE_COMMAND) -E cmake_progress_start /tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles 0.PHONY : all# 直接使用目标untitled4untitled4: cmake_check_build_system    $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 untitled4.PHONY : untitled4## CMakeFiles/Makefile2# Convenience name for target.untitled4: CMakeFiles/untitled4.dir/rule.PHONY : untitled4# Build rule for subdir invocation for target.CMakeFiles/untitled4.dir/rule: cmake_check_build_system    $(CMAKE_COMMAND) -E cmake_progress_start /tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles 3    $(MAKE) $(MAKESILENT) -f CMakeFiles/Makefile2 CMakeFiles/untitled4.dir/all    $(CMAKE_COMMAND) -E cmake_progress_start /tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles 0.PHONY : CMakeFiles/untitled4.dir/rule# All Build rule for target.CMakeFiles/untitled4.dir/all:    $(MAKE) $(MAKESILENT) -f CMakeFiles/untitled4.dir/build.make CMakeFiles/untitled4.dir/depend    $(MAKE) $(MAKESILENT) -f CMakeFiles/untitled4.dir/build.make CMakeFiles/untitled4.dir/build    @$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles --progress-num=1,2,3 &quot;Built target untitled4&quot;.PHONY : CMakeFiles/untitled4.dir/all##Shell# 生成depend$ make -f CMakeFiles/untitled4.dir/build.make CMakeFiles/untitled4.dir/dependScanning dependencies of target untitled4# 变更文件./CMakeFiles/untitled4.dir/depend.internal./CMakeFiles/untitled4.dir/depend.make./CMakeFiles/untitled4.dir/CXX.includecache# 构建$make -f CMakeFiles/untitled4.dir/build.make CMakeFiles/untitled4.dir/build[100%] Building CXX object CMakeFiles/untitled4.dir/Base.cpp.o[100%] Linking CXX executable untitled4</code></pre><pre><code class="shell"># ./CMakeFiles/untitled4.dir/depend.internalCMakeFiles/untitled4.dir/Base.cpp.o /tmp/tmp.3r11cPofBP/Base.cpp /tmp/tmp.3r11cPofBP/Base.hCMakeFiles/untitled4.dir/main.cpp.o /tmp/tmp.3r11cPofBP/Base.h /tmp/tmp.3r11cPofBP/main.cpp# ./CMakeFiles/untitled4.dir/depend.makeCMakeFiles/untitled4.dir/Base.cpp.o: ../Base.cppCMakeFiles/untitled4.dir/Base.cpp.o: ../Base.hCMakeFiles/untitled4.dir/main.cpp.o: ../Base.hCMakeFiles/untitled4.dir/main.cpp.o: ../main.cpp</code></pre><pre><code class="shell"># 生成依赖CMakeFiles/untitled4.dir/depend:    cd /tmp/tmp.3r11cPofBP/cmake-build-debug &amp;&amp; $(CMAKE_COMMAND) -E cmake_depends &quot;Unix Makefiles&quot; /tmp/tmp.3r11cPofBP /tmp/tmp.3r11cPofBP /tmp/tmp.3r11cPofBP/cmake-build-debug /tmp/tmp.3r11cPofBP/cmake-build-debug /tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles/untitled4.dir/DependInfo.cmake --color=$(COLOR).PHONY : CMakeFiles/untitled4.dir/depend# 构建CMakeFiles/untitled4.dir/build: untitled4.PHONY : CMakeFiles/untitled4.dir/builduntitled4: CMakeFiles/untitled4.dir/main.cpp.ountitled4: CMakeFiles/untitled4.dir/Base.cpp.ountitled4: CMakeFiles/untitled4.dir/build.makeuntitled4: CMakeFiles/untitled4.dir/link.txt    @$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) &quot;Linking CXX executable untitled4&quot;    $(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/untitled4.dir/link.txt --verbose=$(VERBOSE)CMakeFiles/untitled4.dir/main.cpp.o: CMakeFiles/untitled4.dir/flags.makeCMakeFiles/untitled4.dir/main.cpp.o: ../main.cpp    @$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/tmp/tmp.3r11cPofBP/cmake-build-debug/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) &quot;Building CXX object CMakeFiles/untitled4.dir/main.cpp.o&quot;    /usr/bin/g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/untitled4.dir/main.cpp.o -c /tmp/tmp.3r11cPofBP/main.cpp</code></pre><p>CMake识别变更和重新编译，是通过比对冒号左右两个文件的最后修改时间。<br>A：B A依赖B，如果B的修改时间晚于A说明A需要重新构建。</p><pre><code class="cmake">set(CurrentProtoGenP2P ${P2P_OUT_PATH_PATH}/${ProtoName}.proto.tars_Api.p2p.h)add_custom_command(OUTPUT ${CurrentProtoGenP2P}  COMMAND sh -c &quot;python2 ${P2P_SELECT_AND_BUILD} ${P2P_OUT_PATH_PATH} ${AllDirs} ${PROTOBUF_ROOT}/include/include ${Protoc} ${ProtoFile}&quot;  DEPENDS ${Protoc} ${ProtoFile}  WORKING_DIRECTORY ${Dir})list(APPEND Srcs ${CurrentProtoGenP2P})</code></pre><h1 id="include-directory"><a href="#include-directory" class="headerlink" title="include_directory"></a>include_directory</h1><p>搜寻头文件的顺序</p><ol><li>&lt;&gt; 搜索顺序: -I指定的路径, 搜索-isystem, 系统路径, -idirafter</li><li>“” 搜索顺序: 当前路径, 搜索-iquote, -I指定的路径, 搜索-isystem, 系统路径, -idirafter</li><li>CMake中include_directory对应-I</li></ol><pre><code class="CMake">function(add_unique list_var element)   # 获取当前列表   set(current_list ${${list_var}})   # 检查元素是否已经在列表中   list(FIND current_list ${element} index)   if(index EQUAL -1)      # 如果元素不在列表中，添加它      list(APPEND current_list ${element})      # 更新原始列表变量      set(${list_var} ${current_list} PARENT_SCOPE)   endif()endfunction()foreach(include_dir ${include_dirs})   message(&quot;add dir ${include_dir}&quot;)   include_directories(${include_dir})endforeach()function(include_directories_recursively base_dir dst)    # 获取当前目录的所有子目录    set(include_dirs)    file(GLOB_RECURSE header_files &quot;${base_dir}/*.h&quot; &quot;${base_dir}/*.hpp&quot;)    foreach(header_file ${header_files})        get_filename_component(header_dir ${header_file} DIRECTORY)        add_unique(include_dirs &quot;-idirafter ${header_dir}&quot;)    endforeach()    string(REPLACE &quot;;&quot; &quot; &quot; include_dirs &quot;${include_dirs}&quot;)    set(${dst} &quot;${${dst}} ${include_dirs}&quot; PARENT_SCOPE)endfunction()set(DIR_AFTER)include_directories_recursively(${CMAKE_CURRENT_SOURCE_DIR} DIR_AFTER)include_directories_recursively(${PUBINCLUDE} DIR_AFTER)message(&quot;${DIR_AFTER}&quot;)</code></pre><ol><li>idirafter 能不能起作用</li><li>为什么Make没问题</li></ol><pre><code class="CMake">function(add_unique list_var element)    # 获取当前列表    set(current_list ${${list_var}})    # 检查元素是否已经在列表中    list(FIND current_list ${element} index)    if(index EQUAL -1)        # 如果元素不在列表中，添加它        list(APPEND current_list ${element})        # 更新原始列表变量        set(${list_var} ${current_list} PARENT_SCOPE)    endif()endfunction()function(include_directories_recursively base_dir dst)    # 获取当前目录的所有子目录    set(include_dirs)    file(GLOB_RECURSE header_files &quot;${base_dir}/*.h&quot; &quot;${base_dir}/*.hpp&quot;)    foreach(header_file ${header_files})        get_filename_component(header_dir ${header_file} DIRECTORY)        add_unique(include_dirs &quot;-idirafter ${header_dir}&quot;)    endforeach()    string(REPLACE &quot;;&quot; &quot; &quot; include_dirs &quot;${include_dirs}&quot;)    set(${dst} &quot;${${dst}} ${include_dirs}&quot; PARENT_SCOPE)endfunction()set(DIR_AFTER)include_directories_recursively(${CMAKE_CURRENT_SOURCE_DIR} DIR_AFTER)include_directories_recursively(${PUBINCLUDE} DIR_AFTER)message(&quot;${DIR_AFTER}&quot;)set(SVR_NAME &quot;NewMainSvr&quot;)message(&quot;server name ${SVR_NAME}&quot;)file(GLOB_RECURSE PRJ_SRCS &quot;*.cpp&quot; &quot;*.c&quot;)#添加目标add_library(${SVR_NAME} SHARED ${PRJ_SRCS})#链接库target_link_libraries(${SVR_NAME} ${COMMON_LIBS})target_link_libraries(${SVR_NAME} &quot;i18n&quot;)set_target_properties(${SVR_NAME} PROPERTIES COMPILE_FLAGS &quot;-D__HIGH_PERFORMANCE__ ${COMMON_CPP_FLAGS} ${DIR_AFTER}&quot;)</code></pre><h1 id="CMAKE优化依赖生成"><a href="#CMAKE优化依赖生成" class="headerlink" title="CMAKE优化依赖生成"></a>CMAKE优化依赖生成</h1><pre><code class="CMake"># 生成file(GLOB CFG_FILES &quot;XML&quot;)foreach (CFG_FILE ${CFG_FILES})    get_filename_component(FILE_NAME ${CFG_FILE} NAME_WE)    set(OUT_H ${RES_INCLUDE}/${FILE_NAME}.h)    message(${OUT_H})    add_custom_command(OUTPUT ${OUT_H}            COMMAND bash ConvertCfg.sh ${CFG_FILE}            DEPENDS ${CFG_FILE}            WORKING_DIRECTORY ${RES}/script/one    )    list(APPEND XML_SRCS ${OUT_H})endforeach ()add_custom_target(XmlHeaders ALL DEPENDS ${XML_SRCS})# 添加依赖add_dependencies(${SVR_NAME} XmlHeaders)</code></pre><h1 id="CMake打进版本信息"><a href="#CMake打进版本信息" class="headerlink" title="CMake打进版本信息"></a>CMake打进版本信息</h1><pre><code class="CMake"># C.h.in#define BUILD_STAMP &quot;@BUILDDATE@&quot;# CMakeexecute_process(                COMMAND date +%F_%R:%S                OUTPUT_VARIABLE BUILDDATE                OUTPUT_STRIP_TRAILING_WHITESPACE)# 会自动填充.h.in中的值configure_file(C.h.in C.h)# 项目中include .h使用宏即可</code></pre><p><strong>不能使用add_definitions -D宏来打包, 否则每次触发cmake时, 宏的改变会导致全体重新编译.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;aux-source-directory&quot;&gt;&lt;a href=&quot;#aux-source-directory&quot; class=&quot;headerlink&quot; title=&quot;aux_source_directory&quot;&gt;&lt;/a&gt;aux_source_directory&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>如何更好的添砖加瓦2</title>
    <link href="http://blog.lsmg.xyz/2024/06/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E7%89%882/"/>
    <id>http://blog.lsmg.xyz/2024/06/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E7%89%882/</id>
    <published>2024-06-24T09:48:22.000Z</published>
    <updated>2025-02-27T06:39:40.173Z</updated>
    
    <content type="html"><![CDATA[<p>本文是2024年上半年的经验总结</p><h2 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h2><p><strong>学习新东西和分享内容虽好, 但要避免乌龙</strong></p><p>实验的场景有问题, 最后得出的结论确实想要的, 分享出去之后才发现场景的问题, 导致结论也是错的.</p><p><strong>工具最好配备文档, 继续常见问题</strong></p><p>写了工具之后, 其他人使用过程中免不了有疑问, 如果逐一回答则会耗费精力, 所以最好把常见的写到文档中, 其他人有问题, 先让对面去看文档.</p><p><strong>分享出去的工具, 在精不在多</strong></p><p>多了之后, 不精的工具会耗费精力去答疑和修改, 所以分享就要分享好用的, 而不是随手写的就分享出去.</p><p><strong>多多钻研和发现值得思考的内容</strong></p><ol><li>编译出的elf文件为什么这么大? elf文件中有哪些内容? 这些内容中哪些可以减小? 如何减小? 减小了有何影响, 这里搞完之后收获还是有的.</li><li>elf文件变大之后, gdb分析变慢, 对gdb使用火焰图发现是在解析符号表, 所以才会卡慢.</li><li>服务器占用xx内存, 这些内存占用必定有他的原因和使用位置, 如何对这些进行分析整理?</li></ol><p><strong>总迭代时间超过半年的编译发布流水线的更新记录和反思</strong></p><p>编译发布流水线经过多次修改, 有的修改甚至到了重写地步, 总结发现下为什么没有一开始就能发现这些问题.</p><ol><li>初版直接把本地的编译命令放到了流水线的shell脚本中, 开了超多条流水线, 每条都写了很多代码</li><li>写了个超长的函数更新各个submodule, 流水线的更新并不好用</li><li>要求自动更新服务器, 修改编译上传脚本将版本号保存到本地, 修改发布脚本支持读取</li><li>要求能够发布IDC的版本, 将原本初版的流水线完全拷贝了一份用来编译release版本, 区分了space导致release和debug无法混发到腾讯云</li><li>要求支持指定submodule的分支发布, 发现改所有的流水线代码比较麻烦, <strong>统一了更新部分</strong></li><li>发布重试的要求, <strong>统一了构建部分</strong></li><li>要求增加海外部分, 如果再开一条流水线将会导致数量继续增加. 直接把构建部分全写到了脚本来控制.</li><li>上传有失败, 增加了上传重试</li><li>分支有/增加了转义</li><li>流水线加上了code_branch分组功能, 防止冲突.</li><li>用分支名命名感觉还是有点问题, <strong>目前看还能抗住</strong></li><li>异常错误处理, 编译会有编译加速失败, <strong>这个还没加重试</strong></li><li>目前一个发布环境也会有多套了, <strong>不能再只用idc, test当做版本号标识了</strong>.</li><li>一步到位, 把相关信息作为msg发到平台, 更新的时候不再读取本地版本号. 不使用花里胡哨的版本号标识, 直接使用构建信息.</li></ol><p><strong>多多学习和消化公司已有的学习资源</strong></p><ol><li>Q-Learning和KM内容太多了, 可以用来扩充知识面, 还能选取感兴趣的点进行深入学习.</li><li>还可以看看已经公开的晋升文档, 看看其他人搞了什么内容, 从中选取自己感兴趣的点.</li></ol><p><strong>平时遇到的问题尽量都进行记录</strong></p><p>及时总结反思，发现问题，尽量避免后续再次出现。对自己每周每月的提升有所了解。</p><p><strong>晨会</strong></p><p>晨会同步进度. 非业务负责的也能听懂做了什么, 还剩余哪些没做。有风险及时同步，为什么有风险, 原因是什么。</p><p><strong>联调</strong></p><p>及时了解相关关系人员, 自己功能提前完成后, 即使了解和催促下相关人员, 提前联调后释放出来，防止处理其他问题时还需要抽时间联调，打乱节奏。</p><p><strong>结合业务学习技术</strong></p><p>只是想着学技术容易找不到发力点，同时学习之后不便于验证。但是结合业务学习，就有发力点，同时可以尝试进行验证。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p><strong>详细了解需求的背景和要求后再动手</strong></p><ol><li>防止一句话需求的理解存在偏差</li><li>防止实现错误, 最后还要进行修改, 如果带到了测试环境甚至线上, 修改的难度和不稳定会越来越大.</li></ol><p><strong>需求做到位即可, 防止做了没必要且无用的内容</strong></p><p>需求中一个功能本来可以用简单的方法实现, 却用了复杂的实现方式, 最后反而效果不好, 得不偿失.</p><p><strong>需求实现成本高的地方和产品沟通</strong></p><p>看看能不能换成本较低, 效果略微降低的方案.</p><p><strong>服务器命名问题</strong></p><p>新加了一大批服务器, 起初我想通过命名给这些服务器赋予功能, 但是会导致服务器的名字难以记忆, 最后分离了开来, 命名使用了简单的方式, 至于服务器的功能则额外加了一张功能表.</p><p><strong>加深自己参与的服务器各个模块的理解</strong></p><p>这样才能在商定各个服务器分工的时候, 给出合理的解释, 方便进行快速的分工.</p><p><strong>开工前的协议制定</strong></p><p>优先和其他开发定协议，协议一次性定好之后汇总发布出来，单条发送不便于查看。</p><p><strong>处理需求时进行记录</strong></p><p>配置和代码是分离的，需要记录需要改哪些配置，防止后续代码提交后存在配置未提交。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是2024年上半年的经验总结&lt;/p&gt;
&lt;h2 id=&quot;个人成长&quot;&gt;&lt;a href=&quot;#个人成长&quot; class=&quot;headerlink&quot; title=&quot;个人成长&quot;&gt;&lt;/a&gt;个人成长&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;学习新东西和分享内容虽好, 但要避免乌龙&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="个人记录" scheme="http://blog.lsmg.xyz/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="UP" scheme="http://blog.lsmg.xyz/tags/UP/"/>
    
  </entry>
  
  <entry>
    <title>massif使用</title>
    <link href="http://blog.lsmg.xyz/2024/04/Linux-massif/"/>
    <id>http://blog.lsmg.xyz/2024/04/Linux-massif/</id>
    <published>2024-04-13T16:31:22.000Z</published>
    <updated>2025-02-27T06:39:40.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>现在内存量大管饱, 优化几兆甚至几十兆, 大部分时候收益不高. 但同一个实例创造大量副本, 且这些副本共存的情况下(1000个), 优化单个实例内存的收益就会上升(1MBx1000=1GB).</p><p>进行内存优化, 首先要知晓一个实例都涉及了哪些内存分配, 由于涉及位置多和熟悉程度等原因, 导致人肉观察效率很低, 所以需要借助工具.</p><p>工具需要能够详细记录一个实例每次申请的内存大小和申请位置, 将申请大小降序排序之后, 能够方便的找到优化起来收益较大的点.</p><h1 id="massif"><a href="#massif" class="headerlink" title="massif"></a>massif</h1><p>massif就是这样的工具</p><p>样例代码</p><pre><code class="cpp">$ cat m1.cpp     #include &lt;map&gt;#include &lt;thread&gt;int foo(){    std::map&lt;int, int&gt; m;    for (int i = 0; i &lt; 1000; ++i)    {        m[i] = i;    }    return 0;}int main(){    std::thread t([](){foo();});    t.join();    return 0;}</code></pre><p>如下是massif导出的结果, 可以看到有栈被打印出来, 后面会对这些内容做简要说明</p><pre><code class="txt">$ cat 2.ms  n        time(i)         total(B)   useful-heap(B) extra-heap(B)    stacks(B)--------------------------------------------------------------------------------  0      3,994,759           56,656           40,632        16,024            0#### new分配了40,632B内存 ####71.72% (40,632B) (heap allocation functions) malloc/new/new[], --alloc-fns, etc.#### 第一个组成部分 40,000B 用 -&gt; 开头-&gt;70.60% (40,000B) 0x4037D5: __gnu_cxx::new_allocator&lt;std::_Rb_tree_node&lt;std::pair&lt;int const, int&gt; &gt; &gt;::allocate(unsigned long, void const*) (new_allocator.h:104)| -&gt;70.60% (40,000B) 0x403401: std::_Rb_tree&lt;int, std::pair&lt;int const, int&gt;, std::_Select1st&lt;std::pair&lt;int const, int&gt; &gt;, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;::_M_get_node() (stl_tree.h:370)|   -&gt;70.60% (40,000B) 0x402B80: std::_Rb_tree_node&lt;std::pair&lt;int const, int&gt; &gt;* std::_Rb_tree&lt;int, std::pair&lt;int const, int&gt;, std::_Select1st&lt;std::pair&lt;int const, int&gt; &gt;, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;::_M_create_node&lt;std::piecewise_construct_t const&amp;, std::tuple&lt;int const&amp;&gt;, std::tuple&lt;&gt; &gt;(std::piecewise_construct_t const&amp;, std::tuple&lt;int const&amp;&gt;&amp;&amp;, std::tuple&lt;&gt;&amp;&amp;) (stl_tree.h:403)|     -&gt;70.60% (40,000B) 0x402913: std::_Rb_tree_iterator&lt;std::pair&lt;int const, int&gt; &gt; std::_Rb_tree&lt;int, std::pair&lt;int const, int&gt;, std::_Select1st&lt;std::pair&lt;int const, int&gt; &gt;, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;::_M_emplace_hint_unique&lt;std::piecewise_construct_t const&amp;, std::tuple&lt;int const&amp;&gt;, std::tuple&lt;&gt; &gt;(std::_Rb_tree_const_iterator&lt;std::pair&lt;int const, int&gt; &gt;, std::piecewise_construct_t const&amp;, std::tuple&lt;int const&amp;&gt;&amp;&amp;, std::tuple&lt;&gt;&amp;&amp;) (stl_tree.h:1669)|       -&gt;70.60% (40,000B) 0x40265D: std::map&lt;int, int, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;int const, int&gt; &gt; &gt;::operator[](int const&amp;) (stl_map.h:465)|         -&gt;70.60% (40,000B) 0x40134E: foo() (m1.cpp:8)|           -&gt;70.60% (40,000B) 0x4013AE: main::{lambda()|             -&gt;70.60% (40,000B) 0x402243: void std::_Bind_simple&lt;main::{lambda()|               -&gt;70.60% (40,000B) 0x40219A: std::_Bind_simple&lt;main::{lambda()|                 -&gt;70.60% (40,000B) 0x402133: std::thread::_Impl&lt;std::_Bind_simple&lt;main::{lambda()|                   -&gt;70.60% (40,000B) 0x40ED4EF: execute_native_thread_routine (thread.cc:84)|                     -&gt;70.60% (40,000B) 0x5545EA4: start_thread (pthread_create.c:307)|                       -&gt;70.60% (40,000B) 0x5858B0C: clone (in /usr/lib64/libc-2.17.so)|  #### 第二个组成部分 576B 用 -&gt; 开头                       -&gt;01.02% (576B) 0x4012784: allocate_dtv (dl-tls.c:317)| -&gt;01.02% (576B) 0x4012784: _dl_allocate_tls (dl-tls.c:533)|   -&gt;01.02% (576B) 0x554687B: allocate_stack (allocatestack.c:539)|     -&gt;01.02% (576B) 0x554687B: pthread_create@@GLIBC_2.2.5 (pthread_create.c:447)|       -&gt;01.02% (576B) 0x40ED73E: __gthread_create (gthr-default.h:662)|         -&gt;01.02% (576B) 0x40ED73E: std::thread::_M_start_thread(std::shared_ptr&lt;std::thread::_Impl_base&gt;) (thread.cc:142)|           -&gt;01.02% (576B) 0x4014CD: std::thread::thread&lt;main::{lambda()|             -&gt;01.02% (576B) 0x4013CC: main (m1.cpp:15)|               -&gt;00.10% (56B) in 1+ places, all below ms_print&#39;s threshold (01.00%)</code></pre><p>使用grep提取实际分配内存的大小和位置并进行排序, 可以看到0x4037D5分配了40000B的内存, 回上文中查找, 找到是<code>0x40134E: foo() (m1.cpp:8)</code>触发的分配.</p><pre><code class="txt">$ grep &quot;^-&gt;&quot; 2.ms | grep -v &quot;all below ms_print&quot; | awk -F &#39;[():]&#39; &#39;{gsub(&quot;,&quot;,&quot;&quot;);print $2,$3}&#39; | sort -nr40000B  0x4037D5576B  0x4012784</code></pre><p>假设上文是一个副本分配的内存, 再进行一次副本创建则会得到下面的结果.</p><pre><code class="txt">$ grep &quot;^-&gt;&quot; 3.p | grep -v &quot;all below ms_print&quot; | awk -F &#39;[():]&#39; &#39;{gsub(&quot;,&quot;,&quot;&quot;);print $2,$3}&#39; | sort -nr80000B  0x4037D5576B  0x4012784</code></pre><p>用两次0x4037D5位置的内存相减, 差值就是一个副本所需要的大小</p><p>将所有差值排序后 就是一个副本涉及的新增的内存, 可以根据地址从大到小逐一排查是否可以进行优化(如副本见共享同一份数据, 避免多次创建)</p><pre><code class="txt">40000B 0x4037D5</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><pre><code class="sh"># threshold默认是1, 越小记录的精度越高, 如果过大会导致记录被合并无法展示细节, 这里指定的0,001# m1是二进制名称 valgrind --tool=massif --threshold=0.001 ./m1</code></pre><p>问题: massif默认会记录程序从启动开始所有的内存, 且是基于无法控制且数量有限的快照机制</p><ol><li>如果服务器需要较长时间初始化, 则会在初始化时消耗掉所有快照, 无法记录后续副本创建的分配.</li><li>快照是无法控制的, 无法方便的获得副本创建前后的内存消耗</li></ol><p>所以需要手动进行快照</p><pre><code class="sh"># A窗口$ valgrind --tool=massif --threshold=0.001 --vgdb=yes --vgdb-error=0 ./m1==28781== Massif, a heap profiler==28781== Copyright (C) 2003-2017, and GNU GPL&#39;d, by Nicholas Nethercote==28781== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info==28781== Command: ./m1==28781== ==28781== (action at startup) vgdb me ... ==28781== ==28781== TO DEBUG THIS PROCESS USING GDB: start GDB like this==28781==   /path/to/gdb ./m1==28781== and then give GDB the following command==28781==   target remote | /usr/local/libexec/valgrind/../../bin/vgdb --pid=28781==28781== --pid is optional if only one valgrind process is running==28781== </code></pre><pre><code class="sh"># B窗口gdb ./m1# 输入上文的提示target remote | /usr/local/libexec/valgrind/../../bin/vgdb --pid=28781# 副本创建之前下断点b 6# 运行r# 此时来到副本创建之前的位置# 手动拍摄快照记录到1.mmonitor detailed_snapshot 1.m # 再次运行# 此时将要创建第二个副本, 也就意味着第一个副本创建完毕# 手动拍摄快照记录到2.mmonitor detailed_snapshot 2.m # 杀掉valgrindmonitor v.kill# 退出gdbquit</code></pre><p>对快照的原始数据进行处理, 就得到了开头的2.ms文件和格式化后的文件, 使用Excel对1.mp和2.mp相同地址的部分计算差值即可.</p><pre><code class="sh">ms_print 1.m &gt; 1.msms_print 2.m &gt; 2.msgrep &quot;^-&gt;&quot; 1.ms | grep -v &quot;all below ms_print&quot; | awk -F &#39;[():]&#39; &#39;{gsub(&quot;,&quot;,&quot;&quot;);print $2,$3}&#39; | sort -nr &gt; 1.mpgrep &quot;^-&gt;&quot; 2.ms | grep -v &quot;all below ms_print&quot; | awk -F &#39;[():]&#39; &#39;{gsub(&quot;,&quot;,&quot;&quot;);print $2,$3}&#39; | sort -nr &gt; 2.mp</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;现在内存量大管饱, 优化几兆甚至几十兆, 大部分时候收益不高. 但同一个实例创造大量副本, 且这些副本共存的情况下(1000个), 优化单个
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>常事UP</title>
    <link href="http://blog.lsmg.xyz/2024/03/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E5%B8%B8%E4%BA%8BUP/"/>
    <id>http://blog.lsmg.xyz/2024/03/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E5%B8%B8%E4%BA%8BUP/</id>
    <published>2024-03-23T14:48:22.000Z</published>
    <updated>2025-02-27T06:39:40.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="旅游想省1000多块钱买了2号回程机票，后面有人一起合租，改成4号"><a href="#旅游想省1000多块钱买了2号回程机票，后面有人一起合租，改成4号" class="headerlink" title="旅游想省1000多块钱买了2号回程机票，后面有人一起合租，改成4号"></a>旅游想省1000多块钱买了2号回程机票，后面有人一起合租，改成4号</h1><p>原价890，改签费530，机票差价1100, 花了1630还不是和团一个飞机。最后团的飞机降价了还不到1600，最后2500买了1600的机票，血亏900.</p><p>后面出去还是早点组团订机票，不要心疼这一点了。</p><ol><li>电子设备: 手环, 手机, 手机充电器线, 耳机, 充电宝</li><li>洗面奶, 保湿, 几个牙线</li><li>证件类: 护照, 身份证, 港澳通行证(可无)</li><li>现金2W, 交通卡, visa卡, 手机卡, 卡针</li><li>路雷他定, 地奈德, 口罩</li><li>袜子内衣x3(4) 优先破旧的, 背心裤子x2, 外套?</li><li>遮阳伞</li><li>牙刷, 牙膏, 小洗衣液</li><li>眼镜布</li><li>指甲刀</li></ol><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><ol><li>visa卡换绑定手机</li><li>胡子, 手脚指甲</li><li>手环充满电(续航开一下)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;旅游想省1000多块钱买了2号回程机票，后面有人一起合租，改成4号&quot;&gt;&lt;a href=&quot;#旅游想省1000多块钱买了2号回程机票，后面有人一起合租，改成4号&quot; class=&quot;headerlink&quot; title=&quot;旅游想省1000多块钱买了2号回程机票，后面有人一起
      
    
    </summary>
    
    
      <category term="个人记录" scheme="http://blog.lsmg.xyz/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="UP" scheme="http://blog.lsmg.xyz/tags/UP/"/>
    
  </entry>
  
  <entry>
    <title>排行榜</title>
    <link href="http://blog.lsmg.xyz/2024/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%8E%92%E8%A1%8C%E6%A6%9C/"/>
    <id>http://blog.lsmg.xyz/2024/01/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%8E%92%E8%A1%8C%E6%A6%9C/</id>
    <published>2024-01-25T14:38:08.000Z</published>
    <updated>2025-02-27T06:39:40.173Z</updated>
    
    <content type="html"><![CDATA[<ol><li>排行榜到处都是</li><li>什么样的场景下使用什么样的排行榜设计? 为什么? 选取这个有什么优点和缺点, 是否牺牲了什么.</li></ol><p>魔法棒: 即时(瞬间更新), 无上限, 支持多种子表单(年季月周日时分, 标签), 数据绝对安全, 不消耗硬件(网卡, 磁盘, CPU, 内存), 先到先得.</p><p>数据: 玩家ID, 数据值. 两个int64_t 16B, 亿人, 100 000 000 * 16 = 1600MB? 玩家ID做Key会不会有啥问题? 有没有其他数据?</p><p>CPU, 即时(瞬间更新):<br>无上限: 存储 + 更新限制<br>一键瞬间导出多种报表(年季月周日时分, 标签)<br>数据绝对安全<br>网卡: 分标签拉取? 子表单, 数据量怎么说都不会小, 分页拉取是必须的.<br>存储: 磁盘, 内存 只是玩家ID, 数据值的话 貌似不成问题.<br>先到先得: 稳定排序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;排行榜到处都是&lt;/li&gt;
&lt;li&gt;什么样的场景下使用什么样的排行榜设计? 为什么? 选取这个有什么优点和缺点, 是否牺牲了什么.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;魔法棒: 即时(瞬间更新), 无上限, 支持多种子表单(年季月周日时分, 标签), 数据绝对安全, 不消
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>编译加速</title>
    <link href="http://blog.lsmg.xyz/2023/12/%E4%BC%98%E5%8C%96-%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F/"/>
    <id>http://blog.lsmg.xyz/2023/12/%E4%BC%98%E5%8C%96-%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F/</id>
    <published>2023-12-13T14:48:22.000Z</published>
    <updated>2025-02-27T06:39:40.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="编译时间统计"><a href="#编译时间统计" class="headerlink" title="编译时间统计"></a>编译时间统计</h2><pre><code class="shell"># g++.shreal_compiler=&quot;/usr/bin/g++&quot;filename=$(echo $* | grep -o &quot;\ -c .*&quot;)output=&quot;/root/stat.log&quot;/usr/bin/time -f &quot;%U-%S $filename&quot; -a -o $output $real_compiler $*# $export CXX=g++.shmkdir b2 &amp;&amp; cd b2 &amp;&amp; cmake .. -DCMAKE_BUILD_TYPE=debug &amp;&amp; make -j24 BigWorldServer</code></pre><h2 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h2><pre><code class="shell">nm a.cpp.o | awk &#39;NF&gt;=2 {print $(NF-1)}&#39; | sort | uniq -c     15 b bss段   2506 n debug符号   2394 r rodate段     36 t text段      1 T global text?     71 u unique global symbol    448 U 未定义符号, 链接阶段会去寻找    426 V 弱符号      4 w   11854 W 弱未定义符号</code></pre><h1 id="全量编译"><a href="#全量编译" class="headerlink" title="全量编译"></a>全量编译</h1><ol><li>减少非必须要的编译项目<ol><li>单元测试类</li></ol></li><li>unitybuild减少编译单元(核心是减少头文件的重复编译)<ol><li>将多个cpp合并编译. 减少重复头文件的耗时</li></ol></li><li>使用预编译头减少编译单元的耗时(核心是减少头文件的重复编译)<ol><li>将耗时常用且不经常修改的加入到其中</li></ol></li><li>proto<ol><li>避免协议文件被头文件引用, 采用前置声明+定义和实现分离的方式, 将协议头文件放到cpp文件中.</li><li>避免超大proto文件, 根据使用范围和频率进行分割, 减少proto变更影响的范围.</li><li><strong>自动生成的proto是重灾区, 这些proto代码一个比一个量大.</strong></li></ol></li></ol><h1 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h1><p>CMake相关</p><ol><li>优化CMake等脚本, 不每次全量生成新文件, 而是配置依赖变更后才生成, 减少非必要的变更.</li></ol><p>枚举解耦<strong>未实操</strong></p><ol><li>减少枚举文件变更导致的重编, 提供STR到INT的映射<ol><li>开发期做这种替换</li><li>发布期换回正常方式</li></ol></li></ol><h1 id="链接加速"><a href="#链接加速" class="headerlink" title="链接加速"></a>链接加速</h1><p><a href="https://github.com/rui314/mold" target="_blank" rel="noopener">mold</a></p><p>更好的链接算法和使用多线程链接</p><p>使用之前</p><pre><code class="txt"> Performance counter stats for &#39;make BigWorldServer&#39;:         29,993.61 msec task-clock                #    0.999 CPUs utilized                         148      context-switches          #    0.005 K/sec                                  26      cpu-migrations            #    0.001 K/sec                             777,595      page-faults               #    0.026 M/sec                     &lt;not supported&gt;      cycles                                                         &lt;not supported&gt;      instructions                                                   &lt;not supported&gt;      branches                                                       &lt;not supported&gt;      branch-misses                                                     30.008942931 seconds time elapsed      27.920985000 seconds user       2.075018000 seconds sys</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h1&gt;&lt;h2 id=&quot;编译时间统计&quot;&gt;&lt;a href=&quot;#编译时间统计&quot; class=&quot;headerlink&quot; title=&quot;编译时间统计&quot;&gt;&lt;/a&gt;编
      
    
    </summary>
    
    
      <category term="优化" scheme="http://blog.lsmg.xyz/categories/%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="编译加速" scheme="http://blog.lsmg.xyz/tags/%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>方向选择</title>
    <link href="http://blog.lsmg.xyz/2023/12/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/"/>
    <id>http://blog.lsmg.xyz/2023/12/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/</id>
    <published>2023-12-11T19:48:22.000Z</published>
    <updated>2025-02-27T06:39:40.173Z</updated>
    
    <content type="html"><![CDATA[<ol><li>深入业务, 不只关注分配到的任务, 看看任务的上下游 关注下整体实现, 毕竟其他服务器的代码都有, 甚至还可以看公共服务的代码<ol><li>从客户端数据进来到回包回去的流程, 确实可以看看</li><li>对整体有把握才能知道可以优化的地方.</li></ol></li><li>性能压测, 编译优化</li><li>KM, 对于某个需求点(如排行榜), 可以看看一个排行榜有多少种实现方式, 每种方法的坑.</li><li>KM, 可以多看看极有可能发现预期之外的感兴趣的点, 一旦用到项目上直接UPUP.</li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>不喜欢这个方面还是算了, 有开源的不用白不用. 项目里的无锁队列一年半了也没认真看过.</p><h1 id="工具侧"><a href="#工具侧" class="headerlink" title="工具侧"></a>工具侧</h1><p>针对开发中遇到的问题, 对于能够自动化的想法提供自动化工具, 优化已有工具的体验.</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>工具与工具之间独立性强, 很容易就能写出一个新的工具, 投入少见效快</li><li>对于新的工具, 每次处理的时候也算是能了解一点内容</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>后续需要进行工具的维护, 占用时间</li><li>工具就算写好了搭配上文档, 也会有人@你去处理, 占用时间, 重复操作比较麻烦.</li><li>难于出什么深度内容</li></ol><h2 id="做过的尝试"><a href="#做过的尝试" class="headerlink" title="做过的尝试"></a>做过的尝试</h2><ol><li>GM工具优化: 这个一直在用, 属于是评价比较好的, 改动也不是很大, 主要是提高了效率.</li><li>Wireshark抓包, 后台抓包工具: 前者运行在Windows机器无法支持解密, 也没法进行良好的操作和筛选. 后者运行在服务器, 支持解析. 最终都是没有太合适的应用场景, 没人用, 也就没维护了, 预期有更高级版本, 但是现在不想写工具.</li><li>服务器自动冒烟: 这个也是在用, 自动构建内网or外网的服务器, 发布服务器和配置. py脚本也不太熟练, 写的时候也比较折磨.</li><li>日志分析: 相对简单的脚本, 但是人要一直投入在上面. 就算有文档也会被@去处理. 后面尝试接入骏鹰来解决, 但感觉可能又要维护骏鹰.</li></ol><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p>最近半年也算是没有写新的工具, 主要是维护自动冒烟, 日志分析(可能要负责维护骏鹰).</p><p>目前比较排斥写工具类的, 感觉没有学到太多的深度的东西, 写了之后就要负责维护和答疑甚至绑在上面操作.</p><h1 id="服务器优化"><a href="#服务器优化" class="headerlink" title="服务器优化"></a>服务器优化</h1><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>感觉比较高大上, 而且难点是找到问题在哪里</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>做起来太难了, 完全没这方面经验, 没有什么大的成果.</p><h2 id="做过的尝试-1"><a href="#做过的尝试-1" class="headerlink" title="做过的尝试"></a>做过的尝试</h2><p>Prometheus+Grafana提供的火焰图插件: 感觉这个也没什么深度的样子, 只做了一个火焰图的插件, 感觉虽然能看到 但还是找不到热点的优化方法, 不是很便宜大碗. 受限于采集频率</p><p>编译加速: 这个感觉还是挺爽的, 文件变更数量较少情况下, 编译速度大幅优化了. <strong>但是没能做到进一步深入优化</strong>.</p><p>bpf: 这个最终甚至都没学完, 也是感觉无法落地.</p><p>服务器二进制包大小优化: 都是有损优化, 想无损的话还是没啥用途.</p><h2 id="体验-1"><a href="#体验-1" class="headerlink" title="体验"></a>体验</h2><p>高大上, 经验积累性质强, 成本高, 难于出成果.</p><h1 id="业务仔"><a href="#业务仔" class="headerlink" title="业务仔"></a>业务仔</h1><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><p>培养代码的基本功</p><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><p>适量的话倒是没什么缺点</p><h2 id="体验-2"><a href="#体验-2" class="headerlink" title="体验"></a>体验</h2><p>一直在积累相关的经验, 最近半年整理的也发布出去了, 后面也打算继续整理和发布, 也算是正向的吧.</p><p>反正需求一直会有的, 这方面还是不太额外花时间了.</p><h1 id="重构or架构优化"><a href="#重构or架构优化" class="headerlink" title="重构or架构优化"></a>重构or架构优化</h1><h2 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h2><h2 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h2><ol><li>这个更难了, 上面的优化章节还不需要对服务器有太多深入了解, 这里就需要找到问题, 并且有能力进行改动.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;深入业务, 不只关注分配到的任务, 看看任务的上下游 关注下整体实现, 毕竟其他服务器的代码都有, 甚至还可以看公共服务的代码&lt;ol&gt;
&lt;li&gt;从客户端数据进来到回包回去的流程, 确实可以看看&lt;/li&gt;
&lt;li&gt;对整体有把握才能知道可以优化的地方.&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="个人记录" scheme="http://blog.lsmg.xyz/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="方向选择" scheme="http://blog.lsmg.xyz/tags/%E6%96%B9%E5%90%91%E9%80%89%E6%8B%A9/"/>
    
  </entry>
  
  <entry>
    <title>如何更好的添砖加瓦</title>
    <link href="http://blog.lsmg.xyz/2023/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E7%89%88/"/>
    <id>http://blog.lsmg.xyz/2023/11/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E7%B2%BE%E5%8D%8E%E6%95%B4%E7%90%86%E7%89%88/</id>
    <published>2023-11-25T09:48:22.000Z</published>
    <updated>2025-02-27T06:39:40.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>记录总结了从7月到11月积累的非技术经验, 涉及添砖加瓦方方面面.</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是自己从7月到11月积累的部分非技术经验, 总结了工作记录中遇到的问题. 由于是个人经验积累, 适用性不强, 也不是大而全. 发布出来主要还是用于自己自勉, 整理了, 不发出来有感觉浪费.</p><h1 id="史山之从设计到制作"><a href="#史山之从设计到制作" class="headerlink" title="史山之从设计到制作"></a>史山之从设计到制作</h1><h2 id="需求设计"><a href="#需求设计" class="headerlink" title="需求设计"></a>需求设计</h2><p><strong>需求评审</strong><br>评审时, 如果不是很确定这部分功能, 自己负责的服务器能不能做, 就不要承接下来, 最后发现做不了, 再转手.</p><p><strong>需求文档到手</strong></p><ol><li>从需求文档中找到需求点, 协商好需求点由哪个服务器来处理, 防止开发重复内容或者无人处理. 或者由于种种原因是对方压根做不了, 只能自己来做.</li><li>尽量避免想当然的情况, 比如文档中说每天增加一次挑战次数, 但是没有提初始次数是多少次, 这时候最好沟通下.</li><li>虽然可能不清楚其他需求, 但还是尽量能够判断下和其他需求是否有重叠, 导致出现边界情况, 对好这个时候怎么处理.</li></ol><p><strong>需求文档看完, 开工之前, 先定协议</strong></p><p>定完协议之后, 各个参与人就可以独立开发. 如果先开发再定协议, 可能导致后定的协议不便于所有人使用.</p><p><strong>开工之前, 进行下预期设计, 同时评估时间</strong></p><ol><li>写代码之前先在vscode进行下预期设计, 写写伪代码. 虽然需求可能要的比较紧急, 但花一点时间提前设计下, 比直接撸起袖子开干还是感觉最终效率好很多.<ol><li>代码放到哪个模块</li><li>这个功能大概是什么流程</li></ol></li><li>预期设计完成后, 根据<strong>功能点和设计</strong>, 能够更加准确的进行排期.</li><li>根据需求工作量确定下复杂程度. 虽然完善的设计很重要, 但有时会因为过于完善, 导致简单的需求变得非常复杂, 同时后续也不一定用得上这次设计的完善机制.</li><li>预期下异常情况处理和兜底处理</li></ol><h2 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h2><p><strong>将重复的项目抽取出来</strong><br>第一次做的时候, 可能考虑到需求比较简单或者时间不足, 一个功能就放在了一起实现, 但是后续又双叒叕用到这个功能了.对于个人提升来说, 就可以考虑抽取出来了.</p><p><strong>做好兼容性处理</strong></p><p>负责的功能要将兼容性处理做完善, 能够做到其他人无感知是最好的. 不要想着其他人只需要小小的一点处理就能解决, 到时候不管提示再多次都会有人@问什么问题的, 所以最优解是其他人无感知.</p><p><strong>预估时间后无法完成后, 要及时周知相关人员</strong></p><p>应该及时通知，否则默认你这边完成了, 其他人进行了一些处理, 导致不必要的问题出现.</p><p><strong>开发的时候加足DEBUG日志</strong></p><ol><li>遇到问题的时, 查日志相对看代码是效率非常高的解决方式.</li><li>加日志的位置和内容还是吃经验. 个人感觉站在将来查问题的角度去加日志有帮助.</li><li>DEBUG日志一般会在线上关闭, 一些重要内容就要注意使用更高的等级, 否则一点日志都没, 外网问题全靠复现才能查.</li></ol><p><strong>个人统一的工具仓库</strong><br>工作中难免会写出来一些小工具, 提供给他人使用的时候一般都是放到公共代码库中, 这个时候工具就会在本地和公共代码库有两份, 注意只在一个地方修改, 否则容易出现不一致.</p><p><strong>需求中途变更后简化代码</strong></p><p>代码设计初期一般会留有一些考虑能够应对需求变化，但是需求变化后可能会导致实现可以简化，这个时候继续复用复杂的代码还是简化代码就需要考虑了.</p><p><strong>代码尽量一步成型</strong><br>个人感觉修改次数越多, 出问题的概率越高, 修改了这里忘记了同步修改其他地方是重灾区.</p><p><strong>避免设计无用的东西</strong><br>一些本来加个函数就能解决问题的, 是否要抽成一个模块就要仔细考虑下了.</p><p><strong>数值类配置化or计算化</strong></p><ol><li>数值类的最好不要写死<ol><li>如果是配置中的值，配置变了，写死的数值就会导致问题</li><li>还可能导致本来热更就能搞定的，需要重新编译服务器</li></ol></li><li>尽量不要写死参数, 配置或者计算得来, 否则后面还需要同步修改.</li></ol><p><strong>减少通用错误码的使用</strong></p><p>如果错误码一对一能够及时发现问题, 如果是多个地方使用的, 只能靠日志+看代码路径了.</p><p><strong>客户端参数校验</strong></p><p>老生常谈了, 基本上每本书里都会提这点, 这次就出现了所有服务器都没校验的一个操作, 甚至是客户端都没检验.</p><p><strong>状态校验放错了位置. 写的时候还是没考虑好运行路径</strong></p><p>加代码的时候, 仔细考虑好相关的运行路径. 可能某个分支下, 这次加的就是有问题的.</p><p><strong>加快调试速度</strong></p><p>需求写完之后, 想要测试下自己的代码, 尽量将GM工具完善好, 否则每次修改代码都要重复操作好几步, 导致花费的时间反而比加一下工具要多.</p><ul><li>副作用, GM工具要标注下使用场景, 否则错误场景使用后容易出乌龙问题.</li></ul><h1 id="史山之从修改到回归"><a href="#史山之从修改到回归" class="headerlink" title="史山之从修改到回归"></a>史山之从修改到回归</h1><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p><strong>修改前-不确定是bug还是feature时要进行确认</strong><br>否则可能将feature作为bug处理了, 后续还要改回来, 造成不必要的时间浪费或者麻烦.</p><p><strong>修改前-遇到BUG还是感觉留下现场，比重启解决问题更加重要</strong></p><p>问题可以后面解决，复现问题可能再也没有机会了</p><p><strong>修改前-简单方式解决问题</strong></p><p>对于一个小bug, 简单的打个补丁就可以解决的话, 还是偏向于打补丁. 至于刨根问题解决虽然好, 但是一旦牵扯过多, 然后自己对项目不了解, 大刀阔斧重构容易出问题.</p><p><strong>查问题中-用物体的事件经过查问题挺方便的</strong></p><p>事件驱动的场景下, 可以先查询顶层都有那些事件, 看看这些事件的内容和实际是否正确, 比一下钻到底层查问题要快很多.</p><p><strong>影响扩大-确定修改后果, 注意一个函数都有哪些作用</strong></p><ol><li>一个函数可能不是你想的那种作用, 或者带有一些条件, 再或者是副作用. 之前没有使用过的, 不熟悉的最好看一看实现.</li><li>修改一处代码的时候, 考虑全面是否会波及其他调用方</li></ol><p><strong>影响扩大-抽取函数注意不要影响到原区域功能</strong></p><p>发现一段代码可以复用的时候, 会从其他函数中将这个函数抽取出来. 但是抽出来的函数增加代码的时候, 注意不要影响到原位置. 如在抽取出来的函数中, 由于其他需求, 增加了一层判断, 导致原位置(抽取函数前的位置)功能被影响.</p><p><strong>影响扩大-enum中增加新类型</strong></p><p>enum中增加新类型后要注意看看这个enum的使用位置, 如果只是关注自己新写的代码忽略旧代码, 可能导致旧代码的判断过不去.</p><p><strong>修改后-BUG修复关联BUG单</strong></p><p>否则后续会忘记为啥修改这里, 当时是什么BUG做出的这样的处理.</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>尽可能进行全面的自测</strong></p><p>真的有某些代码是依靠BUG运行的, 修复BUG之后反而运行不了了, 所以基本的测试是必需的, 能想到的可能影响到的地方, 最好也是自测一下. 想到的地方不去测一下的话, 可能就是想到的这个地方出了问题.</p><p><strong>A通过B通过不等于A+B通过</strong></p><p>一个功能还是完整的测试吧，A功能虽然等于B+C功能，但B和C功能分别正确 不一定B+C就是正确的</p><p><strong>自动化测试</strong></p><p>一些功能测起来可能比较麻烦, 使用自动化工具会方便很多, 比如pyclient完全模拟一个客户端, 写代码有时候比点来点去构建测试环境方便很多.</p><h1 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h1><p><strong>问题的优先级安排</strong></p><p>并行处理任务的时候, 注意优先级的安排. 可能当前的工作进行到一半, 有其他高优先级的工作要做的话, 还是要切过去. 尤其是查BUG到一半的时候, 很容易上头, 导致又多查了半天.</p><p><strong>充分关注自己的工作</strong></p><p>其他人都开始要联调了, 自己的功能还没发布到服务器上. 虽然当时在处理其他问题, 但还是已经做过的善后优先一些.</p><p><strong>不懂就问</strong></p><p>文档较少, 全靠口口相传, 遇到不懂得项目, 一定要进行询问, 不能常识性的去做.</p><p><strong>重视不起眼的小问题，可能背后的原因是非常离谱的</strong></p><p>遇到过不止1-2次了, 看起来就是很小的一个问题, 深究起来问题可能一串一串的.</p><p><strong>特殊处理</strong></p><p>没有注释的代码, 可能使用了一些特殊规定, 如果错误删掉了就会影响到功能. 比如数值是0的时候, 按照1来处理, 看描述很简单, 但是实际代码可能没有那么直观.</p><p><strong>预期下当前所做是不是可以解决最终问题, 而不是当前某一步</strong></p><p>当前所做可能确实能解决当前问题, 但是不一定能解决最终问题. 比如传输日志之前需要压缩, 压缩成几个小包也是压缩, 压缩成超大包也是压缩, 但是压缩成超大包可能不利于传输和解压.</p><p><strong>去看看别人负责的模块, 不要只顾自己的模块</strong></p><p>对于多模块(多服务器)后台, 多去关注下自己负责模块之外的内容, 这样对项目了解的更深.</p><p><strong>问题的原因, 不一定是第一印象想到的点</strong></p><p>遇到问题即使下意识感觉问题就是那里, 也一定要确认下. 可能并不是那样.</p><h1 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h1><p><strong>他人回复的内容一定要仔细理解，不要含主观臆断</strong></p><ol><li>X场景下，……………………………（省略），这个功能就不需要了。（非X场景是需要的，不能直接删掉这个功能）</li><li>今天晚上就合入版本了（几点？能不能在全量发布服务器前完成，而不是晚上这种模糊时间）</li></ol><p><strong>后台开发代表全部后台, 前台开发代表全部前台</strong></p><p>后台有多个服务器，每个服务器不同的人负责，前台可能认为后台是一个整体，所以找你沟通的时候最好不要只考虑本服务器的事情, 有需要就拉上其他服务器的一起建群.</p><p><strong>帮忙</strong></p><p>帮忙处理东西的时候，要问清楚原因, 搞清楚要做啥, 不能只是直接照做.</p><p><strong>对应的事情尽量给对应的人去做</strong></p><p>运维可以通过内网传输日志, 比通过sz和rz快和稳定很多.</p><h1 id="36技"><a href="#36技" class="headerlink" title="36技"></a>36技</h1><p><strong>CR发起前可以自己整一个临时CR看看代码</strong></p><p>每次提交代码前, 全局的看一看自己的代码, 可能功能正确, 但是有不小心动到其他地方的代码.</p><p><strong>测试代码在最终CR的时候要及时去掉 使用TODO 名字方便检索</strong></p><p>使用TODO标记测试代码, 提交前批量查找下, 全部去掉.</p><p><strong>不建议手动操作流水线</strong></p><p>流水线中某一步错误后, 尽量重新触发流水线. 手动执行错误的一步, 很容易出错, 漏掉某些操作.</p><p><strong>自动化操作没有监管人</strong></p><p>流水线有的没有人监管, 即使将结果通知到了使用者, 使用者可能也会忽视结果, 导致有错误没有发现, 进而导致其他问题. 所以错误提示要尽可能的明显.</p><p><strong>压测和扩容</strong></p><ol><li>压测<ol><li>压测场景和实际场景不匹配<ol><li>出现问题之后，都能发现问题，关键是出现问题前发现限制点</li></ol></li></ol></li><li>扩容<ol><li>重要节点前, 预备一些机器, 否则出问题的时候, 机器没办法即时拿到.</li></ol></li></ol><p><strong>发现问题比解决问题更重要</strong></p><p>性能优化感觉难点是发现性能问题, 包括编译加速. (20%的问题造成了80%的负面影响, 如果去处理另外80%的问题收益就很低)</p><p><strong>指定时间点触发的循环定时器, 每轮都计算下时间相比固定时间的更加稳定</strong></p><p><strong>尽量统一函数对统一内容进行清除, 比如标志位, 这样方便发现错误清理的地方</strong></p><p><strong>测试东西或者搞新东西的时候, 注意不要影响到旧功能</strong></p><p>该开测试空间的开测试空间, 防止影响到其他空间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;记录总结了从7月到11月积累的非技术经验, 涉及添砖加瓦方方面面.&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=
      
    
    </summary>
    
    
      <category term="个人记录" scheme="http://blog.lsmg.xyz/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="UP" scheme="http://blog.lsmg.xyz/tags/UP/"/>
    
  </entry>
  
  <entry>
    <title>如何实现火焰图半自由</title>
    <link href="http://blog.lsmg.xyz/2023/11/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-PrometheusX%E7%81%AB%E7%84%B0%E5%9B%BE/"/>
    <id>http://blog.lsmg.xyz/2023/11/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-PrometheusX%E7%81%AB%E7%84%B0%E5%9B%BE/</id>
    <published>2023-11-18T12:50:02.000Z</published>
    <updated>2025-02-27T06:39:40.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Linux服务器端可以使用profile生成火焰图. profile从运行开始收集数据, 结束运行时将结果输出, 过了这村就没这店.</p><p>有没有可能持续使用profile进行采集, 将数据收集起来, 然后查询任意时间段的火焰图?</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>答案是√, 使用Prometheus存储profile采集的数据, 使用Grafana的火焰图插件(V9.5.2)将结果展示出来. <strong>本文结束, 感谢观看!</strong></p><h1 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h1><ol><li><p>profile的原始数据是栈调用(隐含时间信息), 火焰图是树状结构(丢失时间信息), 如果想要查询任意时间段就要存储原始栈调用数据和其对应的时间.</p></li><li><p>Grafana提供了火焰图插件, 但是只接受火焰图数据, Prometheus中存储的原始栈数据无法直接使用.</p></li><li><p>Grafana和Prometheus对字符串的处理能力极差</p></li></ol><p>所以需要实现一个Proxy, 接受Grafana的查询请求, 转去请求Prometheus, 将结果进行处理后返回Grafana进行展示.</p><h1 id="PrometheusProxy实现"><a href="#PrometheusProxy实现" class="headerlink" title="PrometheusProxy实现"></a>PrometheusProxy实现</h1><h2 id="profile输出"><a href="#profile输出" class="headerlink" title="profile输出"></a>profile输出</h2><p><code>threadname;stack0;stack1;stack2 num</code></p><p><code>threadname;stack1;stack4;stack2 num</code></p><p>线程名, 栈帧, 采集到的数量. 这些数据将会上报到Prometheus中进行存储.</p><p>上报的格式需要依照Prometheus要求进行下格式化, 这里就不详细介绍了, 只需要知道Prometheus中存储了这些原始的数据(时间, 栈, 对应采集的次数)即可.</p><h2 id="Grafana查询协议"><a href="#Grafana查询协议" class="headerlink" title="Grafana查询协议"></a>Grafana查询协议</h2><pre><code class="txt"># URL/api/v1/query_range# BODYend=1694848740&amp;query=cpu_func_profile{processname=&quot;HelloServer&quot;}&amp;start=1694827140&amp;step=15</code></pre><p>start 起始时间<br>end 结束时间<br>query 向Prometheus请求的表达式<br>step 步长</p><h2 id="Prometheus协议"><a href="#Prometheus协议" class="headerlink" title="Prometheus协议"></a>Prometheus协议</h2><pre><code class="go">// Prometheus请求协议即是上面的Grafana协议// Prometheus回应协议是如下结构对应的json数据type PrometheusReportData struct {    Status string `json:&quot;status&quot;`    Data   struct {        ResultType string `json:&quot;resultType&quot;`        Result     []struct {            Metric struct {                Name     string `json:&quot;__name__&quot;`                Instance string `json:&quot;instance&quot;`                Job      string `json:&quot;job&quot;`                Stack    string `json:&quot;stack&quot;`            } `json:&quot;metric&quot;`            Values [][]any `json:&quot;values&quot;`        } `json:&quot;result&quot;`    } `json:&quot;data&quot;`}</code></pre><p>将完整的Grafana请求转发给Prometheus, Prometheus会进行筛选和合并后返回, 所以无需对结果进行额外处理, 只需要从其中拿到汇总后的栈数据即可.</p><p>stack: 这个是我们上报的栈数据<code>stack0;stack1;stack2</code></p><p>Values: 是Value的数组, Value有且仅有两个元素, 第一个元素是数据对应的时间戳, 第二个元素是栈数据的<code>num</code></p><p>所以遍历所有数据统计出一个<code>map&lt;stack, num&gt;</code>, Prometheus的任务就完成了.</p><h2 id="Grafana火焰图插件回包json格式"><a href="#Grafana火焰图插件回包json格式" class="headerlink" title="Grafana火焰图插件回包json格式"></a>Grafana火焰图插件回包json格式</h2><pre><code class="go">type Metric struct {    Name     string `json:&quot;__name__&quot;`    Instance string `json:&quot;instance&quot;`    Job      string `json:&quot;job&quot;`    Label    string `json:&quot;label&quot;`    Level    string `json:&quot;level&quot;`    Self     string `json:&quot;self&quot;`    Value    string `json:&quot;value&quot;`}type Result struct {    Metric Metric `json:&quot;metric&quot;`    Values string `json:&quot;values&quot;`}type PrometheusFlameData struct {    Status string `json:&quot;status&quot;`    Data   struct {        ResultType string   `json:&quot;resultType&quot;`        Result     []Result `json:&quot;result&quot;`    } `json:&quot;data&quot;`}</code></pre><p>PrometheusFlameData的其他数据从Prometheus的回包中拷贝过来即可, 重要的是PrometheusFlameData.Result</p><p>Result.Values: 是Value的数组, Value有且仅有两个元素, 第一个元素是数据对应的时间戳, 第二个元素是栈数据的<code>num</code>, <strong>这个已经不重要了, 火焰图并不需要每个节点的时间, 可以任意填充.</strong>, 如<code>[[1684829000,&quot;1&quot;]]</code></p><p>Result.Metric: 将栈数据转换成多叉树后, 前序遍历节点后得到的结果.</p><ul><li>Label: 函数名称(节点名称)</li><li>level: 层级</li><li>self: 自己作为栈最后一帧的数据数量</li><li>value: 自己和子节点所有self的合</li></ul><h2 id="PrometheusProxy处理"><a href="#PrometheusProxy处理" class="headerlink" title="PrometheusProxy处理"></a>PrometheusProxy处理</h2><p>将Grafana的请求原封不动, 转发给Prometheus进行处理, Prometheus数据返回后Proxy进行处理转换为火焰图插件数据格式, 进而返回给Grafana.</p><h1 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h1><h2 id="Prometheus存储数据的原理"><a href="#Prometheus存储数据的原理" class="headerlink" title="Prometheus存储数据的原理"></a>Prometheus存储数据的原理</h2><p>从上文<code>Prometheus协议</code>的格式来看, stack部分和values部分是分开的, 如果一个stack在多个时间被采集到, 只会存储新数据的时间和次数到values中.</p><p>这里提到的stack实际是一个字段, 此外还有线程名, 进程名等字段. 如果一整条上报数据是一样的, Prometheus只会存储时间和次数部分, 如果整条上报数据有一丝一毫差别 就会导致整条数据被记录一次. 导致空间占用暴增(因为stack很长).</p><p>说人话就是不要在字段中增加随机值, 否则会导致上报数据无法复用, 每次上报都要存储完成数据, 导致存储量爆炸.</p><h2 id="C-编译选项"><a href="#C-编译选项" class="headerlink" title="C++编译选项"></a>C++编译选项</h2><p>profile打印出完成的栈结构 需要在程序编译的时候 指定<code>-fno-omit-frame-pointer</code></p><h2 id="针对指定的URL和内容过滤"><a href="#针对指定的URL和内容过滤" class="headerlink" title="针对指定的URL和内容过滤"></a>针对指定的URL和内容过滤</h2><p>Grafana查询的URL是<code>/api/v1/query_range</code>, 对应的标签是cpu_func_profile, 可以只针对这种情况处理.</p><p>其他情况使用doProxy直接转发, 否则无法使用自动补全等一些提示</p><h2 id="profile采集频率"><a href="#profile采集频率" class="headerlink" title="profile采集频率"></a>profile采集频率</h2><p>由于profile需要消耗机器CPU, 可以采用每隔X分钟后运行Y分钟的profile, 将数据格式化后供Prometheus提取.</p><h2 id="半自由"><a href="#半自由" class="headerlink" title="半自由"></a>半自由</h2><p>火焰图准确与否与采集频率有很大关系, profile持续运行会消耗很多的CPU, 所以目前是采取了运行X分钟停止Y分钟的做法, 如果能持续运行profile就能解决这个问题.</p><h1 id="扩展-倒转火焰图"><a href="#扩展-倒转火焰图" class="headerlink" title="扩展-倒转火焰图"></a>扩展-倒转火焰图</h1><pre><code class="txt">func1#func2#func3func1#func3func2#func3func4#func3</code></pre><p>如上四个调用栈, 从火焰图上无法轻易看出来func3占用了过多的CPU, 换一种思路将栈倒过来, 就能发现func3占用了过多CPU, 这一步操作只需要在PrometheusProxy中调用一个函数倒转切割后的栈,就能实现.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;Linux服务器端可以使用profile生成火焰图. profile从运行开始收集数据, 结束运行时将结果输出, 过了这村就没这店.&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="项目制作" scheme="http://blog.lsmg.xyz/categories/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>写博客技巧</title>
    <link href="http://blog.lsmg.xyz/2023/11/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://blog.lsmg.xyz/2023/11/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%86%99%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-11-15T10:38:08.000Z</published>
    <updated>2025-02-27T06:39:40.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写博客技巧"><a href="#写博客技巧" class="headerlink" title="写博客技巧"></a>写博客技巧</h1><h2 id="文章分类和特点"><a href="#文章分类和特点" class="headerlink" title="文章分类和特点"></a>文章分类和特点</h2><p><strong>分类</strong></p><ul><li>大众科普</li><li>方案创新</li><li>项目总结</li><li>深度技术</li></ul><p><strong>特点</strong></p><ul><li>受众多样</li><li>通俗大众</li><li>传播属性</li><li>格式灵活</li></ul><h2 id="写文章的价值和作用"><a href="#写文章的价值和作用" class="headerlink" title="写文章的价值和作用"></a>写文章的价值和作用</h2><ol><li>温故而知新</li><li>便于传播分享, 及时发现问题</li><li>提高技术影响力</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>事前<ol><li>同理心, 确定目标读者</li><li>攒素材, 积累文章素材</li><li>定好题, 确定文章主题</li><li>搭骨架, 确定文章结构</li></ol></li><li>事中<ol><li>画好图, 绘制文章配图</li><li>有干货, 提升文章内容</li><li>勤润色, 反复润色文章</li></ol></li><li>事后<ol><li>练内功, 扩大阅读范围</li></ol></li></ol><h4 id="同理心-认知偏差"><a href="#同理心-认知偏差" class="headerlink" title="同理心-认知偏差"></a>同理心-认知偏差</h4><p>了解之后就难于理解不了解人的想法, 下意识认为对方已经了解某些知识点</p><ul><li>一些基础概念, 读者不一定了解</li><li>因果关系需要更进一步解释</li><li>站在读者角度考虑, 最好的方式是找没有背景同学检验</li><li>面相受众 What, Why, How</li><li>外行人看不懂, 内行人没必要看</li></ul><p>检测知识的最终途径, 将其传播给另一个没有背景的人</p><h4 id="攒素材"><a href="#攒素材" class="headerlink" title="攒素材"></a>攒素材</h4><p>写文章的时候捉襟见肘, 不要在决定写文章的时候 才去找素材. 素材积累之后可以整理出来.</p><p>有些粗粗看过的, 可能含有非常多的点</p><h4 id="定好主题"><a href="#定好主题" class="headerlink" title="定好主题"></a>定好主题</h4><p>确定主要范围, 不要歪楼, 不相关的简单介绍.</p><p>确定知识边界, 普适性的文章, 不需要从识字教起.</p><ul><li>工作总结</li><li>学习材料</li><li>热点话题</li><li>观察生活</li><li>深挖本质</li><li>巧用对比</li></ul><p>主题上升, 和更大的主题联系起来, 变归纳为聚焦</p><p>主题写明动作和动机</p><p>结构化思维: 穿线(讲通, 将多个知识点联系起来, 如从电路讲到程序运行), 归纳(小主题归纳到一个大范围,看看范围都有啥), 深挖(逐字逐句), 聚焦(只讨论关注的点, 将关注的点讲明白)</p><p>获取主题灵感: 发散思维, 逻辑思维, 同理心. 在平时多去关注一些</p><p>确认分享欲, 搜索相关主题(穿线很少), 思考对其他人是否有价值, 属于那种灵感来源, 主题上升, 标题是否是文章主要内容的一句话概括</p><p>标题小技巧, 图片中</p><h4 id="搭骨架"><a href="#搭骨架" class="headerlink" title="搭骨架"></a>搭骨架</h4><p>主题有了 素材有了</p><p>有规律 贴近旧有认知 利于大脑记忆</p><p>金字塔原理: 结构化思考, 沟通, 写作. 一本大厚书 芭芭拉明托</p><p><strong>结构化思维</strong></p><ul><li><p>梅切原则: 相互独立(没有交集), 完全穷尽(没有空隙)</p></li><li><p>简单性原理: 文章不需要面面俱到, 主线不相关内容, 可以考虑删减. 结构简单, 文字简省.</p></li><li><p>不要用复杂的东西解释另一个复杂的东西, 文章结构不要太复杂(精简层数 每层中case精简)</p></li></ul><h4 id="画好图"><a href="#画好图" class="headerlink" title="画好图"></a>画好图</h4><p>字不如数, 数不如表, 表不如图. 人脑处理图片相比文字更快</p><p>配图不一定需要时专业的, 主要目的是帮助理解 不一定需要多么严谨, 放在文章中能说明问题就好.</p><h4 id="有干货"><a href="#有干货" class="headerlink" title="有干货"></a>有干货</h4><p>取决于文章主题, 是否是水货</p><h4 id="勤润色"><a href="#勤润色" class="headerlink" title="勤润色"></a>勤润色</h4><p>语言晦涩, 排版不好, 多迭代, 反复打磨文章</p><p>语言精简(不能无脑删减), 内容分段, 准确(善用专业词汇 鼠标点两下(双击), 准确数字(90%)), 生动, 例子(不求多 命中要害, 极端例子 说明问题)</p><p>发表之前至少自己读一次. 善用AI润色, 重新解读不要机翻 机械搬</p><h4 id="练内功"><a href="#练内功" class="headerlink" title="练内功"></a>练内功</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写博客技巧&quot;&gt;&lt;a href=&quot;#写博客技巧&quot; class=&quot;headerlink&quot; title=&quot;写博客技巧&quot;&gt;&lt;/a&gt;写博客技巧&lt;/h1&gt;&lt;h2 id=&quot;文章分类和特点&quot;&gt;&lt;a href=&quot;#文章分类和特点&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>UP月记录</title>
    <link href="http://blog.lsmg.xyz/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E6%9C%88%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.lsmg.xyz/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP%E6%9C%88%E8%AE%B0%E5%BD%95/</id>
    <published>2023-10-27T09:48:22.000Z</published>
    <updated>2025-02-27T06:39:40.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="月记录备份"><a href="#月记录备份" class="headerlink" title="月记录备份"></a>月记录备份</h1><h2 id="2023-07"><a href="#2023-07" class="headerlink" title="2023-07"></a>2023-07</h2><p>以后写工具应该注意，一个工具放两个代码库维护是容易出问题的，能统一尽量统一，统一不了应该只在一个里面修改</p><ol><li>对方回复的内容一定要仔细理解，不要含主观臆断<ol><li>X场景下，……………………………（省略），这个功能就不需要了。（非X场景是需要的，不能直接删掉这个功能）</li><li>今天晚上就合入版本了（几点？能不能在全量发布服务器前完成，而不是晚上这种模糊时间）</li></ol></li><li>需求中途变更<ol><li>代码设计初期一般会留有一些考虑能够应对需求变化，但是需求变化后可能会导致实现可以简化，这个时候继续服用复杂的代码还是简化代码就需要考虑了</li></ol></li><li>多沟通协调<ol><li>后台有多个服务器，每个服务器不同的人负责，前台可能认为后台是一个整体，所以找你沟通的时候最好不要只考虑本服务器的事情。<ol><li>我这里完成了 前台认为所有服务器完成了</li></ol></li><li>对方代码还没合入的时候，你说对面完成了，结果实际没完成</li></ol></li><li>测试<ol><li>一个功能还是完整的测试吧，A功能虽然等于B+C功能，但B和C功能分别正确 不一定B+C就是正确的<ol><li>pyclient加上这个还是很方便的</li></ol></li></ol></li><li>GM工具<ol><li>GM工具好多都是有使用场景的，非使用场景使用会出现问题，所以还是要标注清楚</li></ol></li><li>流水线异常<ol><li>流水线异常的时候手动操作了报错部分，然而报错导致后续操作也被中断了，但是忘记了操作后续部分，只操作了报错部分<ol><li>流水线都现成的了 直接用吧 别手动操作了、</li></ol></li><li>新版服务器未更新到目标服务器 出了N个乌龙BUG单</li></ol></li></ol><h2 id="2023-08"><a href="#2023-08" class="headerlink" title="2023-08"></a>2023-08</h2><ol><li>兜底方案<ol><li>当时在众多人说自己无法进入游戏的时候，都没有去考虑补上兜底方案<ol><li>因为当时考虑到这些都是异常情况，正常情况玩家地图上是不会有自己的主城，只要是正常环境就没有问题</li><li>然而遇到了Logic崩溃了，Logic没有记录选州成功，此时大地图已经选州了，玩家游戏直接卡死，之后才把兜底补上。这次就不是异常情况了，是正常情况下可能会出现的问题了。</li></ol></li></ol></li><li>一个不起眼的小问题，可能背后的原因是非常离谱的。<ol><li>dev环境选州Logic崩溃，竟然是由于Logic代码写错的原因（为啥外网没有遇到呢？）</li><li>测试反馈添加的主城全部报错30000，结果是因为roleId循环的，已经添加主城的roleId再次添加主城，由于兜底机制+指定roleId主城存在就会将roleId顺延，顺延之后的就是空roleid，后面就拿不到离线时间的数据</li></ol></li><li>注重系统整体架构的设计<ol><li>有输入相比自己死磕能够成长的更快<ol><li>看看其他人的方案拆解<ol><li>不能同一帧将所有点位检查这种情况，才想到要延时进行刷新。</li><li>不能是单单的将需求点列出来，需要对应到具体的改动是啥，这样评估时间才准确。</li><li>注意下时间评估这里，目前我评估的时间还是非常的不准确的</li></ol></li><li>看看其他人的cr，不然自己没有负责过的模块 是一点都不清楚<ol><li>同时看了之后还有和其他人PK的机会</li><li>看看其他人的设计，学一学自己将来才可能遇到，不然都是在自己思维下兜圈子</li><li>看看别人的CR和方案，这里为什么这么设计，自己想的话如何设计，一下对比就出来了。进行后续沟通还能了解到更多。</li></ol></li></ol></li><li>之前看到帝国觉醒只是想到了战斗服需要在压力场景下减少发包<ol><li>但是大地图是不是需要呢？完全没有考虑过，大地图是否需要<ol><li>大地图实际是不需要的，至少目前的同步机制是够用的</li><li>战斗服可能是需要的，不过后面就没跟进了解了</li></ol></li><li>24年2月又做了不下发其他人的PET, 我为什么没想到呢?</li></ol></li><li>千人测试的时候，重启城郊会导致战斗服也需要重启的问题</li><li>千人测试的时候，Logic崩溃导致事件完成了任务没有完成</li></ol></li><li>输入<ol><li>代码</li><li>CR</li><li>方案拆解和评估</li><li>KM文章</li><li>开源项目</li></ol></li><li>注意点（不要将问题带到线上，这样处理起来非常的麻烦，而且会增加不靠谱）<ol><li>异常情况处理</li><li>兜底</li><li>自测</li></ol></li><li>需求拆解和方案评估<ol><li>不能是单单的将需求点列出来，需要对应到具体的改动是啥，这样评估时间才准确。</li><li>注意某些重要的异常情况处理和兜底处理</li></ol></li><li>之前删掉了一段代码，导致城郊出现问题，忘记为啥删除的了，后面修BUG还是带上BUG单的链接把<ol><li>没有强制检查, 保持的不太好</li></ol></li><li>防御性编程，校验外部传进来的参数</li><li>野怪最大等级改了获取位置，写代码的将等级为0认为是错误，直接返回了, 对于能跑的屎山小心动.<ol><li>然而赏金这里有特殊处理，等级是0则按1级</li></ol></li></ol><h2 id="2023-09"><a href="#2023-09" class="headerlink" title="2023-09"></a>2023-09</h2><ol><li>遇到BUG还是感觉留下现场，比重启解决问题更加重要<ol><li>问题可以后面解决，复现问题可能再也没有机会了</li></ol></li><li>编码规范<ol><li>空指针这种错误都犯了<ol><li>改一个位置的时候，尤其要注意使用的所有参数，这些参数可能在外面并没有校验</li><li>改代码比新写代码更容易出现</li></ol></li></ol></li><li>帮忙<ol><li>帮忙处理东西的时候，一定要搞清楚，问清楚。自己也要看清楚，不能只是不带脑子的执行了。</li></ol></li><li>注意可能发生死循环代码的兜底<ol><li>服务器更新脚本中就遇到了，重复的更新服务器。</li></ol></li><li>数值类的最好不要写死<ol><li>如果是配置中的值，配置变了，写死的数值就会导致问题</li><li>还可能导致本来热更就能搞定的，需要重新编译服务器</li></ol></li><li>可能还是要减少通用错误码的使用, 兜底的通用错误码竟然用到了.</li><li>客户端参数校验<ol><li>没想到出现了非联盟成员拆联盟建筑的问题。</li></ol></li><li>压测<ol><li>压测场景和实际场景不匹配<ol><li>出现问题之后，都能发现问题，关键是出现问题前发现限制点</li></ol></li><li>扩容<ol><li>寻路服爆炸了，然而没有办法扩容，没有机器。</li></ol></li></ol></li><li>重新编译的问题，没想到还学到了不少。<ol><li>tars文件重新生成的问题<ol><li>先用md5比对写了一版</li><li>结果还是直接用CMake写最好，几行的事情</li></ol></li><li>CMake和Make的基本原理</li><li>依赖分析，编译加速？</li></ol></li></ol><h2 id="2023-10"><a href="#2023-10" class="headerlink" title="2023-10"></a>2023-10</h2><ol><li>迁移日志<ol><li>最后日志传输工作给了运维来搞，自己搞还是太麻烦了<ol><li>该找运维的找运维了</li></ol></li><li>不要压缩超大包，或者进行分卷了<ol><li>解压起来对磁盘要求太高了(预期下当前所做是不是可以解决问题, 而不是只顾当前压缩)</li></ol></li></ol></li><li>性能优化感觉难点是发现性能问题, 包括编译加速. (20%的问题造成了80%的负面影响, 如果去处理另外80%的问题收益就很低)</li><li>下午看了看相关的博客，还是感觉要坚持输入一些内容，整理整理哪些可以看吧<ol><li>阮一峰, 内部论坛</li></ol></li><li>接触了下战斗服和逻辑服的代码, 把相关环境也搭建好了, 后续也确实看过几次对应的代码.</li><li>终于把之前想过的时间触发器抽了个Module出来, 后面就可以复用了. 写Module之前vscode中写下预期设计挺好的, 继续坚持了.</li><li>做事之前尽量确认好, 不然竹篮打水一场空, 时间浪费不少.<ol><li>需求理解一定要正确, 仔仔细细逐句逐句的看需求点.</li><li>看看需求的特殊要求, 比如退盟之后是否重置, 这个影响到了数据记录到哪里.</li><li>还得考虑下客户端是否支持</li><li>考虑下实现的复杂程度, 可能预期很简单, 但是因为牵扯过多或者不支持导致变得复杂.</li></ol></li><li>指定时间点触发的循环定时器, 每轮都计算下时间相比固定时间的更加稳定.</li><li>主城周围搜索物体, 采用涡旋状搜索, 类似蚊香.</li><li>有的功能大地图并不知道有没有, 还是说下不知道之类的吧, 最后接下来了发现是别人的工作.</li><li>代码BUG<ol><li>显性BUG, 状态校验放错了位置. 写的时候还是没考虑好运行路径.</li><li>隐形BUG, 抽函数后加东西, 导致相对于原有增加了一些功能, 这种是很危险的抽函数.</li></ol></li><li>看到小问题的时候 深究深究就会发现可能并不是那么简单<ol><li>转表工具报错, 空白列占位</li></ol></li><li>尽量统一函数对统一内容进行清除, 比如标志位, 这样方便发现错误清理的地方</li><li>指针判空, break<ol><li>这次是在JavaScript中没有判空, 有的block没有数据</li></ol></li><li>遇到问题即使下意识感觉问题就是那里, 也一定要确认下. 可能并不是那样.</li><li>如果解决一个小bug, 完美的方式改动很多的话, 感觉不如简单的处理下.<ol><li>长久来说, 还是要考虑下解决这个问题, 算是一个优化点? </li></ol></li><li>尽量不要写死参数, 配置或者计算得来, 否则后面还需要同步修改.</li><li>测试东西或者搞新东西的时候, 注意不要影响到旧的东西, 该开测试空间的开测试空间<ol><li>这次自动提单提了2K+, 如果不是提到了临时空间 估计直接爆炸了.</li></ol></li></ol><h2 id="2023-11"><a href="#2023-11" class="headerlink" title="2023-11"></a>2023-11</h2><ol><li>配置化<ol><li>IDC的流水线配置化了, 一些写死的内容移到了外面, 同时把流水线进行了统一, 不然一下改几条流水线直接升天</li></ol></li><li>查BUG<ol><li>仔细检查触发条件, 为什么这个场景触发了, 其他类似场景没触发, 这两个场景看起来很相似, 哪里有区别</li></ol></li><li>隐形问题, <strong>只有监控没有报警or明显提醒, 几乎相当于没有监控</strong>.<ol><li>磁盘炸了, 服务器对外无法提供服务.</li></ol></li><li>降本增效<ol><li>对于非重要数据, 用了Prometheus的双写服务, 把数据向自己搭建的服务器上同步一份, 这样就不用在腾讯云存储太长时间</li></ol></li><li>写BUG<ol><li>城郊里的功能 没有加开关, 影响到了大地图</li></ol></li><li>坚持记录每天所做所想, 不然忘了自己做了啥还是难受.</li><li>公共位置要使用公共账号和密码, 不把自己账号密码存进去, 容易出问题</li><li>当时看到经分文档里两个说明很别扭, ABBA格式, 不是ABAB, 想着容易出错, 结果真的把AB用反了.</li><li>7月就记录过了, GM工具标注使用场景, 结果到了11月还是没几个工具标注, 复习下.</li><li>JPS寻路算法学习, 这个得出的就不是最短路径</li><li><strong>移动接口的调用地方太多了, 结果搞出来了一个死循环的移动, A向B移动被修正到C点, A向B移动. 能够统一调用位置就好了.</strong></li><li>有的需求来来回回改的太多了, 加上后面加了新需求, 旧的代码没有删掉, 新旧代码同时作用导致表现有问题.<ol><li>说的就是回城控制</li></ol></li></ol><h2 id="2023-12"><a href="#2023-12" class="headerlink" title="2023-12"></a>2023-12</h2><ol><li>编译大小分析<ol><li>-fno-loop-optimize这个拖了很久,还搞了个乌龙出来</li><li><em>编译的时候没有-r, 用release和debug版本比较的, 最重要的是通知到群里的是乌龙信息</em></li></ol></li><li>日志分析, 看了看骏鹰的日志清洗相关的内容, 写了一个ES导出脚本, 这下可以一次查询所有的日志了, 还不会占用IO. 顺便把WARN也导出了, 只需要改一个字段.<ol><li><em>这个轮子是真TM的难用. 用开源的你就大大方方的用, 结果旧版本+乱搭配</em></li><li><em>后面还是尽量充当制定规则的, 整好文档, 减少被@的次数</em></li></ol></li><li>深入浅出编译链接, 看了看留了点印象, 但是也不太深</li><li>尝试优化elf文件大小<ol><li><em>大小可以减少, 得看看副作用具体是啥, 文档描述的不太清楚</em></li><li><em>变迁一下, elf是object文件合并的, 直接去统计下object文件获取更好, 已经帮忙分割开了.</em></li><li>两个方面<ol><li>整体优化, 通过添加编译选项, 去除非必要的debug信息</li><li>单独优化, 查看较大的object文件分析原因</li></ol></li></ol></li><li>gdb卡慢的原因分析<ol><li><em>目前来看就是卡在了符号表这里, 首次运行慢, 后续运行快</em></li><li><em>好像是首次跑火焰图</em></li></ol></li><li>C++避免重定义, 定义和声明分开<ol><li>增加inline</li><li>定义放到不会被include的文件中, 如cpp, h文件可能目前没有被include但是将来不一定</li></ol></li><li>小需求<ol><li>死亡军队过期兜底删除<ol><li><em>现在写别人分配的一句话需求, 小心不少了, 基本都会问清楚.</em></li></ol></li><li>城郊拾取不再强行要求有军队</li><li>联盟领地buff</li></ol></li><li>怪物组复活和自动拾取逻辑修改<ol><li>怪物组复活这里最开始通过事件处理已经理不清了, 换成了定时器检测.</li><li>自动拾取这里有一个参数一直都用错了, 最后的目标不一定是击败者</li><li><em>感觉开始处理还是取巧了一些, 结果后面要重写了</em></li></ol></li><li>查看是啥问题导致global更新不上去的, 打包global版本服务器<ol><li><em>很迷的问题, 换成request好了一点</em></li></ol></li><li>竞技场支持怪物组和BOSS<ol><li><em>小需求, 但是这个需求整体还是很大的, 周边系统还是要去看一看</em></li><li>JJC需求</li><li>定时器修改</li></ol></li><li>堡垒刷新bug的修复, <em>当时刷新理解的有偏差, 导致写了bug出来, 进了新的阶段刷新不出新堡垒</em>, 验收和测试也没发现, 最后修的时候真的是火急火燎的.</li></ol><h2 id="2024-1"><a href="#2024-1" class="headerlink" title="2024-1"></a>2024-1</h2><ol><li>整了个编译发布流水线的历史变更记录, 希望能总结出一点东西, 毕竟这个东西变更了太多版本了, 为什么没有一开始一步到位, 是有哪些问题之类的.</li><li>bug部分和up部分都拆出去了, 这里就搞下汇总之类的, bug那边也能写点记录, 方便后续查看</li><li>上周六终于是找了个腾讯学堂的视频看完了, 写了点总结, 这貌似是我接近两年来, 第一次看完历史视频并写笔记? 之前只整理过直播如何写博客的</li><li>占矿<ol><li>起初是想用击败者, <strong>结果参数用错了</strong>, 参数并不是击败者. 不过就算是<strong>用对了, 也会有参数为空的情况出现</strong>.</li><li>改成从战败者的follower中选取, 但是被击败这个事件中, 野怪的follower信息被清理了, 所以提前进行判断, 结果发起的<strong>MoveTo会被后续的覆盖</strong>, 改成立即移动之后依然有问题.</li><li>此外还有一个问题, 依赖战死和取消战斗状态, 提前之后就会被影响.</li><li>直接改成了从玩所有军队中获取, 改回了之前的阶段, 结果军队列表中存在死亡的军队. 过滤了死亡军队目前正常了.</li></ol></li><li>我大意了.jpg<ol><li>事件监听错, 本该是A事件, 结果监听了B事件.</li><li>误删正常代码</li></ol></li><li>考虑不全面<ol><li>参数未判断, 0范围的视野也进行了添加.</li><li>开服日期之前启动服务器, 此时计时器需要为负天数. (这里还出过一个时区的问题)</li><li>恢复为旧的代码时, 旧代码已经不能执行了.</li></ol></li><li>做了没必要的<ol><li>直接过滤掉所有可能阻挡位置的遗忘堡垒点位, 不要为了展示高超的技术写复杂了.(之前做了太多额外功能了 百分比阻挡这些, 直接粗暴点就好)</li></ol></li></ol><h2 id="2024-2"><a href="#2024-2" class="headerlink" title="2024-2"></a>2024-2</h2><ol><li>增加成员变量之后需要考虑,构造函数, 拷贝构造函数, 移动构造函数, 赋值运算符<ol><li>漏掉之后会导致新字段丢失的问题, 比较难查.</li></ol></li><li>添加1和添加2分两步的RPC操作, 添加1到添加2之间会有时间间隔, 添加1之后执行的操作没有添加2的信息.<ol><li>有新增添加或者修改操作的时候, 可能添加1也需要修改, 支持直接添加这些字段, 分两步会有时间间隔.</li></ol></li><li>一些内容可以和策划对, 更简单的实现是否可行<ol><li>从击败军队还是所有军队中选一只去占矿</li></ol></li><li>看了podagent的实现, 本身podagent不需要任何特殊配置, 依托游戏服务器启动时向其中注册(socket)信息.</li></ol><h2 id="2024-3"><a href="#2024-3" class="headerlink" title="2024-3"></a>2024-3</h2><h2 id="2024-4"><a href="#2024-4" class="headerlink" title="2024-4"></a>2024-4</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;月记录备份&quot;&gt;&lt;a href=&quot;#月记录备份&quot; class=&quot;headerlink&quot; title=&quot;月记录备份&quot;&gt;&lt;/a&gt;月记录备份&lt;/h1&gt;&lt;h2 id=&quot;2023-07&quot;&gt;&lt;a href=&quot;#2023-07&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="个人记录" scheme="http://blog.lsmg.xyz/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="UP" scheme="http://blog.lsmg.xyz/tags/UP/"/>
    
  </entry>
  
  <entry>
    <title>游戏设计</title>
    <link href="http://blog.lsmg.xyz/2023/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://blog.lsmg.xyz/2023/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-10-24T10:38:08.000Z</published>
    <updated>2025-02-27T06:39:40.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏设计"><a href="#游戏设计" class="headerlink" title="游戏设计"></a>游戏设计</h1><h2 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h2><h3 id="可靠UDP的实现"><a href="#可靠UDP的实现" class="headerlink" title="可靠UDP的实现"></a>可靠UDP的实现</h3><p>资料学习<br>TCP为什么可靠<br>超时重传、流量控制和拥塞控制<br>TCP使用基于ACK的方式来处理分组丢失。如果每次只发送一个分组，等到ACK到达后再发送后续分组，这种简单的模式下依然存在着下面的问题。</p><ol><li>要等待ACK多长时间？</li><li>分组或ACK丢失了怎么办？<br>由于网络传输是双向的，发送一个分组后等待ACK，会导致发送方向或接收方向的网络处于相对空闲的状态。为了提高效率，需要向网络中发送多个分组。虽然提升了效率，但也带来了更多的问题</li><li>一次发送多少个分组？</li><li>分组较多时，以什么样的时间间隔发送分组？</li><li>接收方如何知道哪些分组被接收到了，哪些还没有？<br>发送分组数和发送间隔，受接收方处理效率及网络通道处理效率的限制<br>超时重传<br>虽然可以选取过去一段时间分组的平均RTT来预测接下来一段时间分组的平均RTT，但由于平均值的局限性，会存在大量低于和高于平均值的RTT，高于平均值的RTT的分组将会被认为丢失，然而这些分组并没有丢失。所以超时时间应该高于平均RTT。<br>RTO：超时时间<br>RTT：发送后到接收到ACK的时间<br>没有发生超时时，RTO是根据RTT计算得来。发生超时后，为了防止重传二义性的问题，RTO=RTOx2，直到不发生超时，恢复之前的算法。<br>滑动窗口<br>滑动窗口协议解决了问题5。发送窗口中记录着哪些分组已经被确认接收、哪些分组发送了还未被确认接收以及哪些分组已经就绪但还未发送。接收窗口中记录着哪些分组已经被接收和确认，哪些分组将会被接收进而等待确认以及哪些分组无法被接收进而丢弃。<br>不过滑动窗口也带来了下面的问题</li><li>发送和接收窗口应该设置为多大<br>流量控制<br>使用窗口进行流量控制，窗口分为滑动窗口和拥塞窗口。<br>● 滑动窗口的大小（rwnd）表示接收方的缓存大小<br>● 拥塞窗口的大小（cwnd）表示发送后但未被确认的数据包大小<br>发送方发送窗口大小（橙色部分）为接受方接收窗口大小<br>发送方发送后未被确认的数据量（黑框中部分）<br>最终发送的数据量由发送窗口和拥塞窗口中较小的一方限制。</li></ol><p>基于窗口的流量控制<br>为了处理接收方处理效率相对发送方低的问题，使用基于窗口的流量控制。接收方需要告知发送方其接收窗口的大小。这样发送方就可以根据接收方的窗口大小来调整发送窗口的大小。</p><p>基于拥塞控制的流量控制<br>为了处理网络通道之间所有中转设备和线路限制导致的问题，使用拥塞控制来解决。</p><p>TCP高延迟原因<br>TCP协议中规定了，发生超时时，RTO=RTOx2。超时时间的增长，导致数据包在真正丢失时，无法被及时的重传，超时时间越长，无法被及时重传的情况越严重。</p><p>TCP使用ARQ模型中此编号K前所有包已收到。当K+1发生了丢失时，虽然K+2可能已经收到，但发送端无法得知K+2和之后数据包的情况，只能全部重传，进而出现不必要的重发。TCP中的SACK？</p><p>SACK<br><a href="https://www.rfc-editor.org/rfc/rfc2018" target="_blank" rel="noopener">https://www.rfc-editor.org/rfc/rfc2018</a><br>MTU为1500<br>MSS最大为1460<br>TCP额外包头最大为60字节。SACK需要消耗8*n+2字节的额外包头长度，所以理论最多描述4段block，不过由于时间戳消耗10字节的额外包头长度，所以实际为3段block。</p><p>UDP为什么不可靠<br>UDP如何可靠<br>涉及到功能的选择和切换<br>KCP协议<br><a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener">https://github.com/skywind3000/kcp</a></p><p>相关工具<br>丢包模拟</p><h3 id="与平台无关的可靠UDP"><a href="#与平台无关的可靠UDP" class="headerlink" title="与平台无关的可靠UDP"></a>与平台无关的可靠UDP</h3><h2 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h2><h3 id="帧同步的后台设计"><a href="#帧同步的后台设计" class="headerlink" title="帧同步的后台设计"></a>帧同步的后台设计</h3><h3 id="帧同步的前台设置（UE4）"><a href="#帧同步的前台设置（UE4）" class="headerlink" title="帧同步的前台设置（UE4）"></a>帧同步的前台设置（UE4）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;游戏设计&quot;&gt;&lt;a href=&quot;#游戏设计&quot; class=&quot;headerlink&quot; title=&quot;游戏设计&quot;&gt;&lt;/a&gt;游戏设计&lt;/h1&gt;&lt;h2 id=&quot;传输&quot;&gt;&lt;a href=&quot;#传输&quot; class=&quot;headerlink&quot; title=&quot;传输&quot;&gt;&lt;/a&gt;传输&lt;/h
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://blog.lsmg.xyz/2023/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.lsmg.xyz/2023/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-10-20T18:38:08.000Z</published>
    <updated>2025-02-27T06:39:40.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创造型模式"><a href="#创造型模式" class="headerlink" title="创造型模式"></a>创造型模式</h1><p>单元生抽工厂</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>提供克隆接口, 能够对指定的物体进行克隆生成新物体.</p><h2 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h2><p>相对于工厂模式一次性获取产品, 生成器模式则是可以一步一步对产品进行组装, 组装完成后获取最终的产品.</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>系工厂, 有多个产品, 每个产品提供一个接口.</p><p>一个工厂可以获得本工厂生产的各种产品. 如日系工厂可以提供各种日式家具, 中系工厂可以提供各种中式家具.</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>苹果工厂, 提供统一的苹果生产接口.</p><p>通过向工厂获取接口传入不同的苹果种类, 获取对应的工厂.</p><p>要求红富士返回红富士工厂, 要求糖心苹果返回糖心苹果工厂, 由于都是工厂 所以外部不用关注具体是哪个工厂.</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>元代适外(室外)装桥组</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>将class中重复很多的字段抽取出来, 在多个类中共享这些重复的字段, 减少内存占用</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>经理设置秘书代理自己, 外部人员需要通过秘书向经理递交材料, 秘书还可能会对材料进行归纳总结.</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>给不兼容的物体设置包装类, 包装类能够和原本不兼容的对象协作.</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>复杂的系统提供简单的接口.</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>将一个对象放入封装对象中, 为对象添加新的功能.</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>通过固定的接口, 将一个整体分离成前台和后台, 前后互不关注具体实现, 只关注接口.</p><p>UI界面和操作系统通过一些固定的接口进行交互, UI界面不在乎是什么系统 只要能相应这些接口就行. 操作系统不在乎是什么UI, 只要通过固定的接口向自己发送请求即可.</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>将对象组合成树状结构, 对外一个接口就可能访问到所有叶子.</p><h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><p>模访状任命中备迭观策(模仿状任命中被爹观测)</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>父类中定义算法框架, 子类可以根据需求重写算法特定的步骤.</p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式 ?"></a>访问者模式 ?</h2><p>将算法和所需对象分离开来</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>不暴露底层数据结构的情况下, 遍历所有元素</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>将对象需要状态的操作都抽象出来放到状态父类中, 状态子类中根据自身的状态实现这些操作. 对象不需要关心当前的状态, 只需要根据操作调用对应函数即可, 状态的更新由状态子类负责.</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>将请求沿着处理链进行发送, 每个人都可以处理请求, 或者传递给下个人员.</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>将请求和相关参数包装成独立对象. 对立对象可以将方法参数化 延迟 或者压入队列, 还能实现撤销</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>禁止众多的对象随意互相耦合, 将请求发送给中介者由中介者进行转发. 例如一个塔台和多个飞机交流, 飞机只需要和一个塔台交流就能得知其他飞机的信息.</p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>对象需要实现保存状态和恢复状态的函数. 保存状态的函数将当前状态需要保存的数据生成快照. 管理器调用函数生成快照并保存起来, 当恢复状态的时候读取快照, 应用到对象上.</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>从众多的事件中订阅某个事件, 忽略其他事件.</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>将众多算法放到不同的类中, 是的可以通过简单的操作更换算法.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;创造型模式&quot;&gt;&lt;a href=&quot;#创造型模式&quot; class=&quot;headerlink&quot; title=&quot;创造型模式&quot;&gt;&lt;/a&gt;创造型模式&lt;/h1&gt;&lt;p&gt;单元生抽工厂&lt;/p&gt;
&lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>时间触发器</title>
    <link href="http://blog.lsmg.xyz/2023/10/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1-%E6%97%B6%E9%97%B4%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://blog.lsmg.xyz/2023/10/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1-%E6%97%B6%E9%97%B4%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2023-10-16T09:48:22.000Z</published>
    <updated>2025-02-27T06:39:40.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>游戏中有许多内容是每天凌晨0点更新, 有些玩法是每天0点都会更新, 有的则需要累积到一定天数才会更新, 累计的天数则是需要进行配置.</p><p>设计一个通用的配置Proto用来统一配置格式, 触发器模型就可以读取这些统一的配置 统一进行天数判断.</p><p>对于每天0点都会更新的, 每天触发一次. 对于累计天数的, 累计天数达到后进行触发.</p><p>触发的时候不主动调用业务代码, 而是采用发布指定事件的方式进行通知.</p><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><pre><code class="protobuf">enum TimeTriggerGamePlay{    TIME_TRIGGER_GAME_PLAY_NONE = 0;    TIME_TRIGGER_GAME_PLAY_NORMAL = 1;    TIME_TRIGGER_GAME_PLAY_REDOUBT = 2;}enum TimeTriggerType{    TIME_TRIGGER_DEFAULT = 0;    // 每小时触发    // TIME_TRIGGER_EVERY_HOUR = 1;    // 每天触发    // TIME_TRIGGER_EVERY_DAY = 2;    // 累计天数触发 从阶段1开始, 阶段2, 阶段3..    TIME_TRIGGER_DAY_ACCUMULATE = 3;}message TimeTriggerConfigItem{    // 所属玩法    TimeTriggerGamePlay trigger_game_play = 1;    // 触发器类型    TimeTriggerType trigger_type = 2;    // 进入新阶段开服天数    repeated int32 trigger_accumulate_day = 3;    // 是否启用    bool is_enable = 4;}message TimeTriggerConfig{    repeated TimeTriggerConfigItem trigger_config_item = 1;}message TimeTriggerMsg{    // 所属玩法    TimeTriggerGamePlay trigger_game_play = 1;    // 触发器类型    TimeTriggerType trigger_type = 2;    int32 now_hour = 3;    int32 now_stage = 4;}</code></pre><p>触发器</p><pre><code class="c++">enum CoreEventMainType{    CEVENT_MT_TIME_TRIGGER}enum CoreEventSubType{    CEVENT_ST_TIME_TRIGGER}// TimeTriggerMsg</code></pre><h1 id="循环定时器"><a href="#循环定时器" class="headerlink" title="循环定时器"></a>循环定时器</h1><p>对于每小时执行函数, 起初的写法是计算出当前小时剩余时间, 之后直接定时一个小时. 但这种方法一旦有时间偏差就会一直存在, 还会将偏差积累下来</p><p>后面改成了每轮循环都要计算下当前小时剩余时间, 这样后面几轮即使有误差 也会被修正过来.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;游戏中有许多内容是每天凌晨0点更新, 有些玩法是每天0点都会更新, 有的则需要累积到一定天数才会更新, 累计的天数则是需要进行配置.&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="模块设计" scheme="http://blog.lsmg.xyz/categories/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="时间触发器" scheme="http://blog.lsmg.xyz/tags/%E6%97%B6%E9%97%B4%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>个人UP</title>
    <link href="http://blog.lsmg.xyz/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP/"/>
    <id>http://blog.lsmg.xyz/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-UP/</id>
    <published>2023-10-16T09:48:22.000Z</published>
    <updated>2025-02-27T06:39:40.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>代码整洁之道中内容很多, 不过这里单单只有命名一节. 被提醒过几次命名不合适, 这部分就着重整理出来, 每次命名的时候都思考思考. 能立刻改善自然最好, 不能立刻也要逐步前进.</p><p><strong>名副其实、避免误导、使用读的出来的名称、避免可爱（要实用）</strong><br>看到名字就知道这个变量是个什么东西，theList就不知道是个什么东西，studentList就好一些。<br>不能变量描述的是A，实际是B。比如给Map类型起名List</p><p><strong>做有意义的区分</strong><br>a1，a2，a3这些就没啥意义，x，y，z就有了<br>book和theBook也没区别</p><p><strong>使用可以搜索的名称</strong><br>找7就非常难找，但是找DAY_PEER_WEEK就好找了</p><p><strong>避免思维映射</strong><br>不要起只有自己能理解的取巧的名称，其他人可能是理解不了的</p><p><strong>方法名使用动词或者动词短语</strong><br>get、set、is</p><p><strong>每个概念对应一个词</strong><br>tower是地图中编码里塔的名称，瞭望塔最好起名watchTower不要和其他冲突了。</p><p><strong>添加有意义的语境</strong><br>name是名字的意思，petName？playerName？无法区分<br>firstName，lastName，street，city，state，这些放一起能看出来是地址，但是单单一个state就看不出来了，不如addrState，或者使用Address类</p><p><strong>命名统一</strong><br>命名要统一，多个人合作的时候要提前商量好，复制粘贴代码后也要注意代码的命名。</p><p><strong>可以直接用机制来命名</strong><br>比如模数余数这些名词</p><p><strong>避免无意义修饰</strong><br>阶段是阶段 等级是等级，不要用阶段等级这种东西</p><p><strong>GPT</strong><br>多用用GPT，这个起名字真的好用, 很有参考价值</p><p><strong>break和nullptr</strong><br>switch-case丢失break, 指针没有判空, 写全新模块的时候基本遇不到, 重灾区是在原有位置加代码.</p><p><strong>注释</strong><br>命名的章节混进来一点点注释, 我感觉问题不大.</p><ol><li>复杂的功能描述下, 不然只有天才能<strong>立刻</strong>知道这一坨代码是干啥的</li><li>其他人或者连自己看起来都很怪的实现, 要说明下原因.</li></ol><h2 id="函数-写故事-反复打磨"><a href="#函数-写故事-反复打磨" class="headerlink" title="函数-写故事-反复打磨"></a>函数-写故事-反复打磨</h2><h3 id="book"><a href="#book" class="headerlink" title="book"></a>book</h3><p><strong>短小</strong><br>避免嵌套太多层</p><p><strong>只做一件事情，做好一件事情</strong><br>编写函数是为了将大一些的概念（函数名称），拆分成另一个抽象层上的一系列步骤。</p><ul><li>函数名下都是同一个抽象层的步骤，实际还是做了一件事。</li></ul><p>检查函数是否只做了一件事，可以看看函数是否可以再拆出一个函数</p><ul><li>函数不仅仅是单纯的重新全是代码，必须<strong>要改变抽象层级</strong></li></ul><p><strong>使用描述性的名称</strong><br>长的具有描述性的名称，比短的令人费解的名称要好。<br>IDE中改名很容易，可以多次修改找到一个最具描述性的名称</p><p><strong>函数参数</strong><br>限制传入bool参数，bool参数表明了，可能存在两个分支，为true一个为false一个，可以考虑拆成函数。<br>给函数取个名字，用来解释函数的意图、<strong>参数和顺序和意图</strong><br>assertEqual改成assertExpectedEqualsActual(Expected，actual)，能够<strong>减少记忆参数顺序的负担</strong>。</p><p><strong>无副作用</strong><br>函数承诺只做一件事情（函数名描述），但是<strong>还会做其他被藏起来的事情（函数名没有描述的）</strong>，这个就是函数会有的副作用。有人轻信了函数的名称，就会有这些藏起来的事情导致的风险。</p><p><strong>减少重复</strong></p><p><strong>结构化编程</strong><br>尽量保证函数只有一个出口，break，continue等语句限制使用。这些在短小函数中影响不是很大，但是在<strong>长函数</strong>中影响很大。</p><p><strong>反复打磨</strong><br>一步到位写出完美的代码是很难的，开始应该注重功能的实现，后面可以进行打磨（拆解函数、消除重复、修改名称）</p><h3 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h3><ol><li>向其他函数增加代码时，如果时独立代码，抽出函数</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="book-1"><a href="#book-1" class="headerlink" title="book"></a>book</h3><p>最好是使用代码本身当作注释，当一行或者一块代码需要注释的时候，可以考虑简化这些代码。<br>注释不能美化代码<br>通过增加变量来进行注释</p><p>错误的注释</p><ul><li>注释可能会误导使用者，错误的注释比起没有注释更麻烦。</li><li>随着代码更新，只改代码不改注释，注释可能无法再与代码对应上</li><li>真正起作用的是代码，不是注释。所以可能出现注释和功能对应不上的问题</li></ul><p>需要注释的地方</p><ul><li>反直觉的代码，这些代码由于某些特殊原因，以反直觉的方式出现</li><li>TODO</li><li>警示作用，某些代码可能具有破坏力</li><li>针对复杂的返回值进行说明（更好的方式是简化返回值）</li></ul><h3 id="经验-1"><a href="#经验-1" class="headerlink" title="经验"></a>经验</h3><ol><li>部分特殊的机制要加说明，不然就只有天才能<strong>立刻知道</strong>这里是什么意思了</li></ol><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ol><li>const能加的就加上吧</li><li>代码还是统一一些<ol><li>判断是不是0 用==0或者if统一一点</li></ol></li><li><strong>空指针这种错误都犯了</strong><ol><li>改一个位置的时候，尤其要注意使用的所有参数，这些参数可能在外面并没有校验</li><li>改代码比新写代码更容易出现</li></ol></li><li><strong>switch语句中丢失break</strong></li><li>注意可能发生死循环代码的兜底<ol><li>服务器更新脚本中就遇到了，重复的更新服务器。</li></ol></li></ol><h1 id="记录总结"><a href="#记录总结" class="headerlink" title="记录总结"></a>记录总结</h1><h2 id="屎山"><a href="#屎山" class="headerlink" title="屎山"></a>屎山</h2><h3 id="指针判空"><a href="#指针判空" class="headerlink" title="指针判空"></a>指针判空</h3><p>使用指针时，一定要注意进行判空</p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>switch中增加case的时候, 注意补齐break</p><h2 id="全新屎山-设计"><a href="#全新屎山-设计" class="headerlink" title="全新屎山-设计"></a>全新屎山-设计</h2><h3 id="需求设计"><a href="#需求设计" class="headerlink" title="需求设计"></a>需求设计</h3><ol><li>看需求文档的时候 根据文档先定协议</li><li>需求理解一定要正确, 仔仔细细逐句逐句的看需求点. 需求点找出来之后，判断好是哪个服务器来做。防止开发重复的事项。</li><li>一些需要多个服务器共同实现的功能，要协商好处理方式。</li><li>查看策划的文档的时候，还是有想当然的内容<ol><li>次数每天1天，上限5次。第1天想当然为5次，结果跟策划确认了是1次，而不是5次。</li></ol></li><li>写代码之前先在vscode进行下预期设计, 比直接撸起袖子写代码好很多.</li><li>看看需求的特殊要求, 比如退盟之后是否重置, 这个影响到了数据记录到哪里.</li><li>考虑下客户端或者其他模块是否能如自己预期提供支持<ol><li>可能预期的内容, 客户端根本没法做, 还是得服务器来做.</li></ol></li><li>考虑下实现的复杂程度, 可能预期很简单, 但是因为牵扯过多或者不支持导致变得复杂.</li><li>A场景下不用处理, 不代表B场景下不用处理</li><li>方案设计应该把框架性的描述到位<ol><li>这次的跨天代码，文档中描述了，但是没有完整描述放到哪里。结果放到了Ext中，后面又改成了Role中。</li></ol></li><li>反复想了很多次 感觉没有问题，然后就没有测试<ol><li>结果还是出了问题，跟预期的一样，把leader和member的标记清掉了</li></ol></li></ol><p><strong>加了新的子类型后没有适配</strong></p><ul><li>看到报错后 也没有去看原因</li><li>加了子类型也没看原有城郊BOSS的特殊处理</li><li>加了子类型也没通知客户端，<strong>应该是更改协议之后都要通知</strong></li></ul><p><strong>方案可能可以用，但是对于目前还能用的代码，这种改动就需要考量下了。</strong><br>现有的敌我判断，只需要在IsEnemy中加几行代码就可以了，大刀阔斧的去改成方案中的设计，可能会遇到很多的问题。<br>改动的时候应该考虑下改动小的方式？而不是去整一套新的方案。<br>复杂的方案为了通用性，后面维护起来也是很麻烦的。</p><h3 id="时间评估"><a href="#时间评估" class="headerlink" title="时间评估"></a>时间评估</h3><p>涉及增加Module + 协议 代码量200~300行 略微修改其他地方 1.5D</p><ol><li>需求拆解和方案评估<ol><li>不能是单单的将需求点列出来，需要对应到具体的改动是啥，这样评估时间才准确。</li><li>注意某些重要的异常情况处理和兜底处理</li></ol></li></ol><h2 id="全新屎山-制作"><a href="#全新屎山-制作" class="headerlink" title="全新屎山-制作"></a>全新屎山-制作</h2><h3 id="通用的机制应该尽可能能够复用"><a href="#通用的机制应该尽可能能够复用" class="headerlink" title="通用的机制应该尽可能能够复用"></a>通用的机制应该尽可能能够复用</h3><ol><li>在ext中新加了一个跨天的功能，但是这个功能其他ext可能也要用，应该放到上一级方便所有ext使用</li><li>终于把之前想过的时间触发器抽了个Module出来, 后面就可以复用了</li></ol><h3 id="一些临时的内容应该加足注释"><a href="#一些临时的内容应该加足注释" class="headerlink" title="一些临时的内容应该加足注释"></a>一些临时的内容应该加足注释</h3><p>比如明明可能有很多配置，按理来说应该是用参数索引，但是写死了，应该说明原因。</p><pre><code class="cpp">// 目前只有1条配置，先写死id为1const auto *config = GetResFactory().FindResStrongpointRewardCfg(1);</code></pre><h3 id="一定要处理好不兼容变更的兜底，如果影响到太多人，容易出问题还是要加上兜底"><a href="#一定要处理好不兼容变更的兜底，如果影响到太多人，容易出问题还是要加上兜底" class="headerlink" title="一定要处理好不兼容变更的兜底，如果影响到太多人，容易出问题还是要加上兜底"></a>一定要处理好不兼容变更的兜底，如果影响到太多人，容易出问题还是要加上兜底</h3><h3 id="预估时间后无法完成-没有及时通知"><a href="#预估时间后无法完成-没有及时通知" class="headerlink" title="预估时间后无法完成 没有及时通知"></a>预估时间后无法完成 没有及时通知</h3><p>应该及时通知，否则认为完成了，后面会出现各种问题。这次就是配置全换掉了 导致半成品的怪物组被启用了</p><h3 id="日志加的不够"><a href="#日志加的不够" class="headerlink" title="日志加的不够"></a>日志加的不够</h3><ol><li>查问题的时候比预期难太多了，后面补了两个主要位置的日志<ol><li>选举队长的位置 增加了旧队长和新队长的状态</li><li>创建怪物组的时候会打印 玩家ID 怪物组ID 怪物组的配置 这样发现问题的时候能够快速定位到创建位置，之后就能看到问题野怪的ID</li></ol></li></ol><h3 id="统一的工具仓库"><a href="#统一的工具仓库" class="headerlink" title="统一的工具仓库"></a>统一的工具仓库</h3><p>以后写工具应该注意，一个工具放两个代码库维护是容易出问题的，能统一尽量统一，统一不了应该只在一个里面修改.</p><h3 id="需求中途变更"><a href="#需求中途变更" class="headerlink" title="需求中途变更"></a>需求中途变更</h3><p>代码设计初期一般会留有一些考虑能够应对需求变化，但是需求变化后可能会导致实现可以简化，这个时候继续服用复杂的代码还是简化代码就需要考虑了</p><h3 id="尽量一步成型代码，后续修改容易顾此失彼，修改了这里忘了其他敌方"><a href="#尽量一步成型代码，后续修改容易顾此失彼，修改了这里忘了其他敌方" class="headerlink" title="尽量一步成型代码，后续修改容易顾此失彼，修改了这里忘了其他敌方"></a>尽量一步成型代码，后续修改容易顾此失彼，修改了这里忘了其他敌方</h3><h3 id="避免设计无用的东西"><a href="#避免设计无用的东西" class="headerlink" title="避免设计无用的东西"></a>避免设计无用的东西</h3><p>给堡垒加了adaptor，然而是一个函数能搞定的判断，多余了</p><h3 id="数值类配置化or计算化"><a href="#数值类配置化or计算化" class="headerlink" title="数值类配置化or计算化"></a>数值类配置化or计算化</h3><ol><li>数值类的最好不要写死<ol><li>如果是配置中的值，配置变了，写死的数值就会导致问题</li><li>还可能导致本来热更就能搞定的，需要重新编译服务器</li></ol></li><li>尽量不要写死参数, 配置或者计算得来, 否则后面还需要同步修改.</li></ol><h3 id="减少通用错误码的使用"><a href="#减少通用错误码的使用" class="headerlink" title="减少通用错误码的使用"></a>减少通用错误码的使用</h3><p>如果错误码一对一能够及时发现问题, 如果是多个地方使用的, 只能靠日志+看代码路径了.</p><h3 id="客户端参数校验"><a href="#客户端参数校验" class="headerlink" title="客户端参数校验"></a>客户端参数校验</h3><p>没想到出现了非联盟成员拆联盟建筑的问题。</p><h3 id="状态校验放错了位置-写的时候还是没考虑好运行路径"><a href="#状态校验放错了位置-写的时候还是没考虑好运行路径" class="headerlink" title="状态校验放错了位置. 写的时候还是没考虑好运行路径"></a>状态校验放错了位置. 写的时候还是没考虑好运行路径</h3><h2 id="全新屎山-装饰"><a href="#全新屎山-装饰" class="headerlink" title="全新屎山-装饰"></a>全新屎山-装饰</h2><h3 id="GM工具"><a href="#GM工具" class="headerlink" title="GM工具"></a>GM工具</h3><ol><li>开发的时候可以考虑好后续可能用到的GM工具，虽然会略微增加开发时间，但是后续用到的时候是真的方便</li><li>GM工具好多都是有使用场景的，非使用场景使用会出现问题，所以还是要标注清楚</li></ol><h2 id="旧屎山-修改"><a href="#旧屎山-修改" class="headerlink" title="旧屎山-修改"></a>旧屎山-修改</h2><h3 id="确定修改后果-注意一个函数都有哪些作用"><a href="#确定修改后果-注意一个函数都有哪些作用" class="headerlink" title="确定修改后果, 注意一个函数都有哪些作用"></a>确定修改后果, 注意一个函数都有哪些作用</h3><p>最大等级的BUG去掉InitModuleDependency中的广播后，确实去掉了开启时候的广播，但导致ClientConfig中的内容也没有被填写上。<br>且由于满阶段nextCheckInterval为0时添加的定时器 又掩盖了这个问题的及时发现 导致后面发现后改的挺急的</p><p>没有调用OnIdle出现的问题，结果加上OnIdle调用后影响到了回城</p><h3 id="把表现正确的当BUG修了"><a href="#把表现正确的当BUG修了" class="headerlink" title="把表现正确的当BUG修了"></a>把表现正确的当BUG修了</h3><p>这种还是要确认好，不然浪费双倍的时间</p><h3 id="删除代码时应该注意-删除原位置无用的内容"><a href="#删除代码时应该注意-删除原位置无用的内容" class="headerlink" title="删除代码时应该注意 删除原位置无用的内容"></a>删除代码时应该注意 删除原位置无用的内容</h3><p>新位置因为需要保证运行，所以一般不会出现问题，但是原位置的多余内容，一般不影响运行，不便于发现。</p><h3 id="查问题的时候-用物体的事件经过查问题挺方便的"><a href="#查问题的时候-用物体的事件经过查问题挺方便的" class="headerlink" title="查问题的时候 用物体的事件经过查问题挺方便的"></a>查问题的时候 用物体的事件经过查问题挺方便的</h3><h3 id="遇到BUG还是感觉留下现场，比重启解决问题更加重要"><a href="#遇到BUG还是感觉留下现场，比重启解决问题更加重要" class="headerlink" title="遇到BUG还是感觉留下现场，比重启解决问题更加重要"></a>遇到BUG还是感觉留下现场，比重启解决问题更加重要</h3><p>问题可以后面解决，复现问题可能再也没有机会了</p><h3 id="BUG修复关联BUG单"><a href="#BUG修复关联BUG单" class="headerlink" title="BUG修复关联BUG单"></a>BUG修复关联BUG单</h3><p>之前删掉了一段代码，导致城郊出现问题，忘记为啥删除的了，后面修BUG还是带上BUG单的链接把</p><h3 id="抽取函数注意不要影响到原区域功能"><a href="#抽取函数注意不要影响到原区域功能" class="headerlink" title="抽取函数注意不要影响到原区域功能"></a>抽取函数注意不要影响到原区域功能</h3><p>抽函数后加东西, 导致相对于原有增加了一些功能, 这种是很危险的抽函数.</p><h3 id="简单方式解决问题"><a href="#简单方式解决问题" class="headerlink" title="简单方式解决问题"></a>简单方式解决问题</h3><p>如果解决一个小bug, 完美的方式改动很多的话, 感觉不如简单的处理下</p><p>长久来说, 还是要考虑下解决这个问题, 算是一个优化点?</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试好了再转单，可能确实把当前问题修了，但导致其他问题出现"><a href="#测试好了再转单，可能确实把当前问题修了，但导致其他问题出现" class="headerlink" title="测试好了再转单，可能确实把当前问题修了，但导致其他问题出现"></a>测试好了再转单，可能确实把当前问题修了，但导致其他问题出现</h3><p>改了BUG不好好验证, 而是急着去查下一个BUG.</p><h3 id="全面测试-不留空缺"><a href="#全面测试-不留空缺" class="headerlink" title="全面测试, 不留空缺"></a>全面测试, 不留空缺</h3><p>战斗无法打起来</p><p>因为战斗无法打起来，好多地方开发的时候都没有测试到，结果反而这里才是问题所在</p><h3 id="A通过B通过不等于A-B通过"><a href="#A通过B通过不等于A-B通过" class="headerlink" title="A通过B通过不等于A+B通过"></a>A通过B通过不等于A+B通过</h3><p>一个功能还是完整的测试吧，A功能虽然等于B+C功能，但B和C功能分别正确 不一定B+C就是正确的</p><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><p>pyclient这个还是很方便的</p><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><h3 id="问题的优先级安排"><a href="#问题的优先级安排" class="headerlink" title="问题的优先级安排"></a>问题的优先级安排</h3><p>下午差城郊防守建筑的BUG查上头了，虽然查出来了但导致了开战距离BUG的延迟了，进而导致了赏金联调的滞后。下午的时候防守建筑的BUG实际可以延后的</p><h3 id="充分关注自己的工作"><a href="#充分关注自己的工作" class="headerlink" title="充分关注自己的工作"></a>充分关注自己的工作</h3><p>赏金都开始联调了，我的功能还没发上去</p><h3 id="不懂就问"><a href="#不懂就问" class="headerlink" title="不懂就问"></a>不懂就问</h3><ol><li>之前一直不知道转测时候填的内容有什么用，导致填的比较随意，导致后面还有同学来提醒，最开始填的时候也确实没有问过。</li><li>还是多问问那个sql语句是啥，原来是描述用的。。。</li></ol><h3 id="重视不起眼的小问题，可能背后的原因是非常离谱的"><a href="#重视不起眼的小问题，可能背后的原因是非常离谱的" class="headerlink" title="重视不起眼的小问题，可能背后的原因是非常离谱的"></a>重视不起眼的小问题，可能背后的原因是非常离谱的</h3><ol><li>dev环境选州Logic崩溃，竟然是由于Logic代码写错的原因（为啥外网没有遇到呢？）</li><li>测试反馈添加的主城全部报错30000，结果是因为roleId循环的，已经添加主城的roleId再次添加主城，由于兜底机制+指定roleId主城存在就会将roleId顺延，顺延之后的就是空roleid，后面就拿不到离线时间的数据</li><li>转表提交报错, 原因是空白行没有被标记占用, 导致新加字段写到了注释行上.</li></ol><h3 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h3><ol><li>野怪最大等级改了获取位置，写代码的将等级为0认为是错误，直接返回了<ol><li>然而赏金这里有特殊处理，等级是0则按1级</li></ol></li></ol><h3 id="预期下当前所做是不是可以解决最终问题-而不是当前某一步"><a href="#预期下当前所做是不是可以解决最终问题-而不是当前某一步" class="headerlink" title="预期下当前所做是不是可以解决最终问题, 而不是当前某一步"></a>预期下当前所做是不是可以解决最终问题, 而不是当前某一步</h3><ol><li>压缩了个超大包, 确实解决了压缩的问题, 但是传输麻烦死了</li></ol><h3 id="去看看别人负责的模块-不要只顾自己的模块"><a href="#去看看别人负责的模块-不要只顾自己的模块" class="headerlink" title="去看看别人负责的模块, 不要只顾自己的模块"></a>去看看别人负责的模块, 不要只顾自己的模块</h3><ol><li>接触了下战斗服和逻辑服的代码, 把相关环境也搭建好了, 后续也确实看过几次对应的代码.</li></ol><h3 id="遇到问题即使下意识感觉问题就是那里-也一定要确认下-可能并不是那样"><a href="#遇到问题即使下意识感觉问题就是那里-也一定要确认下-可能并不是那样" class="headerlink" title="遇到问题即使下意识感觉问题就是那里, 也一定要确认下. 可能并不是那样"></a>遇到问题即使下意识感觉问题就是那里, 也一定要确认下. 可能并不是那样</h3><h2 id="沟通和协作"><a href="#沟通和协作" class="headerlink" title="沟通和协作"></a>沟通和协作</h2><h3 id="他人回复的内容一定要仔细理解，不要含主观臆断"><a href="#他人回复的内容一定要仔细理解，不要含主观臆断" class="headerlink" title="他人回复的内容一定要仔细理解，不要含主观臆断"></a>他人回复的内容一定要仔细理解，不要含主观臆断</h3><ol><li>X场景下，……………………………（省略），这个功能就不需要了。（非X场景是需要的，不能直接删掉这个功能）</li><li>今天晚上就合入版本了（几点？能不能在全量发布服务器前完成，而不是晚上这种模糊时间）</li></ol><h3 id="后台开发代表全部后台-前台开发代表全部前台"><a href="#后台开发代表全部后台-前台开发代表全部前台" class="headerlink" title="后台开发代表全部后台, 前台开发代表全部前台"></a>后台开发代表全部后台, 前台开发代表全部前台</h3><ol><li>后台有多个服务器，每个服务器不同的人负责，前台可能认为后台是一个整体，所以找你沟通的时候最好不要只考虑本服务器的事情。<ol><li>我这里完成了 前台认为所有服务器完成了</li></ol></li><li>对方代码还没合入的时候，你说对面完成了，结果实际没完成</li></ol><h3 id="不兼容变更时做好兜底"><a href="#不兼容变更时做好兜底" class="headerlink" title="不兼容变更时做好兜底"></a>不兼容变更时做好兜底</h3><ol><li>当时在众多人说自己无法进入游戏的时候，都没有去考虑补上兜底方案<ol><li>因为当时考虑到这些都是异常情况，正常情况玩家地图上是不会有自己的主城，只要是正常环境就没有问题</li><li>然而遇到了Logic崩溃了，Logic没有记录选州成功，此时大地图已经选州了，玩家游戏直接卡死，之后才把兜底补上。这次就不是异常情况了，是正常情况下可能会出现的问题了。</li></ol></li><li>重新编译的问题，没想到还学到了不少。<ol><li>tars文件重新生成的问题<ol><li>先用md5比对写了一版</li><li>结果还是直接用CMake写最好，几行的事情</li></ol></li><li>CMake和Make的基本原理</li><li>依赖分析，编译加速？</li></ol></li></ol><h3 id="帮忙"><a href="#帮忙" class="headerlink" title="帮忙"></a>帮忙</h3><p>帮忙处理东西的时候，一定要搞清楚，问清楚。自己也要看清楚，不能只是不带脑子的执行</p><h3 id="不要将问题带到线上，这样处理起来非常的麻烦，而且会增加不靠谱"><a href="#不要将问题带到线上，这样处理起来非常的麻烦，而且会增加不靠谱" class="headerlink" title="不要将问题带到线上，这样处理起来非常的麻烦，而且会增加不靠谱"></a>不要将问题带到线上，这样处理起来非常的麻烦，而且会增加不靠谱</h3><ol><li>异常情况处理</li><li>兜底</li></ol><h3 id="该找运维的找运维-对应的时间给对应的人去做"><a href="#该找运维的找运维-对应的时间给对应的人去做" class="headerlink" title="该找运维的找运维(对应的时间给对应的人去做)"></a>该找运维的找运维(对应的时间给对应的人去做)</h3><ol><li>最后日志传输工作给了运维来搞</li></ol><h3 id="有的功能大地图并不知道有没有-还是说下不知道之类的吧-最后接下来了发现是别人的工作"><a href="#有的功能大地图并不知道有没有-还是说下不知道之类的吧-最后接下来了发现是别人的工作" class="headerlink" title="有的功能大地图并不知道有没有, 还是说下不知道之类的吧, 最后接下来了发现是别人的工作"></a>有的功能大地图并不知道有没有, 还是说下不知道之类的吧, 最后接下来了发现是别人的工作</h3><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="CR发起前可以自己整一个临时CR看看代码"><a href="#CR发起前可以自己整一个临时CR看看代码" class="headerlink" title="CR发起前可以自己整一个临时CR看看代码"></a>CR发起前可以自己整一个临时CR看看代码</h3><h3 id="测试代码在最终CR的时候要及时去掉-使用TODO-名字方便检索"><a href="#测试代码在最终CR的时候要及时去掉-使用TODO-名字方便检索" class="headerlink" title="测试代码在最终CR的时候要及时去掉 使用TODO 名字方便检索"></a>测试代码在最终CR的时候要及时去掉 使用TODO 名字方便检索</h3><h3 id="不建议手动操作自动化代码"><a href="#不建议手动操作自动化代码" class="headerlink" title="不建议手动操作自动化代码"></a>不建议手动操作自动化代码</h3><ol><li>流水线异常的时候手动操作了报错部分，然而报错导致后续操作也被中断了，但是忘记了操作后续部分，只操作了报错部分<ol><li>流水线都现成的了 直接用吧 别手动操作了</li></ol></li></ol><h3 id="自动化操作没有监管人"><a href="#自动化操作没有监管人" class="headerlink" title="自动化操作没有监管人"></a>自动化操作没有监管人</h3><p>新版服务器未更新到目标服务器 出了N个乌龙BUG单</p><h3 id="压测和扩容"><a href="#压测和扩容" class="headerlink" title="压测和扩容"></a>压测和扩容</h3><ol><li>压测<ol><li>压测场景和实际场景不匹配<ol><li>出现问题之后，都能发现问题，关键是出现问题前发现限制点</li></ol></li></ol></li><li>扩容<ol><li>寻路服爆炸了，然而没有办法扩容，没有机器。</li></ol></li></ol><h3 id="发现问题比解决问题更重要"><a href="#发现问题比解决问题更重要" class="headerlink" title="发现问题比解决问题更重要"></a>发现问题比解决问题更重要</h3><ol><li>性能优化感觉难点是发现性能问题, 包括编译加速. (20%的问题造成了80%的负面影响, 如果去处理另外80%的问题收益就很低)</li></ol><h3 id="指定时间点触发的循环定时器-每轮都计算下时间相比固定时间的更加稳定"><a href="#指定时间点触发的循环定时器-每轮都计算下时间相比固定时间的更加稳定" class="headerlink" title="指定时间点触发的循环定时器, 每轮都计算下时间相比固定时间的更加稳定"></a>指定时间点触发的循环定时器, 每轮都计算下时间相比固定时间的更加稳定</h3><h3 id="主城周围搜索物体-采用涡旋状搜索-类似蚊香"><a href="#主城周围搜索物体-采用涡旋状搜索-类似蚊香" class="headerlink" title="主城周围搜索物体, 采用涡旋状搜索, 类似蚊香"></a>主城周围搜索物体, 采用涡旋状搜索, 类似蚊香</h3><h3 id="尽量统一函数对统一内容进行清除-比如标志位-这样方便发现错误清理的地方"><a href="#尽量统一函数对统一内容进行清除-比如标志位-这样方便发现错误清理的地方" class="headerlink" title="尽量统一函数对统一内容进行清除, 比如标志位, 这样方便发现错误清理的地方"></a>尽量统一函数对统一内容进行清除, 比如标志位, 这样方便发现错误清理的地方</h3><h3 id="测试东西或者搞新东西的时候-注意不要影响到旧的东西-该开测试空间的开测试空间"><a href="#测试东西或者搞新东西的时候-注意不要影响到旧的东西-该开测试空间的开测试空间" class="headerlink" title="测试东西或者搞新东西的时候, 注意不要影响到旧的东西, 该开测试空间的开测试空间"></a>测试东西或者搞新东西的时候, 注意不要影响到旧的东西, 该开测试空间的开测试空间</h3><p>这次自动提单提了2K+, 如果不是提到了临时空间 估计直接爆炸了.</p><h2 id="充电"><a href="#充电" class="headerlink" title="充电"></a>充电</h2><ol><li>输入<ol><li>代码</li><li>CR</li><li>方案拆解和评估</li><li>KM文章</li><li>开源项目</li></ol></li></ol><p><strong>123</strong></p><ol><li>有输入相比自己死磕能够成长的更快<ol><li>看看其他人的方案拆解<ol><li>不能同一帧将所有点位检查这种情况，才想到要延时进行刷新。</li><li>不能是单单的将需求点列出来，需要对应到具体的改动是啥，这样评估时间才准确。</li><li>注意下时间评估这里，目前我评估的时间还是非常的不准确的</li></ol></li><li>看看其他人的cr，不然自己没有负责过的模块 是一点都不清楚<ol><li>同时看了之后还有和其他人PK的机会</li><li>看看其他人的设计，学一学自己将来才可能遇到，不然都是在自己思维下兜圈子</li><li>看看别人的CR和方案，这里为什么这么设计，自己想的话如何设计，一下对比就出来了。进行后续沟通还能了解到更多。</li></ol></li></ol></li><li>之前看到帝国觉醒只是想到了战斗服需要在压力场景下减少发包<ol><li>但是大地图是不是需要呢？完全没有考虑过，大地图是否需要<ol><li>大地图实际是不需要的，至少目前的同步机制是够用的</li><li>战斗服可能是需要的，不过后面就没跟进了解了</li></ol></li></ol></li><li>千人测试的时候，重启城郊会导致战斗服也需要重启的问题</li><li>千人测试的时候，Logic崩溃导致事件完成了任务没有完成</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;规范&quot;&gt;&lt;a href=&quot;#规范&quot; class=&quot;headerlink&quot; title=&quot;规范&quot;&gt;&lt;/a&gt;规范&lt;/h1&gt;&lt;h2 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命名&lt;/h2&gt;&lt;p&gt;代码整
      
    
    </summary>
    
    
      <category term="个人记录" scheme="http://blog.lsmg.xyz/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="UP" scheme="http://blog.lsmg.xyz/tags/UP/"/>
    
  </entry>
  
  <entry>
    <title>常用命令</title>
    <link href="http://blog.lsmg.xyz/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.lsmg.xyz/2023/10/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2023-10-16T09:48:22.000Z</published>
    <updated>2025-02-27T06:39:40.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="Clion-将Windows换行转换为Linux模式"><a href="#Clion-将Windows换行转换为Linux模式" class="headerlink" title="Clion-将Windows换行转换为Linux模式"></a>Clion-将Windows换行转换为Linux模式</h2><p><a href="https://stackoverflow.com/questions/2517190/how-do-i-force-git-to-use-lf-instead-of-crlf-under-windows" target="_blank" rel="noopener">how-do-i-force-git-to-use-lf-instead-of-crlf-under-windows</a></p><pre><code class="shell">git config --global core.eol lfgit config --global core.autocrlf inputgit rm -rf --cached .git reset --hard HEAD</code></pre><h2 id="VIM-amp-zsh设置"><a href="#VIM-amp-zsh设置" class="headerlink" title="VIM&amp;zsh设置"></a>VIM&amp;zsh设置</h2><p>VIM</p><pre><code class="vim">set expandtabset ts=4set shiftwidth=4set sts=4set tw=100set numberset cinoptions=:0,g0,(0,w1set backspace=indent,eol,start&quot; set smartindentset autoindentset cindentset softtabstop=4set tabstop=4set enc=utf-8set nocompatiblesyntax onset fileencodings=ucs-bom,utf-8,gb18030,latin1set nobackupset undofileset undodir=~/.vim/undodirif !isdirectory(&amp;undodir)    call mkdir(&amp;undodir, &#39;p&#39;, 0700)endifif has(&quot;autocmd&quot;)  au BufReadPost * if line(&quot;&#39;\&quot;&quot;) &gt; 0 &amp;&amp; line(&quot;&#39;\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g`\&quot;&quot; | endifendifset pastetoggle=&lt;F2&gt;</code></pre><p>ZSH</p><pre><code class="zsh">plugins=(git zsh-autosuggestions zsh-syntax-highlighting autojump)</code></pre><h2 id="Make设置install指定文件"><a href="#Make设置install指定文件" class="headerlink" title="Make设置install指定文件"></a>Make设置install指定文件</h2><p><code>make install &lt;name&gt;</code></p><p><a href="https://stackoverflow.com/questions/9190098/for-cmakes-install-command-what-can-the-component-argument-do" target="_blank" rel="noopener">for-cmakes-install-command-what-can-the-component-argument-do</a></p><pre><code class="Makefile">install(TARGETS main RUNTIME DESTINATION ./install_dir/ COMPONENT main)add_custom_target(install_main COMMAND ${CMAKE_COMMAND} -DCOMPONENT=main -P ${CMAKE_BINARY_DIR}/cmake_install.cmake)</code></pre><h2 id="lsof-iftop"><a href="#lsof-iftop" class="headerlink" title="lsof iftop"></a>lsof iftop</h2><pre><code class="shell"># lsoflsof -i tcp:10002 -P-P 不解析端口号，直接显示# iftop-P 显示端口号-N 不解析端口号l 输入fileter，可以直接输入ip</code></pre><h2 id="安卓adb抓包"><a href="#安卓adb抓包" class="headerlink" title="安卓adb抓包"></a>安卓adb抓包</h2><pre><code class="shell">adb connect 127.0.0.1:port # （连接指定机器）adb devices # (列出所有设备)adb shell # （进入机器中 打开shell）adb push tcpdump /sdcard/... # (推送文件)adb pull /sdcard/1.pcap . # （拉取文件到本地）# wireshark左下角的灯是可以点的，可以列出来可疑项目</code></pre><p>抓取https(没有成功, 也还是记录一下)</p><pre><code class="shell"># https://github.com/frida/frida/releases 下载frida-server 注意要到非sdcard目录 否则不会给运行权限# adb后运行./frida-server# pip3 install frida-tools# 这条会自动启动目标app 所以tcpdump要提前准备好# 将产出的秘钥保存起来, Wireshark-Protocol-TLS 最下方加载frida -U -f jp.ne.paypay.android.app -l .\1.js</code></pre><pre><code class="text">// 1.jsfunction startTLSKeyLogger(SSL_CTX_new, SSL_CTX_set_keylog_callback) {    console.log(&quot;start----&quot;)    function keyLogger(ssl, line) {        console.log(new NativePointer(line).readCString());    }    const keyLogCallback = new NativeCallback(keyLogger, &#39;void&#39;, [&#39;pointer&#39;, &#39;pointer&#39;]);    Interceptor.attach(SSL_CTX_new, {        onLeave: function(retval) {            const ssl = new NativePointer(retval);            const SSL_CTX_set_keylog_callbackFn = new NativeFunction(SSL_CTX_set_keylog_callback, &#39;void&#39;, [&#39;pointer&#39;, &#39;pointer&#39;]);            SSL_CTX_set_keylog_callbackFn(ssl, keyLogCallback);        }    });}startTLSKeyLogger(    Module.findExportByName(&#39;libssl.so&#39;, &#39;SSL_CTX_new&#39;),    Module.findExportByName(&#39;libssl.so&#39;, &#39;SSL_CTX_set_keylog_callback&#39;))</code></pre><h2 id="安装Prometheus"><a href="#安装Prometheus" class="headerlink" title="安装Prometheus"></a>安装Prometheus</h2><pre><code class="sh">docker run -d -p 9090:9090 -v /data/prometheus/prometheus.yml:/data/prometheus/prometheus.yml -v /data/prometheus:/data/prometheus --user root --name prometheus prom/prometheus --config.file=/data/prometheus/prometheus.yml --storage.tsdb.path=/data/prometheus</code></pre><h2 id="火焰图生成"><a href="#火焰图生成" class="headerlink" title="火焰图生成"></a>火焰图生成</h2><pre><code class="sh"># -g enables call-graph recording -p pidperf record -F 99 -g -p 28470perf script &gt; perf.unfoldgit clone https://github.com/brendangregg/FlameGraph.git./stackcollapse-perf.pl perf.unfold &gt; perf.fold./flamegraph.pl perf.fold &gt; perf.svg</code></pre><h2 id="文件大小分析"><a href="#文件大小分析" class="headerlink" title="文件大小分析"></a>文件大小分析</h2><pre><code class="sh">objdump -dwarf=info XXXServer &gt; XXXServer.inforeadelf -e XXXServer# cmake选项-femit-struct-debug-baseonly</code></pre><h1 id="APK"><a href="#APK" class="headerlink" title="APK"></a>APK</h1><pre><code class="sh">keytool -genkey -v -keystore example-release-key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias example-key-aliasapksigner sign --ks example-release-key.jks --ks-key-alias example-key-alias --out example-signed.apk example.apkapksigner verify example-signed.apk</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h1&gt;&lt;h2 id=&quot;Clion-将Windows换行转换为Linux模式&quot;&gt;&lt;a href=&quot;#Clion-将Windows换行转换为Linux模式&quot;
      
    
    </summary>
    
    
      <category term="个人记录" scheme="http://blog.lsmg.xyz/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="常用命令" scheme="http://blog.lsmg.xyz/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>bpf</title>
    <link href="http://blog.lsmg.xyz/2023/10/Linux-ebpf/"/>
    <id>http://blog.lsmg.xyz/2023/10/Linux-ebpf/</id>
    <published>2023-10-11T17:00:22.000Z</published>
    <updated>2025-02-27T06:39:40.172Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="shell"># 查看内核版本# 一定要和最后install的版本一致$ uname -r4.18.0-348.7.1.el8_5.x86_64# 搜索包并显示版本$ yum search kernel-devel --showduplicates# 这个版本最匹配kernel-devel-4.18.0-348.7.1.el8_5.x86_64# 使用包含版本的完整包名安装$ yum install kernel-devel-4.18.0-348.7.1.el8_5.x86_64# header和devel版本一致$ yum install kernel-headers-4.18.0-348.7.1.el8_5.x86_64$ yum install -y bcc-tools# 加入环境目录,在~/.bashrc加入：$ export PATH=$PATH:/usr/share/bcc/tools/# 安装好后尝试执行下$ execsnoop</code></pre><p>BPF  实际起作用的一些代码，内核提供的接口。</p><p>BCC bpftrace  BPF前端</p><h2 id="BCC工具60秒快速检查"><a href="#BCC工具60秒快速检查" class="headerlink" title="BCC工具60秒快速检查"></a>BCC工具60秒快速检查</h2><h4 id="快速查看负载情况-1min-5min-15min"><a href="#快速查看负载情况-1min-5min-15min" class="headerlink" title="快速查看负载情况 1min 5min 15min"></a>快速查看负载情况 1min 5min 15min</h4><pre><code class="shell">$ uptime 10:45:40 up 205 days, 54 min,  1 user,  load average: 0.18, 0.16, 0.20</code></pre><p>如果1min的负载高于5min或者15min，说明当前正是高负载。</p><p>如果1min的负载低于5min或者15min，说明错过了高负载的现场，后续查看的数据都是非高负载情况的数据。</p><h4 id="查看当前机器的错误信息"><a href="#查看当前机器的错误信息" class="headerlink" title="查看当前机器的错误信息"></a>查看当前机器的错误信息</h4><pre><code class="shell">$ dmesg -T | tail -n 10</code></pre><p>T 打印可读的时间戳</p><h4 id="查看总体内存占用-总体CPU使用占比"><a href="#查看总体内存占用-总体CPU使用占比" class="headerlink" title="查看总体内存占用, 总体CPU使用占比"></a>查看总体内存占用, 总体CPU使用占比</h4><p>查看核心数量</p><pre><code class="shell">$ cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq 获取物理核心数量$ cat /proc/cpuinfo | grep &quot;processor&quot;　获取逻辑核心数量</code></pre><p>vmstat</p><pre><code class="shell">$ vmstat 1procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 1  0      0 253240 141064 1181400    0    0    79   101    0    0  2  2 96  0  0 0  0      0 252216 141064 1181404    0    0     0     0  881 1401  1  2 98  0  0 0  0      0 254328 141064 1181404    0    0     0     0  916 1397  1  1 98  0  0 0  0      0 254436 141064 1181416    0    0     0   152 1480 1894  3  8 88  1  0 0  1      0 254504 141064 1181412    0    0     8   488 1180 1743  2  2 96  1  0 0  0      0 254568 141064 1181412    0    0     0   128 1059 1667  2  1 97  1  0 0  0      0 254692 141064 1181412    0    0     0     0 1056 1723  1  1 98  0  0</code></pre><p>第一行数据由于工具的启动　不准确</p><ul><li>r 等待时间片的进程数量（等待IO时是睡眠状态，不需要等待时间片，所以这里不含阻塞在IO的进程） 大于CPU核心数量说明饱和。</li><li>free 单位KB 数字很大到不容易换算到GB说明内存充足 具体看free -m</li><li>si so 换入换出的数量, 非0时说明内存不足</li><li>us sy id wa st 用户 系统 空闲 等待IO 偷取时间 IO处理需要系统时间, 系统占比高可能指向系统IO效率低</li></ul><h4 id="分核心查看CPU占比-yum-install-sysstat"><a href="#分核心查看CPU占比-yum-install-sysstat" class="headerlink" title="分核心查看CPU占比 (yum install sysstat)"></a>分核心查看CPU占比 (yum install sysstat)</h4><pre><code class="shell">$ mpstat -P ALL 102:04:24 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle02:04:25 PM  all    0.99    0.00    0.50    0.00    0.00    0.50    0.00    0.00    0.00   98.0202:04:25 PM    0    0.98    0.00    0.98    0.00    0.00    0.98    0.00    0.00    0.00   97.0602:04:25 PM    1    1.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   99.00Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idleAverage:     all    4.64    0.00    1.31    0.28    0.53    0.17    0.00    0.00    0.00   93.07Average:       0    3.13    0.00    1.51    0.17    0.56    0.17    0.00    0.00    0.00   94.46Average:       1    6.14    0.00    1.12    0.39    0.50    0.17    0.00    0.00    0.00   91.68</code></pre><p>单个核心占用高, 指向单线程的问题</p><h4 id="分进程查看CPU占比"><a href="#分进程查看CPU占比" class="headerlink" title="分进程查看CPU占比"></a>分进程查看CPU占比</h4><pre><code class="shell">$ pidstat 102:06:42 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command02:06:43 PM     0     50128    1.00    0.00    0.00    0.00    1.00     1  qbittorrent-nox02:06:43 PM     0   1583327    0.00    1.00    0.00    0.00    1.00     1  YDService02:06:43 PM     0   1641467    0.00    1.00    0.00    0.00    1.00     0  barad_agent02:06:43 PM     0   3314936    0.00    1.00    0.00    0.00    1.00     1  pidstatAverage:      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  CommandAverage:        0        42    0.00    0.12    0.00    0.00    0.12     -  kworker/0:1H-kblockdAverage:        0       623    0.00    0.12    0.00    0.00    0.12     -  systemd-journalAverage:        0       948    0.38    0.12    0.00    0.12    0.50     -  tunedAverage:        0     50128    0.62    0.12    0.00    0.00    0.75     -  qbittorrent-noxAverage:        0   1583327    0.38    0.38    0.00    0.00    0.75     -  YDServiceAverage:        0   1641467    0.38    0.38    0.00    0.00    0.75     -  barad_agentAverage:        0   3202896    0.12    0.00    0.00    0.00    0.12     -  nodeAverage:        0   3313606    0.00    0.12    0.00    0.12    0.12     -  kworker/1:0-eventsAverage:        0   3314936    0.12    0.38    0.00    0.00    0.50     -  pidstat</code></pre><p>相比top, pidstat会将解锁保存到shell的缓冲区 方便观察变化趋势</p><h4 id="查看磁盘占用"><a href="#查看磁盘占用" class="headerlink" title="查看磁盘占用"></a>查看磁盘占用</h4><pre><code class="shell">$ iostat -xz 1</code></pre><p>%util 磁盘使用率<br>avgqu-sz 提交的任务数量, 超过1可能代表有问题</p><p>异步IO可能导致性能问题, 因为发起后操作系统不会拒绝, 且一个线程因为不被阻塞可以批量发起.</p><h4 id="查看内存占用"><a href="#查看内存占用" class="headerlink" title="查看内存占用"></a>查看内存占用</h4><pre><code class="shell">$ free -mh              total        used        free      shared  buff/cache   availableMem:          7.3Gi       5.8Gi       332Mi       3.0Mi       1.1Gi       1.2GiSwap:            0B          0B          0B</code></pre><h4 id="网卡占用"><a href="#网卡占用" class="headerlink" title="网卡占用"></a>网卡占用</h4><pre><code class="shell">$ sar -n DEV 102:21:23 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil02:21:24 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.0002:21:24 PM      eth0     56.00     50.00     17.92     12.95      0.00      0.00      0.00      0.0002:21:24 PM cni-podman0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutilAverage:           lo      8.43      8.43      0.75      0.75      0.00      0.00      0.00      0.00Average:         eth0     46.50     43.90      7.77     10.48      0.00      0.00      0.00      0.00Average:    cni-podman0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</code></pre><p>rxkB/s    txkB/s    收发速率</p><h4 id="网络连接建立和重传"><a href="#网络连接建立和重传" class="headerlink" title="网络连接建立和重传"></a>网络连接建立和重传</h4><pre><code class="shell">$ sar -n TCP,ETCP 102:25:04 PM  active/s passive/s    iseg/s    oseg/s02:25:05 PM      0.00      1.00      5.00      5.0002:25:04 PM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s02:25:05 PM      0.00      0.00      0.00      0.00      0.00Average:     active/s passive/s    iseg/s    oseg/sAverage:         0.50      0.75     10.50      9.75Average:     atmptf/s  estres/s retrans/s isegerr/s   orsts/sAverage:         0.00      0.00      0.00      0.00      0.25</code></pre><ul><li>active/s TCP连接connect速度</li><li>passive/s TCP连接accept速度</li><li>retrans/s 重传数量</li></ul><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>提供的数据很多, 但是一直再刷新, 导致很难看到变化相关. </p><p>Ctrl-S pause Ctrl-Q continue</p><h2 id="追踪系统调用"><a href="#追踪系统调用" class="headerlink" title="追踪系统调用"></a>追踪系统调用</h2><pre><code class="shell">#  追踪write系统调用 且筛选打开了文件描述符2的进程 strace -fe write `lsof -t &quot;/proc/$$/fd/2&quot; |sed &#39;s/^/-p/&#39;` -o write2.log# rdi是系统调用第一个参数 其次为rsi rdx r10 r8 r9b write if $rdi == 2# 8个字节 x 16进制 b以bytes为单位打印 x /8xb ptr</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# 查看内核版本
# 一定要和最后install的版本一致
$ uname -r
4.18.0-348.7.1.el8_5.x86_64
# 搜索包并显示版本
$ yum search kernel-devel --showdup
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="ebpf" scheme="http://blog.lsmg.xyz/tags/ebpf/"/>
    
  </entry>
  
  <entry>
    <title>架构</title>
    <link href="http://blog.lsmg.xyz/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%9E%B6%E6%9E%84/"/>
    <id>http://blog.lsmg.xyz/2023/04/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%9E%B6%E6%9E%84/</id>
    <published>2023-04-17T10:38:08.000Z</published>
    <updated>2025-02-27T06:39:40.174Z</updated>
    
    <content type="html"><![CDATA[<p>skynet 这个还没有看过</p><h2 id="游戏服务器端"><a href="#游戏服务器端" class="headerlink" title="游戏服务器端"></a>游戏服务器端</h2><h3 id="热更"><a href="#热更" class="headerlink" title="热更"></a>热更</h3><ul><li>函数替换</li><li>配置热更</li></ul><p>inject替换函数，配置热更</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul><li>日志压缩</li><li>战斗回放</li></ul><p>尽量详尽的日志</p><h3 id="监控和报警"><a href="#监控和报警" class="headerlink" title="监控和报警"></a>监控和报警</h3><p><strong>服务器是否有卡顿的现象</strong></p><p>客户端请求的平均响应速度</p><p><strong>玩家行为和投放监控</strong></p><p>某些操作是否超过了预期的设定，比如奖励获取等</p><h3 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h3><p>架构容错（服务器和进程挂掉了），外部服务挂掉（DB），异常情况下的保底逻辑，保证服务的整体可用</p><p>功能开关，关闭异常功能 修复后再打开。</p><p>玩家行为超出预期（所有列表都加个上限，操作频率上限）</p><p>系统行为超出预期（封号频率超过预期后需要预警）</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>不需要实时的系统，可用做成异步。（原神的抽卡记录就是非实时的）</p><p>一些排行榜更新也不一定需求实时，可以收集数据后每隔一段排行一次，（小优化？玩家本人的排行榜可以前台坐下处理进行预排行 让玩家以为看到的数据实时更新了？）</p><h3 id="消除单点和水平扩展"><a href="#消除单点和水平扩展" class="headerlink" title="消除单点和水平扩展"></a>消除单点和水平扩展</h3><p>集群的承载上限是集群中逻辑单点的承载上限，游戏架构设计中要尽可能的消除单点。存在单点是由于一些数据需要统计进行处理。水平拓展的方式能够增强稳定性，一个node挂掉不影响其他node。</p><p>消除单点的方式</p><ul><li>加一层分发逻辑，使用master服务器将请求分发到不同的node上，master服务器处理的逻辑简单、承载能力强，具体的操作交由node服务器处理</li><li>使用无状态，将数据和逻辑分离，逻辑执行时去db读取数据。上面的master服务器虽然依然是单点，但由于数据处理简单可以使用无状态的方式组建多组master-node服务器。</li></ul><p>游戏服务器中不需要消除所有的单点，只需要服务器的性能满足要求即可，避免过度优化。优化是需要开发和运维成本的。</p><h3 id="功能解耦和隔离"><a href="#功能解耦和隔离" class="headerlink" title="功能解耦和隔离"></a>功能解耦和隔离</h3><p>对于互不影响的功能（登录和创建队伍）可以拆分成多个服务。对于互相影响的功能（玩家个人逻辑，强化装备、锻造装备都需要操作玩家背包的多个数据）存在同一服务中，使用服务中模块的方式将这些操作隔离开。</p><p>服务之间进程隔离和线程隔离。</p><ul><li>线程隔离的不同服务之间可以通过函数调用的方式交互，不会存在RPC请求可能出现的失败情况。但是服务之间的隔离不是很强。</li><li>进程隔离的不同服务之间交互复杂，可能存在失败的情况，进程数量过多，增加管理和维护成本。但是隔离程度很高。</li></ul><p>隔离</p><ul><li>将服务分组，同组服务器放在同一进程中，不同组服务放到不同的进程中。</li><li>对于性能消耗高的服务，进行隔离，防止CPU打满影响到本线程的其他服务。</li><li>低于不稳定的服务器进行隔离，减少对稳定服务的影响。</li></ul><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>对于可能卡死服务的调用，应该使用超时机制，否则A服务出现问题B服务卡死，B服务卡死C服务器跟着卡死，就会出现雪崩影响到众多的功能。</p><p>超时的情况</p><ul><li>接受方没有接收到请求</li><li>接受方接收到了但是没有回应</li><li>请求放没有收到接受方的回应</li></ul><p>超时的处理方法</p><ul><li>忽略</li><li>重试</li></ul><p>由于要保证幂等性，重试逻辑很复杂。所以对于重要的服务才需要考虑重试，不重要的服务还是尽量选择忽略。使用超时后应该将游戏系统进行分割，对于核心的功能还是不要使用，非核心功能可以使用超时。</p><h3 id="回档"><a href="#回档" class="headerlink" title="回档"></a>回档</h3><p>使用了Redis的时候回档怎么解决。</p><h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><p>多级灰度环境，范围较大的改动 先在在灰度环境中上线 一段时间后 没有问题就可以正式上线了。</p><p>这里就涉及到了如何让部分玩家不进入正式环境而是进行灰度环境（测试服？直接修改玩家连接的服务器？）</p><p>如第一级灰度环境-公司内测试人员，第二级灰度-在线随机挑选。</p><h3 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h3><ul><li>开服，创建和登录账号 排队系统</li><li>广播，开服的时候人非常多 可以减少范围或者服务降级</li><li>玩家聚集，优化同步策略，逻辑分线</li><li>单点服务，会将部分CPU跑满并且出现一核有难八核围观的情况。</li><li>数据上限，各种列表设置上限，否则可能出现预期外的情况，好友列表爆满</li><li>全服玩家操作，如全服发送邮件等</li></ul><h3 id="动态扩容和缩容"><a href="#动态扩容和缩容" class="headerlink" title="动态扩容和缩容"></a>动态扩容和缩容</h3><p>最好的情况是根据负载情况动态缩扩容，但目前的情况是冗余的服务器也是需要开销的，所以需要考虑的还是有部分的。</p><ul><li>云服务器可用区限制，同一个区域的机器可以使用内网IP访问，跨区域只能使用公网IP，这就涉及到了跨区域支持</li><li>动态缩容，将服务器标记为不可用，同时等到其中的玩家减少到一定程度后踢玩家下线（无感知），最后极少的玩家可以选择强制下线（可能有感知），也是分级的策略</li><li>自动化流程支持</li></ul><h2 id="服务端架构"><a href="#服务端架构" class="headerlink" title="服务端架构"></a>服务端架构</h2><h3 id="全区全服"><a href="#全区全服" class="headerlink" title="全区全服"></a>全区全服</h3><p>战斗服多地区混合部署, 玩家自动选择最优地区的服务器进行连接.</p><ul><li><p>战斗机房多Central共享使用</p></li><li><p>各个Central使用匹配服决定战斗地区(同地区, 同语言文化区域, 同首选战斗, 扩大匹配区域, 同Central)</p><ul><li>战斗机房网络中断: Central间心跳探测</li><li>客户端连接失败: 客户端到pingsvr的探测</li></ul></li><li><p>测不准</p><ul><li>机房到机房的探测数据不能代表用户到机房</li><li>历史数据变动大, 可信度不高</li></ul></li><li><p>合作难</p><ul><li>中小运营商众多</li><li>基建参差不齐</li></ul></li><li><p>变量多</p><ul><li>用户网络问题</li><li>手机杂乱</li><li>网络跨地区</li><li>物理故障</li></ul></li></ul><p>客户端到服务器</p><ul><li>预表现: 位置同步 技能前摇 拉扯. (降低抖动影响)</li><li>帧缓存: 针对网络环境动态调整缓存帧数量. (降低抖动影响)</li><li>协议优化. (减少下行包大小)<ul><li>精简帧: 减少不必要发包</li><li>数据压缩</li></ul></li><li>上行包优化. (降低丢包影响)<ul><li>根据重要程度对重要包使用可靠传输, 对不重要包采用非可靠传输</li><li>预测丢包, 进行快速ARQ</li></ul></li><li>下行包优化<ul><li>根据网络情况, 动态调整冗余端口. (降低抖动影响)</li><li>对网路丢包 拥塞进行也测, 动态调整补帧策略. (降低抖动影响)</li><li>网络不稳定时, 提高发包帧率. (降低抖动影响)</li><li>空帧合并通知. (改善传输效率)</li><li>不需要的重复操作包, 服务器进行合并或过滤. (减少下行包大小)</li><li>采用占用流量更小的冗余算法(FEC, Erasure Coding)(减少下行包大小)</li></ul></li><li>手机系统优化 (提升特定机型流畅度)</li><li>厂家硬件优化 (提升特定机型流畅度)<ul><li>天线, 网卡, 驱动, CPU调度等</li></ul></li><li>Linux系统调优 (降低抖动概率)<ul><li>绑定核心, 避免跨NUMA, 利用cpu cache, 网络多队列, 进程</li></ul></li><li>多机房部署 (降低延迟和丢包)<ul><li>多机房部署, 就近连接</li></ul></li></ul><p>从TCP/IP四层来看</p><ul><li>应用层<ul><li>表现层<ul><li>预表现</li><li>帧率优化</li></ul></li><li>逻辑层<ul><li>帧缓存</li></ul></li><li>帧同步网络层<ul><li>协议优化</li><li>上行包优化</li><li>下行包优化</li></ul></li></ul></li><li>系统调度层<ul><li>手机系统调优</li><li>Linux系统调优</li></ul></li><li>网络层<ul><li>MTU探测</li></ul></li><li>传输层<ul><li>网路诊断</li><li>TCP/UDP双发</li></ul></li><li>硬件层<ul><li>厂家硬件优化</li><li>多机房部署</li><li>云硬件优化</li></ul></li></ul><h3 id="预表现"><a href="#预表现" class="headerlink" title="预表现"></a>预表现</h3><ol><li>安全</li><li>流畅</li><li>多客户端一致</li></ol><p><strong>位置</strong></p><p>服务器每帧发送物体的速度和位置. AB帧之间, 客户端使用A帧的速度进行平滑移动. 收到B帧的时候, 使用B帧的位置以及时间偏差x速度计算物体真实位置. 时间偏差是服务器B帧结束到客户端收到B帧的时间差<code>当前时间 - (游戏开始时间 + 帧号 * 每帧时间)</code>.</p><p><strong>子弹</strong></p><p>只需要子弹的出生位置和速度就可以同步计算. 客户端负责计算特效, 服务器负责计算受伤信息.</p><p><strong>优化</strong></p><p>减少移动包: 从每个操作都发送 -&gt; 状态改变的时候发送</p><p><strong>弱网处理</strong></p><ol><li><p>延迟过大的时候进行提示</p></li><li><p>游戏开始时间受游戏开始包控制, 然而这个包的延迟是不确定的. 可以反推游戏开始时间, <code>当前时间 - 帧号 * 每帧时间</code>, 多次计算求平均值.</p></li></ol><p><strong>表现统一</strong></p><p>A输出, 做预表现后, 会导致A的表现时长比B多一段(RTT+帧时间), 预表现要考虑这段的平滑处理.</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><ul><li>服务器只做转发, 客户端读取操作进行计算.<ul><li>网络卡顿, 容易出现不一致 ?</li><li>相信客户端输入, 导致容易出现作弊.</li></ul></li><li>服务器计算后将结果发送给客户端<ul><li>unity放到服务器</li><li>重新开发碰撞计算, 位置计算</li></ul></li></ul><p>服务器发送战斗开始, 开始计算服务器帧. 客户端收到开始后计算客户端帧. 客户端将输出和所属帧发送给服务器, 服务器判断是否是当前帧, 如果是则计算输入, 如果过期则丢弃.</p><ul><li>延时过大容易导致客户端的输入被大量丢弃</li></ul><p>服务器接收客户端输入, 收到输入后保存. 如果帧没有结束则继续等待, 结束后则运算此帧, 并将结果发送给客户端.</p><ul><li>服务器接收客户端输入, 将输入保存到队列A中, 服务器在帧中执行队列B结束后, 切换AB队列. 服务器没帧结束后, 将变更推送给客户端.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;skynet 这个还没有看过&lt;/p&gt;
&lt;h2 id=&quot;游戏服务器端&quot;&gt;&lt;a href=&quot;#游戏服务器端&quot; class=&quot;headerlink&quot; title=&quot;游戏服务器端&quot;&gt;&lt;/a&gt;游戏服务器端&lt;/h2&gt;&lt;h3 id=&quot;热更&quot;&gt;&lt;a href=&quot;#热更&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
</feed>
